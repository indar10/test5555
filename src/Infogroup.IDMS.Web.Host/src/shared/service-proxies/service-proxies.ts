/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.6.0 (NJsonSchema v10.0.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccessObjectsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAccessObjectForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AccessObjects/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAccessObjectForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAccessObjectForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAccessObjectForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAccessObjectForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAccessObjectForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAccessObjectForEdit(id: number | null | undefined): Observable<GetAccessObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AccessObjects/GetAccessObjectForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessObjectForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessObjectForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAccessObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAccessObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccessObjectForEdit(response: HttpResponseBase): Observable<GetAccessObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccessObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccessObjectForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAccessObjectDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccessObjects/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccessObjects/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resolveTenantId(input: ResolveTenantIdInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendPasswordResetCode(input: SendPasswordResetCodeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordInput | null | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResetPasswordOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendEmailActivationLink(input: SendEmailActivationLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    activateEmail(input: ActivateEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    impersonate(input: ImpersonateInput | null | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    switchToLinkedAccount(input: SwitchToLinkedAccountInput | null | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchToLinkedAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAuditLogListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | null | undefined, entityId: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | null | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityPropertyChangeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }
}

@Injectable()
export class AutoSuppressesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param databasecDatabaseNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, databasecDatabaseNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAutoSuppressForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoSuppresses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (databasecDatabaseNameFilter !== undefined)
            url_ += "DatabasecDatabaseNameFilter=" + encodeURIComponent("" + databasecDatabaseNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAutoSuppressForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAutoSuppressForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAutoSuppressForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAutoSuppressForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAutoSuppressForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAutoSuppressForView(id: string | null | undefined): Observable<GetAutoSuppressForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoSuppresses/GetAutoSuppressForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAutoSuppressForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAutoSuppressForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAutoSuppressForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAutoSuppressForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAutoSuppressForView(response: HttpResponseBase): Observable<GetAutoSuppressForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAutoSuppressForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAutoSuppressForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAutoSuppressForEdit(id: string | null | undefined): Observable<GetAutoSuppressForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AutoSuppresses/GetAutoSuppressForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAutoSuppressForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAutoSuppressForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAutoSuppressForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAutoSuppressForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAutoSuppressForEdit(response: HttpResponseBase): Observable<GetAutoSuppressForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAutoSuppressForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAutoSuppressForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAutoSuppressDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AutoSuppresses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AutoSuppresses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDatabaseForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAutoSuppressDatabaseLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoSuppresses/GetAllDatabaseForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDatabaseForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDatabaseForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAutoSuppressDatabaseLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAutoSuppressDatabaseLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDatabaseForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAutoSuppressDatabaseLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAutoSuppressDatabaseLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAutoSuppressDatabaseLookupTableDto>(<any>null);
    }
}

@Injectable()
export class BatchQueuesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBatchQueueDto> {
        let url_ = this.baseUrl + "/api/services/app/BatchQueues/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBatchQueueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBatchQueueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfBatchQueueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBatchQueueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBatchQueueDto>(<any>null);
    }

    /**
     * @param queueId (optional) 
     * @return Success
     */
    getQueuesData(queueId: number | null | undefined): Observable<CreateOrEditBatchQueueDto> {
        let url_ = this.baseUrl + "/api/services/app/BatchQueues/GetQueuesData?";
        if (queueId !== undefined)
            url_ += "queueId=" + encodeURIComponent("" + queueId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQueuesData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQueuesData(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditBatchQueueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditBatchQueueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQueuesData(response: HttpResponseBase): Observable<CreateOrEditBatchQueueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditBatchQueueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditBatchQueueDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createOrEdit(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BatchQueues/CreateOrEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BrokersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param iIsActiveFilter (optional) 
     * @param selectedDatabase (optional) 
     * @param contactLastNameFilterText (optional) 
     * @param contactEmailFilterText (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBrokers(filter: string | null | undefined, iIsActiveFilter: number | null | undefined, selectedDatabase: number | null | undefined, contactLastNameFilterText: string | null | undefined, contactEmailFilterText: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBrokersDto> {
        let url_ = this.baseUrl + "/api/services/app/Brokers/GetAllBrokers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (iIsActiveFilter !== undefined)
            url_ += "iIsActiveFilter=" + encodeURIComponent("" + iIsActiveFilter) + "&"; 
        if (selectedDatabase !== undefined)
            url_ += "SelectedDatabase=" + encodeURIComponent("" + selectedDatabase) + "&"; 
        if (contactLastNameFilterText !== undefined)
            url_ += "ContactLastNameFilterText=" + encodeURIComponent("" + contactLastNameFilterText) + "&"; 
        if (contactEmailFilterText !== undefined)
            url_ += "ContactEmailFilterText=" + encodeURIComponent("" + contactEmailFilterText) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBrokers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBrokers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBrokersDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBrokersDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBrokers(response: HttpResponseBase): Observable<PagedResultDtoOfBrokersDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBrokersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBrokersDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBrokerForEdit(id: number | null | undefined): Observable<CreateOrEditBrokerDto> {
        let url_ = this.baseUrl + "/api/services/app/Brokers/GetBrokerForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrokerForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrokerForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditBrokerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditBrokerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrokerForEdit(response: HttpResponseBase): Observable<CreateOrEditBrokerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditBrokerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditBrokerDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditBrokerDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brokers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    exportToExcel(input: GetAllBrokersInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Brokers/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BuildLolsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxMasterLolIDFilter (optional) 
     * @param minMasterLolIDFilter (optional) 
     * @param lK_ActionFilter (optional) 
     * @param lK_ActionMonth1Filter (optional) 
     * @param lK_ActionMonth2Filter (optional) 
     * @param lK_ActionNextMonthFilter (optional) 
     * @param lK_QuantityTypeFilter (optional) 
     * @param lK_FileTypeFilter (optional) 
     * @param iSkipFirstRowFilter (optional) 
     * @param iIsActiveFilter (optional) 
     * @param maxiUsageFilter (optional) 
     * @param miniUsageFilter (optional) 
     * @param maxnTurnsFilter (optional) 
     * @param minnTurnsFilter (optional) 
     * @param cDecisionReasoningFilter (optional) 
     * @param cSlugDateFilter (optional) 
     * @param cBatchDateTypeFilter (optional) 
     * @param lK_SlugDateTypeFilter (optional) 
     * @param maxiQuantityPreviousFilter (optional) 
     * @param miniQuantityPreviousFilter (optional) 
     * @param maxiQuantityRequestedFilter (optional) 
     * @param miniQuantityRequestedFilter (optional) 
     * @param maxiQuantityReceivedDPFilter (optional) 
     * @param miniQuantityReceivedDPFilter (optional) 
     * @param maxiQuantityReceivedFilter (optional) 
     * @param miniQuantityReceivedFilter (optional) 
     * @param maxiQuantityConvertedFilter (optional) 
     * @param miniQuantityConvertedFilter (optional) 
     * @param maxdDateReceivedFilter (optional) 
     * @param mindDateReceivedFilter (optional) 
     * @param maxiQuantityTotalFilter (optional) 
     * @param miniQuantityTotalFilter (optional) 
     * @param cBatch_LastFROMFilter (optional) 
     * @param cBatch_LastTOFilter (optional) 
     * @param cBatch_FROMFilter (optional) 
     * @param cBatch_TOFilter (optional) 
     * @param order_NoFilter (optional) 
     * @param order_ClientPOFilter (optional) 
     * @param orderSelectionFilter (optional) 
     * @param order_FieldsFilter (optional) 
     * @param order_CommentsFilter (optional) 
     * @param order_Notes1Filter (optional) 
     * @param order_Notes2Filter (optional) 
     * @param lK_EmailTemplateFilter (optional) 
     * @param maxddateOrderSentFilter (optional) 
     * @param minddateOrderSentFilter (optional) 
     * @param cNoteFilter (optional) 
     * @param maxiCASApprovalToFilter (optional) 
     * @param miniCASApprovalToFilter (optional) 
     * @param cSourceFilenameReadyToLoadFilter (optional) 
     * @param cSystemFilenameReadyToLoadFilter (optional) 
     * @param lK_LoadFileTypeFilter (optional) 
     * @param lK_LoadFileRowTerminatorFilter (optional) 
     * @param cOnePassFileNameFilter (optional) 
     * @param maxdCreatedDateFilter (optional) 
     * @param mindCreatedDateFilter (optional) 
     * @param cCreatedByFilter (optional) 
     * @param maxdModifiedDateFilter (optional) 
     * @param mindModifiedDateFilter (optional) 
     * @param cModifiedByFilter (optional) 
     * @param cSQLFilter (optional) 
     * @param cSQLDescriptionFilter (optional) 
     * @param maxiLoadQtyFilter (optional) 
     * @param miniLoadQtyFilter (optional) 
     * @param lK_EncodingFilter (optional) 
     * @param iIsMultilineFilter (optional) 
     * @param buildLK_BuildStatusFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxMasterLolIDFilter: number | null | undefined, minMasterLolIDFilter: number | null | undefined, lK_ActionFilter: string | null | undefined, lK_ActionMonth1Filter: string | null | undefined, lK_ActionMonth2Filter: string | null | undefined, lK_ActionNextMonthFilter: string | null | undefined, lK_QuantityTypeFilter: string | null | undefined, lK_FileTypeFilter: string | null | undefined, iSkipFirstRowFilter: number | null | undefined, iIsActiveFilter: number | null | undefined, maxiUsageFilter: number | null | undefined, miniUsageFilter: number | null | undefined, maxnTurnsFilter: number | null | undefined, minnTurnsFilter: number | null | undefined, cDecisionReasoningFilter: string | null | undefined, cSlugDateFilter: string | null | undefined, cBatchDateTypeFilter: string | null | undefined, lK_SlugDateTypeFilter: string | null | undefined, maxiQuantityPreviousFilter: number | null | undefined, miniQuantityPreviousFilter: number | null | undefined, maxiQuantityRequestedFilter: number | null | undefined, miniQuantityRequestedFilter: number | null | undefined, maxiQuantityReceivedDPFilter: number | null | undefined, miniQuantityReceivedDPFilter: number | null | undefined, maxiQuantityReceivedFilter: number | null | undefined, miniQuantityReceivedFilter: number | null | undefined, maxiQuantityConvertedFilter: number | null | undefined, miniQuantityConvertedFilter: number | null | undefined, maxdDateReceivedFilter: moment.Moment | null | undefined, mindDateReceivedFilter: moment.Moment | null | undefined, maxiQuantityTotalFilter: number | null | undefined, miniQuantityTotalFilter: number | null | undefined, cBatch_LastFROMFilter: string | null | undefined, cBatch_LastTOFilter: string | null | undefined, cBatch_FROMFilter: string | null | undefined, cBatch_TOFilter: string | null | undefined, order_NoFilter: string | null | undefined, order_ClientPOFilter: string | null | undefined, orderSelectionFilter: string | null | undefined, order_FieldsFilter: string | null | undefined, order_CommentsFilter: string | null | undefined, order_Notes1Filter: string | null | undefined, order_Notes2Filter: string | null | undefined, lK_EmailTemplateFilter: string | null | undefined, maxddateOrderSentFilter: moment.Moment | null | undefined, minddateOrderSentFilter: moment.Moment | null | undefined, cNoteFilter: string | null | undefined, maxiCASApprovalToFilter: number | null | undefined, miniCASApprovalToFilter: number | null | undefined, cSourceFilenameReadyToLoadFilter: string | null | undefined, cSystemFilenameReadyToLoadFilter: string | null | undefined, lK_LoadFileTypeFilter: string | null | undefined, lK_LoadFileRowTerminatorFilter: string | null | undefined, cOnePassFileNameFilter: string | null | undefined, maxdCreatedDateFilter: moment.Moment | null | undefined, mindCreatedDateFilter: moment.Moment | null | undefined, cCreatedByFilter: string | null | undefined, maxdModifiedDateFilter: moment.Moment | null | undefined, mindModifiedDateFilter: moment.Moment | null | undefined, cModifiedByFilter: string | null | undefined, cSQLFilter: string | null | undefined, cSQLDescriptionFilter: string | null | undefined, maxiLoadQtyFilter: number | null | undefined, miniLoadQtyFilter: number | null | undefined, lK_EncodingFilter: string | null | undefined, iIsMultilineFilter: number | null | undefined, buildLK_BuildStatusFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBuildLolForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BuildLols/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxMasterLolIDFilter !== undefined)
            url_ += "MaxMasterLolIDFilter=" + encodeURIComponent("" + maxMasterLolIDFilter) + "&"; 
        if (minMasterLolIDFilter !== undefined)
            url_ += "MinMasterLolIDFilter=" + encodeURIComponent("" + minMasterLolIDFilter) + "&"; 
        if (lK_ActionFilter !== undefined)
            url_ += "LK_ActionFilter=" + encodeURIComponent("" + lK_ActionFilter) + "&"; 
        if (lK_ActionMonth1Filter !== undefined)
            url_ += "LK_ActionMonth1Filter=" + encodeURIComponent("" + lK_ActionMonth1Filter) + "&"; 
        if (lK_ActionMonth2Filter !== undefined)
            url_ += "LK_ActionMonth2Filter=" + encodeURIComponent("" + lK_ActionMonth2Filter) + "&"; 
        if (lK_ActionNextMonthFilter !== undefined)
            url_ += "LK_ActionNextMonthFilter=" + encodeURIComponent("" + lK_ActionNextMonthFilter) + "&"; 
        if (lK_QuantityTypeFilter !== undefined)
            url_ += "LK_QuantityTypeFilter=" + encodeURIComponent("" + lK_QuantityTypeFilter) + "&"; 
        if (lK_FileTypeFilter !== undefined)
            url_ += "LK_FileTypeFilter=" + encodeURIComponent("" + lK_FileTypeFilter) + "&"; 
        if (iSkipFirstRowFilter !== undefined)
            url_ += "iSkipFirstRowFilter=" + encodeURIComponent("" + iSkipFirstRowFilter) + "&"; 
        if (iIsActiveFilter !== undefined)
            url_ += "iIsActiveFilter=" + encodeURIComponent("" + iIsActiveFilter) + "&"; 
        if (maxiUsageFilter !== undefined)
            url_ += "MaxiUsageFilter=" + encodeURIComponent("" + maxiUsageFilter) + "&"; 
        if (miniUsageFilter !== undefined)
            url_ += "MiniUsageFilter=" + encodeURIComponent("" + miniUsageFilter) + "&"; 
        if (maxnTurnsFilter !== undefined)
            url_ += "MaxnTurnsFilter=" + encodeURIComponent("" + maxnTurnsFilter) + "&"; 
        if (minnTurnsFilter !== undefined)
            url_ += "MinnTurnsFilter=" + encodeURIComponent("" + minnTurnsFilter) + "&"; 
        if (cDecisionReasoningFilter !== undefined)
            url_ += "cDecisionReasoningFilter=" + encodeURIComponent("" + cDecisionReasoningFilter) + "&"; 
        if (cSlugDateFilter !== undefined)
            url_ += "cSlugDateFilter=" + encodeURIComponent("" + cSlugDateFilter) + "&"; 
        if (cBatchDateTypeFilter !== undefined)
            url_ += "cBatchDateTypeFilter=" + encodeURIComponent("" + cBatchDateTypeFilter) + "&"; 
        if (lK_SlugDateTypeFilter !== undefined)
            url_ += "LK_SlugDateTypeFilter=" + encodeURIComponent("" + lK_SlugDateTypeFilter) + "&"; 
        if (maxiQuantityPreviousFilter !== undefined)
            url_ += "MaxiQuantityPreviousFilter=" + encodeURIComponent("" + maxiQuantityPreviousFilter) + "&"; 
        if (miniQuantityPreviousFilter !== undefined)
            url_ += "MiniQuantityPreviousFilter=" + encodeURIComponent("" + miniQuantityPreviousFilter) + "&"; 
        if (maxiQuantityRequestedFilter !== undefined)
            url_ += "MaxiQuantityRequestedFilter=" + encodeURIComponent("" + maxiQuantityRequestedFilter) + "&"; 
        if (miniQuantityRequestedFilter !== undefined)
            url_ += "MiniQuantityRequestedFilter=" + encodeURIComponent("" + miniQuantityRequestedFilter) + "&"; 
        if (maxiQuantityReceivedDPFilter !== undefined)
            url_ += "MaxiQuantityReceivedDPFilter=" + encodeURIComponent("" + maxiQuantityReceivedDPFilter) + "&"; 
        if (miniQuantityReceivedDPFilter !== undefined)
            url_ += "MiniQuantityReceivedDPFilter=" + encodeURIComponent("" + miniQuantityReceivedDPFilter) + "&"; 
        if (maxiQuantityReceivedFilter !== undefined)
            url_ += "MaxiQuantityReceivedFilter=" + encodeURIComponent("" + maxiQuantityReceivedFilter) + "&"; 
        if (miniQuantityReceivedFilter !== undefined)
            url_ += "MiniQuantityReceivedFilter=" + encodeURIComponent("" + miniQuantityReceivedFilter) + "&"; 
        if (maxiQuantityConvertedFilter !== undefined)
            url_ += "MaxiQuantityConvertedFilter=" + encodeURIComponent("" + maxiQuantityConvertedFilter) + "&"; 
        if (miniQuantityConvertedFilter !== undefined)
            url_ += "MiniQuantityConvertedFilter=" + encodeURIComponent("" + miniQuantityConvertedFilter) + "&"; 
        if (maxdDateReceivedFilter !== undefined)
            url_ += "MaxdDateReceivedFilter=" + encodeURIComponent(maxdDateReceivedFilter ? "" + maxdDateReceivedFilter.toJSON() : "") + "&"; 
        if (mindDateReceivedFilter !== undefined)
            url_ += "MindDateReceivedFilter=" + encodeURIComponent(mindDateReceivedFilter ? "" + mindDateReceivedFilter.toJSON() : "") + "&"; 
        if (maxiQuantityTotalFilter !== undefined)
            url_ += "MaxiQuantityTotalFilter=" + encodeURIComponent("" + maxiQuantityTotalFilter) + "&"; 
        if (miniQuantityTotalFilter !== undefined)
            url_ += "MiniQuantityTotalFilter=" + encodeURIComponent("" + miniQuantityTotalFilter) + "&"; 
        if (cBatch_LastFROMFilter !== undefined)
            url_ += "cBatch_LastFROMFilter=" + encodeURIComponent("" + cBatch_LastFROMFilter) + "&"; 
        if (cBatch_LastTOFilter !== undefined)
            url_ += "cBatch_LastTOFilter=" + encodeURIComponent("" + cBatch_LastTOFilter) + "&"; 
        if (cBatch_FROMFilter !== undefined)
            url_ += "cBatch_FROMFilter=" + encodeURIComponent("" + cBatch_FROMFilter) + "&"; 
        if (cBatch_TOFilter !== undefined)
            url_ += "cBatch_TOFilter=" + encodeURIComponent("" + cBatch_TOFilter) + "&"; 
        if (order_NoFilter !== undefined)
            url_ += "Order_NoFilter=" + encodeURIComponent("" + order_NoFilter) + "&"; 
        if (order_ClientPOFilter !== undefined)
            url_ += "Order_ClientPOFilter=" + encodeURIComponent("" + order_ClientPOFilter) + "&"; 
        if (orderSelectionFilter !== undefined)
            url_ += "OrderSelectionFilter=" + encodeURIComponent("" + orderSelectionFilter) + "&"; 
        if (order_FieldsFilter !== undefined)
            url_ += "Order_FieldsFilter=" + encodeURIComponent("" + order_FieldsFilter) + "&"; 
        if (order_CommentsFilter !== undefined)
            url_ += "Order_CommentsFilter=" + encodeURIComponent("" + order_CommentsFilter) + "&"; 
        if (order_Notes1Filter !== undefined)
            url_ += "Order_Notes1Filter=" + encodeURIComponent("" + order_Notes1Filter) + "&"; 
        if (order_Notes2Filter !== undefined)
            url_ += "Order_Notes2Filter=" + encodeURIComponent("" + order_Notes2Filter) + "&"; 
        if (lK_EmailTemplateFilter !== undefined)
            url_ += "LK_EmailTemplateFilter=" + encodeURIComponent("" + lK_EmailTemplateFilter) + "&"; 
        if (maxddateOrderSentFilter !== undefined)
            url_ += "MaxddateOrderSentFilter=" + encodeURIComponent(maxddateOrderSentFilter ? "" + maxddateOrderSentFilter.toJSON() : "") + "&"; 
        if (minddateOrderSentFilter !== undefined)
            url_ += "MinddateOrderSentFilter=" + encodeURIComponent(minddateOrderSentFilter ? "" + minddateOrderSentFilter.toJSON() : "") + "&"; 
        if (cNoteFilter !== undefined)
            url_ += "cNoteFilter=" + encodeURIComponent("" + cNoteFilter) + "&"; 
        if (maxiCASApprovalToFilter !== undefined)
            url_ += "MaxiCASApprovalToFilter=" + encodeURIComponent("" + maxiCASApprovalToFilter) + "&"; 
        if (miniCASApprovalToFilter !== undefined)
            url_ += "MiniCASApprovalToFilter=" + encodeURIComponent("" + miniCASApprovalToFilter) + "&"; 
        if (cSourceFilenameReadyToLoadFilter !== undefined)
            url_ += "cSourceFilenameReadyToLoadFilter=" + encodeURIComponent("" + cSourceFilenameReadyToLoadFilter) + "&"; 
        if (cSystemFilenameReadyToLoadFilter !== undefined)
            url_ += "cSystemFilenameReadyToLoadFilter=" + encodeURIComponent("" + cSystemFilenameReadyToLoadFilter) + "&"; 
        if (lK_LoadFileTypeFilter !== undefined)
            url_ += "LK_LoadFileTypeFilter=" + encodeURIComponent("" + lK_LoadFileTypeFilter) + "&"; 
        if (lK_LoadFileRowTerminatorFilter !== undefined)
            url_ += "LK_LoadFileRowTerminatorFilter=" + encodeURIComponent("" + lK_LoadFileRowTerminatorFilter) + "&"; 
        if (cOnePassFileNameFilter !== undefined)
            url_ += "cOnePassFileNameFilter=" + encodeURIComponent("" + cOnePassFileNameFilter) + "&"; 
        if (maxdCreatedDateFilter !== undefined)
            url_ += "MaxdCreatedDateFilter=" + encodeURIComponent(maxdCreatedDateFilter ? "" + maxdCreatedDateFilter.toJSON() : "") + "&"; 
        if (mindCreatedDateFilter !== undefined)
            url_ += "MindCreatedDateFilter=" + encodeURIComponent(mindCreatedDateFilter ? "" + mindCreatedDateFilter.toJSON() : "") + "&"; 
        if (cCreatedByFilter !== undefined)
            url_ += "cCreatedByFilter=" + encodeURIComponent("" + cCreatedByFilter) + "&"; 
        if (maxdModifiedDateFilter !== undefined)
            url_ += "MaxdModifiedDateFilter=" + encodeURIComponent(maxdModifiedDateFilter ? "" + maxdModifiedDateFilter.toJSON() : "") + "&"; 
        if (mindModifiedDateFilter !== undefined)
            url_ += "MindModifiedDateFilter=" + encodeURIComponent(mindModifiedDateFilter ? "" + mindModifiedDateFilter.toJSON() : "") + "&"; 
        if (cModifiedByFilter !== undefined)
            url_ += "cModifiedByFilter=" + encodeURIComponent("" + cModifiedByFilter) + "&"; 
        if (cSQLFilter !== undefined)
            url_ += "cSQLFilter=" + encodeURIComponent("" + cSQLFilter) + "&"; 
        if (cSQLDescriptionFilter !== undefined)
            url_ += "cSQLDescriptionFilter=" + encodeURIComponent("" + cSQLDescriptionFilter) + "&"; 
        if (maxiLoadQtyFilter !== undefined)
            url_ += "MaxiLoadQtyFilter=" + encodeURIComponent("" + maxiLoadQtyFilter) + "&"; 
        if (miniLoadQtyFilter !== undefined)
            url_ += "MiniLoadQtyFilter=" + encodeURIComponent("" + miniLoadQtyFilter) + "&"; 
        if (lK_EncodingFilter !== undefined)
            url_ += "LK_EncodingFilter=" + encodeURIComponent("" + lK_EncodingFilter) + "&"; 
        if (iIsMultilineFilter !== undefined)
            url_ += "iIsMultilineFilter=" + encodeURIComponent("" + iIsMultilineFilter) + "&"; 
        if (buildLK_BuildStatusFilter !== undefined)
            url_ += "BuildLK_BuildStatusFilter=" + encodeURIComponent("" + buildLK_BuildStatusFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBuildLolForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBuildLolForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBuildLolForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBuildLolForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBuildLolForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBuildLolForView(id: number | null | undefined): Observable<GetBuildLolForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BuildLols/GetBuildLolForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildLolForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildLolForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBuildLolForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBuildLolForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildLolForView(response: HttpResponseBase): Observable<GetBuildLolForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBuildLolForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBuildLolForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBuildLolForEdit(id: number | null | undefined): Observable<GetBuildLolForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BuildLols/GetBuildLolForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildLolForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildLolForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBuildLolForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBuildLolForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildLolForEdit(response: HttpResponseBase): Observable<GetBuildLolForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBuildLolForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBuildLolForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditBuildLolDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BuildLols/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BuildLols/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxMasterLolIDFilter (optional) 
     * @param minMasterLolIDFilter (optional) 
     * @param lK_ActionFilter (optional) 
     * @param lK_ActionMonth1Filter (optional) 
     * @param lK_ActionMonth2Filter (optional) 
     * @param lK_ActionNextMonthFilter (optional) 
     * @param lK_QuantityTypeFilter (optional) 
     * @param lK_FileTypeFilter (optional) 
     * @param iSkipFirstRowFilter (optional) 
     * @param iIsActiveFilter (optional) 
     * @param maxiUsageFilter (optional) 
     * @param miniUsageFilter (optional) 
     * @param maxnTurnsFilter (optional) 
     * @param minnTurnsFilter (optional) 
     * @param cDecisionReasoningFilter (optional) 
     * @param cSlugDateFilter (optional) 
     * @param cBatchDateTypeFilter (optional) 
     * @param lK_SlugDateTypeFilter (optional) 
     * @param maxiQuantityPreviousFilter (optional) 
     * @param miniQuantityPreviousFilter (optional) 
     * @param maxiQuantityRequestedFilter (optional) 
     * @param miniQuantityRequestedFilter (optional) 
     * @param maxiQuantityReceivedDPFilter (optional) 
     * @param miniQuantityReceivedDPFilter (optional) 
     * @param maxiQuantityReceivedFilter (optional) 
     * @param miniQuantityReceivedFilter (optional) 
     * @param maxiQuantityConvertedFilter (optional) 
     * @param miniQuantityConvertedFilter (optional) 
     * @param maxdDateReceivedFilter (optional) 
     * @param mindDateReceivedFilter (optional) 
     * @param maxiQuantityTotalFilter (optional) 
     * @param miniQuantityTotalFilter (optional) 
     * @param cBatch_LastFROMFilter (optional) 
     * @param cBatch_LastTOFilter (optional) 
     * @param cBatch_FROMFilter (optional) 
     * @param cBatch_TOFilter (optional) 
     * @param order_NoFilter (optional) 
     * @param order_ClientPOFilter (optional) 
     * @param orderSelectionFilter (optional) 
     * @param order_FieldsFilter (optional) 
     * @param order_CommentsFilter (optional) 
     * @param order_Notes1Filter (optional) 
     * @param order_Notes2Filter (optional) 
     * @param lK_EmailTemplateFilter (optional) 
     * @param maxddateOrderSentFilter (optional) 
     * @param minddateOrderSentFilter (optional) 
     * @param cNoteFilter (optional) 
     * @param maxiCASApprovalToFilter (optional) 
     * @param miniCASApprovalToFilter (optional) 
     * @param cSourceFilenameReadyToLoadFilter (optional) 
     * @param cSystemFilenameReadyToLoadFilter (optional) 
     * @param lK_LoadFileTypeFilter (optional) 
     * @param lK_LoadFileRowTerminatorFilter (optional) 
     * @param cOnePassFileNameFilter (optional) 
     * @param maxdCreatedDateFilter (optional) 
     * @param mindCreatedDateFilter (optional) 
     * @param cCreatedByFilter (optional) 
     * @param maxdModifiedDateFilter (optional) 
     * @param mindModifiedDateFilter (optional) 
     * @param cModifiedByFilter (optional) 
     * @param cSQLFilter (optional) 
     * @param cSQLDescriptionFilter (optional) 
     * @param maxiLoadQtyFilter (optional) 
     * @param miniLoadQtyFilter (optional) 
     * @param lK_EncodingFilter (optional) 
     * @param iIsMultilineFilter (optional) 
     * @param buildLK_BuildStatusFilter (optional) 
     * @return Success
     */
    getBuildLolsToExcel(filter: string | null | undefined, maxMasterLolIDFilter: number | null | undefined, minMasterLolIDFilter: number | null | undefined, lK_ActionFilter: string | null | undefined, lK_ActionMonth1Filter: string | null | undefined, lK_ActionMonth2Filter: string | null | undefined, lK_ActionNextMonthFilter: string | null | undefined, lK_QuantityTypeFilter: string | null | undefined, lK_FileTypeFilter: string | null | undefined, iSkipFirstRowFilter: number | null | undefined, iIsActiveFilter: number | null | undefined, maxiUsageFilter: number | null | undefined, miniUsageFilter: number | null | undefined, maxnTurnsFilter: number | null | undefined, minnTurnsFilter: number | null | undefined, cDecisionReasoningFilter: string | null | undefined, cSlugDateFilter: string | null | undefined, cBatchDateTypeFilter: string | null | undefined, lK_SlugDateTypeFilter: string | null | undefined, maxiQuantityPreviousFilter: number | null | undefined, miniQuantityPreviousFilter: number | null | undefined, maxiQuantityRequestedFilter: number | null | undefined, miniQuantityRequestedFilter: number | null | undefined, maxiQuantityReceivedDPFilter: number | null | undefined, miniQuantityReceivedDPFilter: number | null | undefined, maxiQuantityReceivedFilter: number | null | undefined, miniQuantityReceivedFilter: number | null | undefined, maxiQuantityConvertedFilter: number | null | undefined, miniQuantityConvertedFilter: number | null | undefined, maxdDateReceivedFilter: moment.Moment | null | undefined, mindDateReceivedFilter: moment.Moment | null | undefined, maxiQuantityTotalFilter: number | null | undefined, miniQuantityTotalFilter: number | null | undefined, cBatch_LastFROMFilter: string | null | undefined, cBatch_LastTOFilter: string | null | undefined, cBatch_FROMFilter: string | null | undefined, cBatch_TOFilter: string | null | undefined, order_NoFilter: string | null | undefined, order_ClientPOFilter: string | null | undefined, orderSelectionFilter: string | null | undefined, order_FieldsFilter: string | null | undefined, order_CommentsFilter: string | null | undefined, order_Notes1Filter: string | null | undefined, order_Notes2Filter: string | null | undefined, lK_EmailTemplateFilter: string | null | undefined, maxddateOrderSentFilter: moment.Moment | null | undefined, minddateOrderSentFilter: moment.Moment | null | undefined, cNoteFilter: string | null | undefined, maxiCASApprovalToFilter: number | null | undefined, miniCASApprovalToFilter: number | null | undefined, cSourceFilenameReadyToLoadFilter: string | null | undefined, cSystemFilenameReadyToLoadFilter: string | null | undefined, lK_LoadFileTypeFilter: string | null | undefined, lK_LoadFileRowTerminatorFilter: string | null | undefined, cOnePassFileNameFilter: string | null | undefined, maxdCreatedDateFilter: moment.Moment | null | undefined, mindCreatedDateFilter: moment.Moment | null | undefined, cCreatedByFilter: string | null | undefined, maxdModifiedDateFilter: moment.Moment | null | undefined, mindModifiedDateFilter: moment.Moment | null | undefined, cModifiedByFilter: string | null | undefined, cSQLFilter: string | null | undefined, cSQLDescriptionFilter: string | null | undefined, maxiLoadQtyFilter: number | null | undefined, miniLoadQtyFilter: number | null | undefined, lK_EncodingFilter: string | null | undefined, iIsMultilineFilter: number | null | undefined, buildLK_BuildStatusFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BuildLols/GetBuildLolsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxMasterLolIDFilter !== undefined)
            url_ += "MaxMasterLolIDFilter=" + encodeURIComponent("" + maxMasterLolIDFilter) + "&"; 
        if (minMasterLolIDFilter !== undefined)
            url_ += "MinMasterLolIDFilter=" + encodeURIComponent("" + minMasterLolIDFilter) + "&"; 
        if (lK_ActionFilter !== undefined)
            url_ += "LK_ActionFilter=" + encodeURIComponent("" + lK_ActionFilter) + "&"; 
        if (lK_ActionMonth1Filter !== undefined)
            url_ += "LK_ActionMonth1Filter=" + encodeURIComponent("" + lK_ActionMonth1Filter) + "&"; 
        if (lK_ActionMonth2Filter !== undefined)
            url_ += "LK_ActionMonth2Filter=" + encodeURIComponent("" + lK_ActionMonth2Filter) + "&"; 
        if (lK_ActionNextMonthFilter !== undefined)
            url_ += "LK_ActionNextMonthFilter=" + encodeURIComponent("" + lK_ActionNextMonthFilter) + "&"; 
        if (lK_QuantityTypeFilter !== undefined)
            url_ += "LK_QuantityTypeFilter=" + encodeURIComponent("" + lK_QuantityTypeFilter) + "&"; 
        if (lK_FileTypeFilter !== undefined)
            url_ += "LK_FileTypeFilter=" + encodeURIComponent("" + lK_FileTypeFilter) + "&"; 
        if (iSkipFirstRowFilter !== undefined)
            url_ += "iSkipFirstRowFilter=" + encodeURIComponent("" + iSkipFirstRowFilter) + "&"; 
        if (iIsActiveFilter !== undefined)
            url_ += "iIsActiveFilter=" + encodeURIComponent("" + iIsActiveFilter) + "&"; 
        if (maxiUsageFilter !== undefined)
            url_ += "MaxiUsageFilter=" + encodeURIComponent("" + maxiUsageFilter) + "&"; 
        if (miniUsageFilter !== undefined)
            url_ += "MiniUsageFilter=" + encodeURIComponent("" + miniUsageFilter) + "&"; 
        if (maxnTurnsFilter !== undefined)
            url_ += "MaxnTurnsFilter=" + encodeURIComponent("" + maxnTurnsFilter) + "&"; 
        if (minnTurnsFilter !== undefined)
            url_ += "MinnTurnsFilter=" + encodeURIComponent("" + minnTurnsFilter) + "&"; 
        if (cDecisionReasoningFilter !== undefined)
            url_ += "cDecisionReasoningFilter=" + encodeURIComponent("" + cDecisionReasoningFilter) + "&"; 
        if (cSlugDateFilter !== undefined)
            url_ += "cSlugDateFilter=" + encodeURIComponent("" + cSlugDateFilter) + "&"; 
        if (cBatchDateTypeFilter !== undefined)
            url_ += "cBatchDateTypeFilter=" + encodeURIComponent("" + cBatchDateTypeFilter) + "&"; 
        if (lK_SlugDateTypeFilter !== undefined)
            url_ += "LK_SlugDateTypeFilter=" + encodeURIComponent("" + lK_SlugDateTypeFilter) + "&"; 
        if (maxiQuantityPreviousFilter !== undefined)
            url_ += "MaxiQuantityPreviousFilter=" + encodeURIComponent("" + maxiQuantityPreviousFilter) + "&"; 
        if (miniQuantityPreviousFilter !== undefined)
            url_ += "MiniQuantityPreviousFilter=" + encodeURIComponent("" + miniQuantityPreviousFilter) + "&"; 
        if (maxiQuantityRequestedFilter !== undefined)
            url_ += "MaxiQuantityRequestedFilter=" + encodeURIComponent("" + maxiQuantityRequestedFilter) + "&"; 
        if (miniQuantityRequestedFilter !== undefined)
            url_ += "MiniQuantityRequestedFilter=" + encodeURIComponent("" + miniQuantityRequestedFilter) + "&"; 
        if (maxiQuantityReceivedDPFilter !== undefined)
            url_ += "MaxiQuantityReceivedDPFilter=" + encodeURIComponent("" + maxiQuantityReceivedDPFilter) + "&"; 
        if (miniQuantityReceivedDPFilter !== undefined)
            url_ += "MiniQuantityReceivedDPFilter=" + encodeURIComponent("" + miniQuantityReceivedDPFilter) + "&"; 
        if (maxiQuantityReceivedFilter !== undefined)
            url_ += "MaxiQuantityReceivedFilter=" + encodeURIComponent("" + maxiQuantityReceivedFilter) + "&"; 
        if (miniQuantityReceivedFilter !== undefined)
            url_ += "MiniQuantityReceivedFilter=" + encodeURIComponent("" + miniQuantityReceivedFilter) + "&"; 
        if (maxiQuantityConvertedFilter !== undefined)
            url_ += "MaxiQuantityConvertedFilter=" + encodeURIComponent("" + maxiQuantityConvertedFilter) + "&"; 
        if (miniQuantityConvertedFilter !== undefined)
            url_ += "MiniQuantityConvertedFilter=" + encodeURIComponent("" + miniQuantityConvertedFilter) + "&"; 
        if (maxdDateReceivedFilter !== undefined)
            url_ += "MaxdDateReceivedFilter=" + encodeURIComponent(maxdDateReceivedFilter ? "" + maxdDateReceivedFilter.toJSON() : "") + "&"; 
        if (mindDateReceivedFilter !== undefined)
            url_ += "MindDateReceivedFilter=" + encodeURIComponent(mindDateReceivedFilter ? "" + mindDateReceivedFilter.toJSON() : "") + "&"; 
        if (maxiQuantityTotalFilter !== undefined)
            url_ += "MaxiQuantityTotalFilter=" + encodeURIComponent("" + maxiQuantityTotalFilter) + "&"; 
        if (miniQuantityTotalFilter !== undefined)
            url_ += "MiniQuantityTotalFilter=" + encodeURIComponent("" + miniQuantityTotalFilter) + "&"; 
        if (cBatch_LastFROMFilter !== undefined)
            url_ += "cBatch_LastFROMFilter=" + encodeURIComponent("" + cBatch_LastFROMFilter) + "&"; 
        if (cBatch_LastTOFilter !== undefined)
            url_ += "cBatch_LastTOFilter=" + encodeURIComponent("" + cBatch_LastTOFilter) + "&"; 
        if (cBatch_FROMFilter !== undefined)
            url_ += "cBatch_FROMFilter=" + encodeURIComponent("" + cBatch_FROMFilter) + "&"; 
        if (cBatch_TOFilter !== undefined)
            url_ += "cBatch_TOFilter=" + encodeURIComponent("" + cBatch_TOFilter) + "&"; 
        if (order_NoFilter !== undefined)
            url_ += "Order_NoFilter=" + encodeURIComponent("" + order_NoFilter) + "&"; 
        if (order_ClientPOFilter !== undefined)
            url_ += "Order_ClientPOFilter=" + encodeURIComponent("" + order_ClientPOFilter) + "&"; 
        if (orderSelectionFilter !== undefined)
            url_ += "OrderSelectionFilter=" + encodeURIComponent("" + orderSelectionFilter) + "&"; 
        if (order_FieldsFilter !== undefined)
            url_ += "Order_FieldsFilter=" + encodeURIComponent("" + order_FieldsFilter) + "&"; 
        if (order_CommentsFilter !== undefined)
            url_ += "Order_CommentsFilter=" + encodeURIComponent("" + order_CommentsFilter) + "&"; 
        if (order_Notes1Filter !== undefined)
            url_ += "Order_Notes1Filter=" + encodeURIComponent("" + order_Notes1Filter) + "&"; 
        if (order_Notes2Filter !== undefined)
            url_ += "Order_Notes2Filter=" + encodeURIComponent("" + order_Notes2Filter) + "&"; 
        if (lK_EmailTemplateFilter !== undefined)
            url_ += "LK_EmailTemplateFilter=" + encodeURIComponent("" + lK_EmailTemplateFilter) + "&"; 
        if (maxddateOrderSentFilter !== undefined)
            url_ += "MaxddateOrderSentFilter=" + encodeURIComponent(maxddateOrderSentFilter ? "" + maxddateOrderSentFilter.toJSON() : "") + "&"; 
        if (minddateOrderSentFilter !== undefined)
            url_ += "MinddateOrderSentFilter=" + encodeURIComponent(minddateOrderSentFilter ? "" + minddateOrderSentFilter.toJSON() : "") + "&"; 
        if (cNoteFilter !== undefined)
            url_ += "cNoteFilter=" + encodeURIComponent("" + cNoteFilter) + "&"; 
        if (maxiCASApprovalToFilter !== undefined)
            url_ += "MaxiCASApprovalToFilter=" + encodeURIComponent("" + maxiCASApprovalToFilter) + "&"; 
        if (miniCASApprovalToFilter !== undefined)
            url_ += "MiniCASApprovalToFilter=" + encodeURIComponent("" + miniCASApprovalToFilter) + "&"; 
        if (cSourceFilenameReadyToLoadFilter !== undefined)
            url_ += "cSourceFilenameReadyToLoadFilter=" + encodeURIComponent("" + cSourceFilenameReadyToLoadFilter) + "&"; 
        if (cSystemFilenameReadyToLoadFilter !== undefined)
            url_ += "cSystemFilenameReadyToLoadFilter=" + encodeURIComponent("" + cSystemFilenameReadyToLoadFilter) + "&"; 
        if (lK_LoadFileTypeFilter !== undefined)
            url_ += "LK_LoadFileTypeFilter=" + encodeURIComponent("" + lK_LoadFileTypeFilter) + "&"; 
        if (lK_LoadFileRowTerminatorFilter !== undefined)
            url_ += "LK_LoadFileRowTerminatorFilter=" + encodeURIComponent("" + lK_LoadFileRowTerminatorFilter) + "&"; 
        if (cOnePassFileNameFilter !== undefined)
            url_ += "cOnePassFileNameFilter=" + encodeURIComponent("" + cOnePassFileNameFilter) + "&"; 
        if (maxdCreatedDateFilter !== undefined)
            url_ += "MaxdCreatedDateFilter=" + encodeURIComponent(maxdCreatedDateFilter ? "" + maxdCreatedDateFilter.toJSON() : "") + "&"; 
        if (mindCreatedDateFilter !== undefined)
            url_ += "MindCreatedDateFilter=" + encodeURIComponent(mindCreatedDateFilter ? "" + mindCreatedDateFilter.toJSON() : "") + "&"; 
        if (cCreatedByFilter !== undefined)
            url_ += "cCreatedByFilter=" + encodeURIComponent("" + cCreatedByFilter) + "&"; 
        if (maxdModifiedDateFilter !== undefined)
            url_ += "MaxdModifiedDateFilter=" + encodeURIComponent(maxdModifiedDateFilter ? "" + maxdModifiedDateFilter.toJSON() : "") + "&"; 
        if (mindModifiedDateFilter !== undefined)
            url_ += "MindModifiedDateFilter=" + encodeURIComponent(mindModifiedDateFilter ? "" + mindModifiedDateFilter.toJSON() : "") + "&"; 
        if (cModifiedByFilter !== undefined)
            url_ += "cModifiedByFilter=" + encodeURIComponent("" + cModifiedByFilter) + "&"; 
        if (cSQLFilter !== undefined)
            url_ += "cSQLFilter=" + encodeURIComponent("" + cSQLFilter) + "&"; 
        if (cSQLDescriptionFilter !== undefined)
            url_ += "cSQLDescriptionFilter=" + encodeURIComponent("" + cSQLDescriptionFilter) + "&"; 
        if (maxiLoadQtyFilter !== undefined)
            url_ += "MaxiLoadQtyFilter=" + encodeURIComponent("" + maxiLoadQtyFilter) + "&"; 
        if (miniLoadQtyFilter !== undefined)
            url_ += "MiniLoadQtyFilter=" + encodeURIComponent("" + miniLoadQtyFilter) + "&"; 
        if (lK_EncodingFilter !== undefined)
            url_ += "LK_EncodingFilter=" + encodeURIComponent("" + lK_EncodingFilter) + "&"; 
        if (iIsMultilineFilter !== undefined)
            url_ += "iIsMultilineFilter=" + encodeURIComponent("" + iIsMultilineFilter) + "&"; 
        if (buildLK_BuildStatusFilter !== undefined)
            url_ += "BuildLK_BuildStatusFilter=" + encodeURIComponent("" + buildLK_BuildStatusFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildLolsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildLolsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildLolsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBuildForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBuildLolBuildLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BuildLols/GetAllBuildForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBuildForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBuildForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBuildLolBuildLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBuildLolBuildLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBuildForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBuildLolBuildLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBuildLolBuildLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBuildLolBuildLookupTableDto>(<any>null);
    }
}

@Injectable()
export class BuildsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param lK_BuildStatusFilter (optional) 
     * @param maxiPreviousBuildIDFilter (optional) 
     * @param miniPreviousBuildIDFilter (optional) 
     * @param cBuildFilter (optional) 
     * @param cDescriptionFilter (optional) 
     * @param maxdMailDateFilter (optional) 
     * @param mindMailDateFilter (optional) 
     * @param maxiRecordCountFilter (optional) 
     * @param miniRecordCountFilter (optional) 
     * @param iIsReadyToUseFilter (optional) 
     * @param iIsOnDiskFilter (optional) 
     * @param cMailDateFROMFilter (optional) 
     * @param cMailDateTOFilter (optional) 
     * @param maxdCreatedDateFilter (optional) 
     * @param mindCreatedDateFilter (optional) 
     * @param cCreatedByFilter (optional) 
     * @param maxdModifiedDateFilter (optional) 
     * @param mindModifiedDateFilter (optional) 
     * @param cModifiedByFilter (optional) 
     * @param maxLK_BuildPriorityFilter (optional) 
     * @param minLK_BuildPriorityFilter (optional) 
     * @param maxdScheduledDateTimeFilter (optional) 
     * @param mindScheduledDateTimeFilter (optional) 
     * @param iStopRequestedFilter (optional) 
     * @param iIsOneStepFilter (optional) 
     * @param databasecDatabaseNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, lK_BuildStatusFilter: string | null | undefined, maxiPreviousBuildIDFilter: number | null | undefined, miniPreviousBuildIDFilter: number | null | undefined, cBuildFilter: string | null | undefined, cDescriptionFilter: string | null | undefined, maxdMailDateFilter: moment.Moment | null | undefined, mindMailDateFilter: moment.Moment | null | undefined, maxiRecordCountFilter: number | null | undefined, miniRecordCountFilter: number | null | undefined, iIsReadyToUseFilter: number | null | undefined, iIsOnDiskFilter: number | null | undefined, cMailDateFROMFilter: string | null | undefined, cMailDateTOFilter: string | null | undefined, maxdCreatedDateFilter: moment.Moment | null | undefined, mindCreatedDateFilter: moment.Moment | null | undefined, cCreatedByFilter: string | null | undefined, maxdModifiedDateFilter: moment.Moment | null | undefined, mindModifiedDateFilter: moment.Moment | null | undefined, cModifiedByFilter: string | null | undefined, maxLK_BuildPriorityFilter: number | null | undefined, minLK_BuildPriorityFilter: number | null | undefined, maxdScheduledDateTimeFilter: moment.Moment | null | undefined, mindScheduledDateTimeFilter: moment.Moment | null | undefined, iStopRequestedFilter: number | null | undefined, iIsOneStepFilter: number | null | undefined, databasecDatabaseNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBuildForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Builds/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (lK_BuildStatusFilter !== undefined)
            url_ += "LK_BuildStatusFilter=" + encodeURIComponent("" + lK_BuildStatusFilter) + "&"; 
        if (maxiPreviousBuildIDFilter !== undefined)
            url_ += "MaxiPreviousBuildIDFilter=" + encodeURIComponent("" + maxiPreviousBuildIDFilter) + "&"; 
        if (miniPreviousBuildIDFilter !== undefined)
            url_ += "MiniPreviousBuildIDFilter=" + encodeURIComponent("" + miniPreviousBuildIDFilter) + "&"; 
        if (cBuildFilter !== undefined)
            url_ += "cBuildFilter=" + encodeURIComponent("" + cBuildFilter) + "&"; 
        if (cDescriptionFilter !== undefined)
            url_ += "cDescriptionFilter=" + encodeURIComponent("" + cDescriptionFilter) + "&"; 
        if (maxdMailDateFilter !== undefined)
            url_ += "MaxdMailDateFilter=" + encodeURIComponent(maxdMailDateFilter ? "" + maxdMailDateFilter.toJSON() : "") + "&"; 
        if (mindMailDateFilter !== undefined)
            url_ += "MindMailDateFilter=" + encodeURIComponent(mindMailDateFilter ? "" + mindMailDateFilter.toJSON() : "") + "&"; 
        if (maxiRecordCountFilter !== undefined)
            url_ += "MaxiRecordCountFilter=" + encodeURIComponent("" + maxiRecordCountFilter) + "&"; 
        if (miniRecordCountFilter !== undefined)
            url_ += "MiniRecordCountFilter=" + encodeURIComponent("" + miniRecordCountFilter) + "&"; 
        if (iIsReadyToUseFilter !== undefined)
            url_ += "iIsReadyToUseFilter=" + encodeURIComponent("" + iIsReadyToUseFilter) + "&"; 
        if (iIsOnDiskFilter !== undefined)
            url_ += "iIsOnDiskFilter=" + encodeURIComponent("" + iIsOnDiskFilter) + "&"; 
        if (cMailDateFROMFilter !== undefined)
            url_ += "cMailDateFROMFilter=" + encodeURIComponent("" + cMailDateFROMFilter) + "&"; 
        if (cMailDateTOFilter !== undefined)
            url_ += "cMailDateTOFilter=" + encodeURIComponent("" + cMailDateTOFilter) + "&"; 
        if (maxdCreatedDateFilter !== undefined)
            url_ += "MaxdCreatedDateFilter=" + encodeURIComponent(maxdCreatedDateFilter ? "" + maxdCreatedDateFilter.toJSON() : "") + "&"; 
        if (mindCreatedDateFilter !== undefined)
            url_ += "MindCreatedDateFilter=" + encodeURIComponent(mindCreatedDateFilter ? "" + mindCreatedDateFilter.toJSON() : "") + "&"; 
        if (cCreatedByFilter !== undefined)
            url_ += "cCreatedByFilter=" + encodeURIComponent("" + cCreatedByFilter) + "&"; 
        if (maxdModifiedDateFilter !== undefined)
            url_ += "MaxdModifiedDateFilter=" + encodeURIComponent(maxdModifiedDateFilter ? "" + maxdModifiedDateFilter.toJSON() : "") + "&"; 
        if (mindModifiedDateFilter !== undefined)
            url_ += "MindModifiedDateFilter=" + encodeURIComponent(mindModifiedDateFilter ? "" + mindModifiedDateFilter.toJSON() : "") + "&"; 
        if (cModifiedByFilter !== undefined)
            url_ += "cModifiedByFilter=" + encodeURIComponent("" + cModifiedByFilter) + "&"; 
        if (maxLK_BuildPriorityFilter !== undefined)
            url_ += "MaxLK_BuildPriorityFilter=" + encodeURIComponent("" + maxLK_BuildPriorityFilter) + "&"; 
        if (minLK_BuildPriorityFilter !== undefined)
            url_ += "MinLK_BuildPriorityFilter=" + encodeURIComponent("" + minLK_BuildPriorityFilter) + "&"; 
        if (maxdScheduledDateTimeFilter !== undefined)
            url_ += "MaxdScheduledDateTimeFilter=" + encodeURIComponent(maxdScheduledDateTimeFilter ? "" + maxdScheduledDateTimeFilter.toJSON() : "") + "&"; 
        if (mindScheduledDateTimeFilter !== undefined)
            url_ += "MindScheduledDateTimeFilter=" + encodeURIComponent(mindScheduledDateTimeFilter ? "" + mindScheduledDateTimeFilter.toJSON() : "") + "&"; 
        if (iStopRequestedFilter !== undefined)
            url_ += "iStopRequestedFilter=" + encodeURIComponent("" + iStopRequestedFilter) + "&"; 
        if (iIsOneStepFilter !== undefined)
            url_ += "iIsOneStepFilter=" + encodeURIComponent("" + iIsOneStepFilter) + "&"; 
        if (databasecDatabaseNameFilter !== undefined)
            url_ += "DatabasecDatabaseNameFilter=" + encodeURIComponent("" + databasecDatabaseNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBuildForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBuildForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBuildForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBuildForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBuildForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBuildForView(id: number | null | undefined): Observable<GetBuildForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Builds/GetBuildForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBuildForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBuildForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildForView(response: HttpResponseBase): Observable<GetBuildForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBuildForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBuildForViewDto>(<any>null);
    }

    /**
     * @param databaseID (optional) 
     * @return Success
     */
    getLatestBuildFromDatabaseID(databaseID: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Builds/GetLatestBuildFromDatabaseID?";
        if (databaseID !== undefined)
            url_ += "databaseID=" + encodeURIComponent("" + databaseID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestBuildFromDatabaseID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestBuildFromDatabaseID(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestBuildFromDatabaseID(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBuildForEdit(id: number | null | undefined): Observable<GetBuildForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Builds/GetBuildForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBuildForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBuildForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildForEdit(response: HttpResponseBase): Observable<GetBuildForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBuildForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBuildForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditBuildDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Builds/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Builds/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDatabaseForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBuildDatabaseLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Builds/GetAllDatabaseForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDatabaseForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDatabaseForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBuildDatabaseLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBuildDatabaseLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDatabaseForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBuildDatabaseLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBuildDatabaseLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBuildDatabaseLookupTableDto>(<any>null);
    }

    /**
     * @param iDatabaseID (optional) 
     * @param taskID (optional) 
     * @return Success
     */
    getBuildsForDatabase(iDatabaseID: number | null | undefined, taskID: number | null | undefined): Observable<GetAllBuildsForDatabaseDto> {
        let url_ = this.baseUrl + "/api/services/app/Builds/GetBuildsForDatabase?";
        if (iDatabaseID !== undefined)
            url_ += "iDatabaseID=" + encodeURIComponent("" + iDatabaseID) + "&"; 
        if (taskID !== undefined)
            url_ += "taskID=" + encodeURIComponent("" + taskID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildsForDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildsForDatabase(<any>response_);
                } catch (e) {
                    return <Observable<GetAllBuildsForDatabaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllBuildsForDatabaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildsForDatabase(response: HttpResponseBase): Observable<GetAllBuildsForDatabaseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllBuildsForDatabaseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllBuildsForDatabaseDto>(<any>null);
    }

    /**
     * @param buildId (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    getChildAndExternalTablesByBuild(buildId: number | null | undefined, databaseId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Builds/GetChildAndExternalTablesByBuild?";
        if (buildId !== undefined)
            url_ += "buildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChildAndExternalTablesByBuild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChildAndExternalTablesByBuild(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetChildAndExternalTablesByBuild(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }
}

@Injectable()
export class BuildTableLayoutsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param buildId (optional) 
     * @param databaseId (optional) 
     * @param mailerId (optional) 
     * @return Success
     */
    getAllMultiFields(filter: string | null | undefined, buildId: number | null | undefined, databaseId: number | null | undefined, mailerId: number | null | undefined): Observable<GetBuildTableLayoutForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BuildTableLayouts/GetAllMultiFields?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (buildId !== undefined)
            url_ += "BuildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (databaseId !== undefined)
            url_ += "DatabaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (mailerId !== undefined)
            url_ += "MailerId=" + encodeURIComponent("" + mailerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMultiFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMultiFields(<any>response_);
                } catch (e) {
                    return <Observable<GetBuildTableLayoutForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBuildTableLayoutForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMultiFields(response: HttpResponseBase): Observable<GetBuildTableLayoutForViewDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetBuildTableLayoutForViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBuildTableLayoutForViewDto[]>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @param buildId (optional) 
     * @return Success
     */
    getFieldDetails(databaseId: number | null | undefined, buildId: number | null | undefined, screen: AdvanceSelectionScreen): Observable<AdvanceSelectionFields> {
        let url_ = this.baseUrl + "/api/services/app/BuildTableLayouts/GetFieldDetails?";
        if (databaseId !== undefined)
            url_ += "DatabaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (buildId !== undefined)
            url_ += "BuildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (screen === undefined || screen === null)
            throw new Error("The parameter 'screen' must be defined and cannot be null.");
        else
            url_ += "Screen=" + encodeURIComponent("" + screen) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFieldDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFieldDetails(<any>response_);
                } catch (e) {
                    return <Observable<AdvanceSelectionFields>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvanceSelectionFields>><any>_observableThrow(response_);
        }));
    }

    protected processGetFieldDetails(response: HttpResponseBase): Observable<AdvanceSelectionFields> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdvanceSelectionFields.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvanceSelectionFields>(<any>null);
    }
}

@Injectable()
export class BuildTablesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param cTableNameFilter (optional) 
     * @param buildcBuildFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, cTableNameFilter: string | null | undefined, buildcBuildFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBuildTableForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BuildTables/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (cTableNameFilter !== undefined)
            url_ += "cTableNameFilter=" + encodeURIComponent("" + cTableNameFilter) + "&"; 
        if (buildcBuildFilter !== undefined)
            url_ += "BuildcBuildFilter=" + encodeURIComponent("" + buildcBuildFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBuildTableForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBuildTableForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBuildTableForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBuildTableForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBuildTableForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBuildTableForView(id: number | null | undefined): Observable<GetBuildTableForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BuildTables/GetBuildTableForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildTableForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildTableForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBuildTableForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBuildTableForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildTableForView(response: HttpResponseBase): Observable<GetBuildTableForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBuildTableForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBuildTableForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBuildTableForEdit(id: number | null | undefined): Observable<GetBuildTableForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BuildTables/GetBuildTableForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildTableForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildTableForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBuildTableForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBuildTableForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildTableForEdit(response: HttpResponseBase): Observable<GetBuildTableForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBuildTableForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBuildTableForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditBuildTableDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BuildTables/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BuildTables/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBuildForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBuildTableBuildLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BuildTables/GetAllBuildForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBuildForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBuildForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBuildTableBuildLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBuildTableBuildLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBuildForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBuildTableBuildLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBuildTableBuildLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBuildTableBuildLookupTableDto>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfCacheDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    clearCache(input: EntityDtoOfString | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CampaignAttachmentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param campaigncDescriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, campaigncDescriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCampaignAttachmentForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CampaignAttachments/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (campaigncDescriptionFilter !== undefined)
            url_ += "CampaigncDescriptionFilter=" + encodeURIComponent("" + campaigncDescriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCampaignAttachmentForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCampaignAttachmentForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCampaignAttachmentForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCampaignAttachmentForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCampaignAttachmentForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCampaignAttachmentForEdit(id: number | null | undefined): Observable<GetCampaignAttachmentForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CampaignAttachments/GetCampaignAttachmentForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCampaignAttachmentForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCampaignAttachmentForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCampaignAttachmentForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCampaignAttachmentForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCampaignAttachmentForEdit(response: HttpResponseBase): Observable<GetCampaignAttachmentForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCampaignAttachmentForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCampaignAttachmentForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCampaignAttachmentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CampaignAttachments/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CampaignAttachments/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCampaignForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCampaignAttachmentCampaignLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CampaignAttachments/GetAllCampaignForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCampaignForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCampaignForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCampaignAttachmentCampaignLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCampaignAttachmentCampaignLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCampaignForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCampaignAttachmentCampaignLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCampaignAttachmentCampaignLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCampaignAttachmentCampaignLookupTableDto>(<any>null);
    }
}

@Injectable()
export class CampaignCASApprovalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param campaigncDatabaseNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, campaigncDatabaseNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCampaignCASApprovalForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CampaignCASApprovals/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (campaigncDatabaseNameFilter !== undefined)
            url_ += "CampaigncDatabaseNameFilter=" + encodeURIComponent("" + campaigncDatabaseNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCampaignCASApprovalForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCampaignCASApprovalForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCampaignCASApprovalForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCampaignCASApprovalForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCampaignCASApprovalForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCampaignCASApprovalForEdit(id: number | null | undefined): Observable<GetCampaignCASApprovalForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CampaignCASApprovals/GetCampaignCASApprovalForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCampaignCASApprovalForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCampaignCASApprovalForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCampaignCASApprovalForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCampaignCASApprovalForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCampaignCASApprovalForEdit(response: HttpResponseBase): Observable<GetCampaignCASApprovalForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCampaignCASApprovalForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCampaignCASApprovalForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCampaignCASApprovalDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CampaignCASApprovals/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CampaignCASApprovals/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCampaignForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCampaignCASApprovalCampaignLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CampaignCASApprovals/GetAllCampaignForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCampaignForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCampaignForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCampaignCASApprovalCampaignLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCampaignCASApprovalCampaignLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCampaignForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCampaignCASApprovalCampaignLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCampaignCASApprovalCampaignLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCampaignCASApprovalCampaignLookupTableDto>(<any>null);
    }
}

@Injectable()
export class CampaignFavouritesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllFavouriteCampaigns(): Observable<CampaignFavouriteDtoForView[]> {
        let url_ = this.baseUrl + "/api/services/app/CampaignFavourites/GetAllFavouriteCampaigns";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFavouriteCampaigns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFavouriteCampaigns(<any>response_);
                } catch (e) {
                    return <Observable<CampaignFavouriteDtoForView[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CampaignFavouriteDtoForView[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFavouriteCampaigns(response: HttpResponseBase): Observable<CampaignFavouriteDtoForView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CampaignFavouriteDtoForView.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CampaignFavouriteDtoForView[]>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param isFavourite (optional) 
     * @return Success
     */
    addOrRemoveFavouriteCampaigns(campaignId: number | null | undefined, isFavourite: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CampaignFavourites/AddOrRemoveFavouriteCampaigns?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (isFavourite !== undefined)
            url_ += "isFavourite=" + encodeURIComponent("" + isFavourite) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrRemoveFavouriteCampaigns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrRemoveFavouriteCampaigns(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrRemoveFavouriteCampaigns(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CampaignFTPsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCampaignFTPForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CampaignFTPs/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCampaignFTPForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCampaignFTPForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCampaignFTPForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCampaignFTPForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCampaignFTPForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCampaignFTPForEdit(id: number | null | undefined): Observable<GetCampaignFTPForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CampaignFTPs/GetCampaignFTPForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCampaignFTPForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCampaignFTPForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCampaignFTPForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCampaignFTPForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCampaignFTPForEdit(response: HttpResponseBase): Observable<GetCampaignFTPForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCampaignFTPForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCampaignFTPForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCampaignFTPDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CampaignFTPs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CampaignFTPs/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CampaignMultiColumnReportsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param campaigncDescriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, campaigncDescriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCampaignMultiColumnReportForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CampaignMultiColumnReports/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (campaigncDescriptionFilter !== undefined)
            url_ += "CampaigncDescriptionFilter=" + encodeURIComponent("" + campaigncDescriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCampaignMultiColumnReportForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCampaignMultiColumnReportForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCampaignMultiColumnReportForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCampaignMultiColumnReportForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCampaignMultiColumnReportForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCampaignMultiColumnReportForEdit(id: number | null | undefined): Observable<GetCampaignMultiColumnReportForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CampaignMultiColumnReports/GetCampaignMultiColumnReportForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCampaignMultiColumnReportForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCampaignMultiColumnReportForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCampaignMultiColumnReportForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCampaignMultiColumnReportForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCampaignMultiColumnReportForEdit(response: HttpResponseBase): Observable<GetCampaignMultiColumnReportForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCampaignMultiColumnReportForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCampaignMultiColumnReportForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCampaignMultiColumnReportDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CampaignMultiColumnReports/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CampaignMultiColumnReports/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCampaignForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCampaignMultiColumnReportCampaignLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CampaignMultiColumnReports/GetAllCampaignForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCampaignForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCampaignForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCampaignMultiColumnReportCampaignLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCampaignMultiColumnReportCampaignLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCampaignForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCampaignMultiColumnReportCampaignLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCampaignMultiColumnReportCampaignLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCampaignMultiColumnReportCampaignLookupTableDto>(<any>null);
    }
}

@Injectable()
export class CampaignsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param orderId (optional) 
     * @param status (optional) 
     * @param databaseId (optional) 
     * @param userId (optional) 
     * @param selectedDateRange (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllFastCountCampaignsList(orderId: string | null | undefined, status: string[] | null | undefined, databaseId: string[] | null | undefined, userId: string[] | null | undefined, selectedDateRange: moment.Moment[] | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCampaignsListForView> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetAllFastCountCampaignsList?";
        if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (status !== undefined)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (databaseId !== undefined)
            databaseId && databaseId.forEach(item => { url_ += "DatabaseId=" + encodeURIComponent("" + item) + "&"; });
        if (userId !== undefined)
            userId && userId.forEach(item => { url_ += "UserId=" + encodeURIComponent("" + item) + "&"; });
        if (selectedDateRange !== undefined)
            selectedDateRange && selectedDateRange.forEach(item_ => { url_ += "selectedDateRange=" + encodeURIComponent(item_ ? "" + item_.toJSON() : "null") + "&"; });
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFastCountCampaignsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFastCountCampaignsList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCampaignsListForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCampaignsListForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFastCountCampaignsList(response: HttpResponseBase): Observable<PagedResultDtoOfGetCampaignsListForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCampaignsListForView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCampaignsListForView>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    updateFastCountMailerId(campaignId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/UpdateFastCountMailerId?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFastCountMailerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFastCountMailerId(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateFastCountMailerId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @return Success
     */
    getGenericMailerForDB(databaseId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetGenericMailerForDB?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGenericMailerForDB(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGenericMailerForDB(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetGenericMailerForDB(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    getSegmentsWithSourcesAndSubSelect(campaignId: number | null | undefined): Observable<{ [key: string]: string[]; }> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/getSegmentsWithSourcesAndSubSelect?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSegmentsWithSourcesAndSubSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSegmentsWithSourcesAndSubSelect(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: string[]; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: string[]; }>><any>_observableThrow(response_);
        }));
    }

    protected processGetSegmentsWithSourcesAndSubSelect(response: HttpResponseBase): Observable<{ [key: string]: string[]; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key] !== undefined ? resultData200[key] : [];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: string[]; }>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    campaignActions(input: CampaignActionInputDto | null | undefined): Observable<CampaignActionOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/CampaignActions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCampaignActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCampaignActions(<any>response_);
                } catch (e) {
                    return <Observable<CampaignActionOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CampaignActionOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCampaignActions(response: HttpResponseBase): Observable<CampaignActionOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CampaignActionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CampaignActionOutputDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateOrderStatus(input: CampaignActionInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/UpdateOrderStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrderStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrderStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrderStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    executeCampaign(input: CampaignActionInputDto | null | undefined): Observable<CampaignActionOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/ExecuteCampaign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecuteCampaign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecuteCampaign(<any>response_);
                } catch (e) {
                    return <Observable<CampaignActionOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CampaignActionOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processExecuteCampaign(response: HttpResponseBase): Observable<CampaignActionOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CampaignActionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CampaignActionOutputDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    campaignScheduleActionsValidations(input: CampaignActionInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/CampaignScheduleActionsValidations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCampaignScheduleActionsValidations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCampaignScheduleActionsValidations(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCampaignScheduleActionsValidations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    checkLatestBuildForScheduleCampaign(input: CampaignActionInputDto | null | undefined): Observable<CampaignActionOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/CheckLatestBuildForScheduleCampaign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckLatestBuildForScheduleCampaign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckLatestBuildForScheduleCampaign(<any>response_);
                } catch (e) {
                    return <Observable<CampaignActionOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CampaignActionOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCheckLatestBuildForScheduleCampaign(response: HttpResponseBase): Observable<CampaignActionOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CampaignActionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CampaignActionOutputDto>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param newStatus (optional) 
     * @param date (optional) 
     * @param time (optional) 
     * @param buildId (optional) 
     * @param currentStatus (optional) 
     * @return Success
     */
    scheduleCampaign(campaignId: number | null | undefined, newStatus: number | null | undefined, date: string | null | undefined, time: string | null | undefined, buildId: number | null | undefined, currentStatus: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/ScheduleCampaign?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (newStatus !== undefined)
            url_ += "newStatus=" + encodeURIComponent("" + newStatus) + "&"; 
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent("" + date) + "&"; 
        if (time !== undefined)
            url_ += "time=" + encodeURIComponent("" + time) + "&"; 
        if (buildId !== undefined)
            url_ += "buildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (currentStatus !== undefined)
            url_ += "currentStatus=" + encodeURIComponent("" + currentStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScheduleCampaign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScheduleCampaign(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processScheduleCampaign(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param databaseId (optional) 
     * @param reshipEmail (optional) 
     * @return Success
     */
    reshipCampaign(campaignId: number | null | undefined, databaseId: number | null | undefined, reshipEmail: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/ReshipCampaign?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (reshipEmail !== undefined)
            url_ += "reshipEmail=" + encodeURIComponent("" + reshipEmail) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReshipCampaign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReshipCampaign(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReshipCampaign(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    cancelCampaign(campaignId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/CancelCampaign?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelCampaign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelCampaign(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelCampaign(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    resetCampaign(campaignId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/ResetCampaign?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetCampaign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetCampaign(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetCampaign(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param validationString (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    validateOutputFields(campaignId: number | null | undefined, validationString: string | null | undefined, databaseId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/ValidateOutputFields?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (validationString !== undefined)
            url_ += "validationString=" + encodeURIComponent("" + validationString) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateOutputFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateOutputFields(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processValidateOutputFields(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getServerDate(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetServerDate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServerDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServerDate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetServerDate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param iOrderID (optional) 
     * @param databaseID (optional) 
     * @return Success
     */
    printDetailsReport(iOrderID: number | null | undefined, databaseID: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/PrintDetailsReport?";
        if (iOrderID !== undefined)
            url_ += "iOrderID=" + encodeURIComponent("" + iOrderID) + "&"; 
        if (databaseID !== undefined)
            url_ += "databaseID=" + encodeURIComponent("" + databaseID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintDetailsReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintDetailsReport(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processPrintDetailsReport(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param buildID (optional) 
     * @param mailerID (optional) 
     * @param offerID (optional) 
     * @param userID (optional) 
     * @param iIsOrder (optional) 
     * @param iProvidedCount (optional) 
     * @param iIsRandomExecution (optional) 
     * @param iIsNetUse (optional) 
     * @param dDateLastRun (optional) 
     * @param cLVAOrderNo (optional) 
     * @param cBrokerPONo (optional) 
     * @param cNotes (optional) 
     * @param iDecoyQty (optional) 
     * @param iDecoyKeyMethod (optional) 
     * @param cDecoysByKeycode (optional) 
     * @param cSpecialProcess (optional) 
     * @param cShipTOEmail (optional) 
     * @param cShipCCEmail (optional) 
     * @param dShipDateShipped (optional) 
     * @param lK_ExportFileFormatID (optional) 
     * @param iIsAddHeader (optional) 
     * @param iIsUncompressed (optional) 
     * @param lK_PGPKeyFile (optional) 
     * @param cDatabaseName (optional) 
     * @param iSplitType (optional) 
     * @param iSplitIntoNParts (optional) 
     * @param cExportLayout (optional) 
     * @param iIsNoUsage (optional) 
     * @param iHouseFilePriority (optional) 
     * @param cOutputCase (optional) 
     * @param dCreatedDate (optional) 
     * @param dModifiedDate (optional) 
     * @param cModifiedBy (optional) 
     * @param divisionMailerID (optional) 
     * @param divisionBrokerID (optional) 
     * @param cDecoyKey1 (optional) 
     * @param iAvailableQty (optional) 
     * @param dMailDate (optional) 
     * @param iMailDatePlus (optional) 
     * @param iMailDateMinus (optional) 
     * @param iMinQuantityOrderLevelMaxPer (optional) 
     * @param iMaxQuantityOrderLevelMaxPer (optional) 
     * @param cChannelType (optional) 
     * @param cSANNumber (optional) 
     * @param iIsExportDataFileOnly (optional) 
     * @param lK_Media (optional) 
     * @param lK_AccountCode (optional) 
     * @param cBillingCompany (optional) 
     * @param cBillingPhone (optional) 
     * @param iExportLayoutID (optional) 
     * @param id (optional) 
     * @return Success
     */
    getDecoyGroup(buildID: number | null | undefined, mailerID: number | null | undefined, offerID: number | null | undefined, cOrderType: string, userID: number | null | undefined, iIsOrder: boolean | null | undefined, cDescription: string, iProvidedCount: number | null | undefined, iIsRandomExecution: boolean | null | undefined, iIsNetUse: boolean | null | undefined, dDateLastRun: moment.Moment | null | undefined, cSortFields: string, cOrderNo: string, cLVAOrderNo: string | null | undefined, cNextMarkOrderNo: string, cBrokerPONo: string | null | undefined, cNotes: string | null | undefined, iDecoyQty: number | null | undefined, iDecoyKeyMethod: number | null | undefined, cDecoyKey: string, cDecoysByKeycode: boolean | null | undefined, cSpecialProcess: string | null | undefined, cShiptoType: string, cShipTOEmail: string | null | undefined, cShipCCEmail: string | null | undefined, cShipSUBJECT: string, dShipDateShipped: moment.Moment | null | undefined, lK_ExportFileFormatID: string | null | undefined, iIsAddHeader: boolean | null | undefined, iIsUncompressed: boolean | null | undefined, lK_PGPKeyFile: string | null | undefined, cDatabaseName: string | null | undefined, iSplitType: number | null | undefined, iSplitIntoNParts: number | null | undefined, cExportLayout: string | null | undefined, iIsNoUsage: boolean | null | undefined, iHouseFilePriority: boolean | null | undefined, cOutputCase: string | null | undefined, dCreatedDate: moment.Moment | null | undefined, cCreatedBy: string, dModifiedDate: moment.Moment | null | undefined, cModifiedBy: string | null | undefined, cOfferName: string, divisionMailerID: number | null | undefined, divisionBrokerID: number | null | undefined, cDecoyKey1: string | null | undefined, iAvailableQty: number | null | undefined, dMailDate: moment.Moment | null | undefined, iMailDatePlus: number | null | undefined, iMailDateMinus: number | null | undefined, iMinQuantityOrderLevelMaxPer: number | null | undefined, iMaxQuantityOrderLevelMaxPer: number | null | undefined, cMaxPerFieldOrderLevel: string, cChannelType: string | null | undefined, cFileLabel: string, cSANNumber: string | null | undefined, iIsExportDataFileOnly: boolean | null | undefined, lK_Media: string | null | undefined, lK_AccountCode: string | null | undefined, cBillingCompany: string | null | undefined, cBillingPhone: string | null | undefined, iExportLayoutID: number | null | undefined, id: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetDecoyGroup?";
        if (buildID !== undefined)
            url_ += "BuildID=" + encodeURIComponent("" + buildID) + "&"; 
        if (mailerID !== undefined)
            url_ += "MailerID=" + encodeURIComponent("" + mailerID) + "&"; 
        if (offerID !== undefined)
            url_ += "OfferID=" + encodeURIComponent("" + offerID) + "&"; 
        if (cOrderType === undefined || cOrderType === null)
            throw new Error("The parameter 'cOrderType' must be defined and cannot be null.");
        else
            url_ += "cOrderType=" + encodeURIComponent("" + cOrderType) + "&"; 
        if (userID !== undefined)
            url_ += "UserID=" + encodeURIComponent("" + userID) + "&"; 
        if (iIsOrder !== undefined)
            url_ += "iIsOrder=" + encodeURIComponent("" + iIsOrder) + "&"; 
        if (cDescription === undefined || cDescription === null)
            throw new Error("The parameter 'cDescription' must be defined and cannot be null.");
        else
            url_ += "cDescription=" + encodeURIComponent("" + cDescription) + "&"; 
        if (iProvidedCount !== undefined)
            url_ += "iProvidedCount=" + encodeURIComponent("" + iProvidedCount) + "&"; 
        if (iIsRandomExecution !== undefined)
            url_ += "iIsRandomExecution=" + encodeURIComponent("" + iIsRandomExecution) + "&"; 
        if (iIsNetUse !== undefined)
            url_ += "iIsNetUse=" + encodeURIComponent("" + iIsNetUse) + "&"; 
        if (dDateLastRun !== undefined)
            url_ += "dDateLastRun=" + encodeURIComponent(dDateLastRun ? "" + dDateLastRun.toJSON() : "") + "&"; 
        if (cSortFields === undefined || cSortFields === null)
            throw new Error("The parameter 'cSortFields' must be defined and cannot be null.");
        else
            url_ += "cSortFields=" + encodeURIComponent("" + cSortFields) + "&"; 
        if (cOrderNo === undefined || cOrderNo === null)
            throw new Error("The parameter 'cOrderNo' must be defined and cannot be null.");
        else
            url_ += "cOrderNo=" + encodeURIComponent("" + cOrderNo) + "&"; 
        if (cLVAOrderNo !== undefined)
            url_ += "cLVAOrderNo=" + encodeURIComponent("" + cLVAOrderNo) + "&"; 
        if (cNextMarkOrderNo === undefined || cNextMarkOrderNo === null)
            throw new Error("The parameter 'cNextMarkOrderNo' must be defined and cannot be null.");
        else
            url_ += "cNextMarkOrderNo=" + encodeURIComponent("" + cNextMarkOrderNo) + "&"; 
        if (cBrokerPONo !== undefined)
            url_ += "cBrokerPONo=" + encodeURIComponent("" + cBrokerPONo) + "&"; 
        if (cNotes !== undefined)
            url_ += "cNotes=" + encodeURIComponent("" + cNotes) + "&"; 
        if (iDecoyQty !== undefined)
            url_ += "iDecoyQty=" + encodeURIComponent("" + iDecoyQty) + "&"; 
        if (iDecoyKeyMethod !== undefined)
            url_ += "iDecoyKeyMethod=" + encodeURIComponent("" + iDecoyKeyMethod) + "&"; 
        if (cDecoyKey === undefined || cDecoyKey === null)
            throw new Error("The parameter 'cDecoyKey' must be defined and cannot be null.");
        else
            url_ += "cDecoyKey=" + encodeURIComponent("" + cDecoyKey) + "&"; 
        if (cDecoysByKeycode !== undefined)
            url_ += "cDecoysByKeycode=" + encodeURIComponent("" + cDecoysByKeycode) + "&"; 
        if (cSpecialProcess !== undefined)
            url_ += "cSpecialProcess=" + encodeURIComponent("" + cSpecialProcess) + "&"; 
        if (cShiptoType === undefined || cShiptoType === null)
            throw new Error("The parameter 'cShiptoType' must be defined and cannot be null.");
        else
            url_ += "cShiptoType=" + encodeURIComponent("" + cShiptoType) + "&"; 
        if (cShipTOEmail !== undefined)
            url_ += "cShipTOEmail=" + encodeURIComponent("" + cShipTOEmail) + "&"; 
        if (cShipCCEmail !== undefined)
            url_ += "cShipCCEmail=" + encodeURIComponent("" + cShipCCEmail) + "&"; 
        if (cShipSUBJECT === undefined || cShipSUBJECT === null)
            throw new Error("The parameter 'cShipSUBJECT' must be defined and cannot be null.");
        else
            url_ += "cShipSUBJECT=" + encodeURIComponent("" + cShipSUBJECT) + "&"; 
        if (dShipDateShipped !== undefined)
            url_ += "dShipDateShipped=" + encodeURIComponent(dShipDateShipped ? "" + dShipDateShipped.toJSON() : "") + "&"; 
        if (lK_ExportFileFormatID !== undefined)
            url_ += "LK_ExportFileFormatID=" + encodeURIComponent("" + lK_ExportFileFormatID) + "&"; 
        if (iIsAddHeader !== undefined)
            url_ += "iIsAddHeader=" + encodeURIComponent("" + iIsAddHeader) + "&"; 
        if (iIsUncompressed !== undefined)
            url_ += "iIsUncompressed=" + encodeURIComponent("" + iIsUncompressed) + "&"; 
        if (lK_PGPKeyFile !== undefined)
            url_ += "LK_PGPKeyFile=" + encodeURIComponent("" + lK_PGPKeyFile) + "&"; 
        if (cDatabaseName !== undefined)
            url_ += "cDatabaseName=" + encodeURIComponent("" + cDatabaseName) + "&"; 
        if (iSplitType !== undefined)
            url_ += "iSplitType=" + encodeURIComponent("" + iSplitType) + "&"; 
        if (iSplitIntoNParts !== undefined)
            url_ += "iSplitIntoNParts=" + encodeURIComponent("" + iSplitIntoNParts) + "&"; 
        if (cExportLayout !== undefined)
            url_ += "cExportLayout=" + encodeURIComponent("" + cExportLayout) + "&"; 
        if (iIsNoUsage !== undefined)
            url_ += "iIsNoUsage=" + encodeURIComponent("" + iIsNoUsage) + "&"; 
        if (iHouseFilePriority !== undefined)
            url_ += "iHouseFilePriority=" + encodeURIComponent("" + iHouseFilePriority) + "&"; 
        if (cOutputCase !== undefined)
            url_ += "cOutputCase=" + encodeURIComponent("" + cOutputCase) + "&"; 
        if (dCreatedDate !== undefined)
            url_ += "dCreatedDate=" + encodeURIComponent(dCreatedDate ? "" + dCreatedDate.toJSON() : "") + "&"; 
        if (cCreatedBy === undefined || cCreatedBy === null)
            throw new Error("The parameter 'cCreatedBy' must be defined and cannot be null.");
        else
            url_ += "cCreatedBy=" + encodeURIComponent("" + cCreatedBy) + "&"; 
        if (dModifiedDate !== undefined)
            url_ += "dModifiedDate=" + encodeURIComponent(dModifiedDate ? "" + dModifiedDate.toJSON() : "") + "&"; 
        if (cModifiedBy !== undefined)
            url_ += "cModifiedBy=" + encodeURIComponent("" + cModifiedBy) + "&"; 
        if (cOfferName === undefined || cOfferName === null)
            throw new Error("The parameter 'cOfferName' must be defined and cannot be null.");
        else
            url_ += "cOfferName=" + encodeURIComponent("" + cOfferName) + "&"; 
        if (divisionMailerID !== undefined)
            url_ += "DivisionMailerID=" + encodeURIComponent("" + divisionMailerID) + "&"; 
        if (divisionBrokerID !== undefined)
            url_ += "DivisionBrokerID=" + encodeURIComponent("" + divisionBrokerID) + "&"; 
        if (cDecoyKey1 !== undefined)
            url_ += "cDecoyKey1=" + encodeURIComponent("" + cDecoyKey1) + "&"; 
        if (iAvailableQty !== undefined)
            url_ += "iAvailableQty=" + encodeURIComponent("" + iAvailableQty) + "&"; 
        if (dMailDate !== undefined)
            url_ += "dMailDate=" + encodeURIComponent(dMailDate ? "" + dMailDate.toJSON() : "") + "&"; 
        if (iMailDatePlus !== undefined)
            url_ += "iMailDatePlus=" + encodeURIComponent("" + iMailDatePlus) + "&"; 
        if (iMailDateMinus !== undefined)
            url_ += "iMailDateMinus=" + encodeURIComponent("" + iMailDateMinus) + "&"; 
        if (iMinQuantityOrderLevelMaxPer !== undefined)
            url_ += "iMinQuantityOrderLevelMaxPer=" + encodeURIComponent("" + iMinQuantityOrderLevelMaxPer) + "&"; 
        if (iMaxQuantityOrderLevelMaxPer !== undefined)
            url_ += "iMaxQuantityOrderLevelMaxPer=" + encodeURIComponent("" + iMaxQuantityOrderLevelMaxPer) + "&"; 
        if (cMaxPerFieldOrderLevel === undefined || cMaxPerFieldOrderLevel === null)
            throw new Error("The parameter 'cMaxPerFieldOrderLevel' must be defined and cannot be null.");
        else
            url_ += "cMaxPerFieldOrderLevel=" + encodeURIComponent("" + cMaxPerFieldOrderLevel) + "&"; 
        if (cChannelType !== undefined)
            url_ += "cChannelType=" + encodeURIComponent("" + cChannelType) + "&"; 
        if (cFileLabel === undefined || cFileLabel === null)
            throw new Error("The parameter 'cFileLabel' must be defined and cannot be null.");
        else
            url_ += "cFileLabel=" + encodeURIComponent("" + cFileLabel) + "&"; 
        if (cSANNumber !== undefined)
            url_ += "cSANNumber=" + encodeURIComponent("" + cSANNumber) + "&"; 
        if (iIsExportDataFileOnly !== undefined)
            url_ += "iIsExportDataFileOnly=" + encodeURIComponent("" + iIsExportDataFileOnly) + "&"; 
        if (lK_Media !== undefined)
            url_ += "LK_Media=" + encodeURIComponent("" + lK_Media) + "&"; 
        if (lK_AccountCode !== undefined)
            url_ += "LK_AccountCode=" + encodeURIComponent("" + lK_AccountCode) + "&"; 
        if (cBillingCompany !== undefined)
            url_ += "cBillingCompany=" + encodeURIComponent("" + cBillingCompany) + "&"; 
        if (cBillingPhone !== undefined)
            url_ += "cBillingPhone=" + encodeURIComponent("" + cBillingPhone) + "&"; 
        if (iExportLayoutID !== undefined)
            url_ += "iExportLayoutID=" + encodeURIComponent("" + iExportLayoutID) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDecoyGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDecoyGroup(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDecoyGroup(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param campaignID (optional) 
     * @param cDecoyGroup (optional) 
     * @return Success
     */
    getDecoyGroupList(campaignID: number | null | undefined, cDecoyGroup: string | null | undefined): Observable<DecoyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetDecoyGroupList?";
        if (campaignID !== undefined)
            url_ += "campaignID=" + encodeURIComponent("" + campaignID) + "&"; 
        if (cDecoyGroup !== undefined)
            url_ += "cDecoyGroup=" + encodeURIComponent("" + cDecoyGroup) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDecoyGroupList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDecoyGroupList(<any>response_);
                } catch (e) {
                    return <Observable<DecoyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DecoyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDecoyGroupList(response: HttpResponseBase): Observable<DecoyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DecoyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DecoyDto[]>(<any>null);
    }

    /**
     * @param decoysRecord (optional) 
     * @return Success
     */
    validateDecoys(decoysRecord: DecoyDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/ValidateDecoys";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(decoysRecord);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateDecoys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateDecoys(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processValidateDecoys(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param campaignID (optional) 
     * @return Success
     */
    fetchAttachmentsData(campaignID: number | null | undefined): Observable<CampaignAttachmentDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/FetchAttachmentsData?";
        if (campaignID !== undefined)
            url_ += "campaignID=" + encodeURIComponent("" + campaignID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAttachmentsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAttachmentsData(<any>response_);
                } catch (e) {
                    return <Observable<CampaignAttachmentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CampaignAttachmentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAttachmentsData(response: HttpResponseBase): Observable<CampaignAttachmentDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CampaignAttachmentDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CampaignAttachmentDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCampaignAttachment(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/DeleteCampaignAttachment?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCampaignAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCampaignAttachment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCampaignAttachment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filename (optional) 
     * @param sysfileName (optional) 
     * @param code (optional) 
     * @param id (optional) 
     * @param campaignId (optional) 
     * @return Success
     */
    uploadFile(filename: string | null | undefined, sysfileName: string | null | undefined, code: string | null | undefined, id: number | null | undefined, campaignId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/UploadFile?";
        if (filename !== undefined)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&"; 
        if (sysfileName !== undefined)
            url_ += "sysfileName=" + encodeURIComponent("" + sysfileName) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param attachmentType (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    downloadFile(campaignId: number | null | undefined, attachmentType: string | null | undefined, databaseId: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/DownloadFile?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (attachmentType !== undefined)
            url_ += "attachmentType=" + encodeURIComponent("" + attachmentType) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFile(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param iOrderID (optional) 
     * @param iExportLayoutID (optional) 
     * @param sInitiatedBy (optional) 
     * @param campaignStatus (optional) 
     * @return Success
     */
    copyOrderExportLayout(iOrderID: number | null | undefined, iExportLayoutID: number | null | undefined, sInitiatedBy: string | null | undefined, campaignStatus: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/CopyOrderExportLayout?";
        if (iOrderID !== undefined)
            url_ += "iOrderID=" + encodeURIComponent("" + iOrderID) + "&"; 
        if (iExportLayoutID !== undefined)
            url_ += "iExportLayoutID=" + encodeURIComponent("" + iExportLayoutID) + "&"; 
        if (sInitiatedBy !== undefined)
            url_ += "sInitiatedBy=" + encodeURIComponent("" + sInitiatedBy) + "&"; 
        if (campaignStatus !== undefined)
            url_ += "campaignStatus=" + encodeURIComponent("" + campaignStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyOrderExportLayout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyOrderExportLayout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCopyOrderExportLayout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param camapignID (optional) 
     * @param listOfMaxPerFields (optional) 
     * @return Success
     */
    getAllSegmentLevelMaxPer(camapignID: number | null | undefined, listOfMaxPerFields: any[] | null | undefined): Observable<SegmentLevelMaxPerDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetAllSegmentLevelMaxPer?";
        if (camapignID !== undefined)
            url_ += "camapignID=" + encodeURIComponent("" + camapignID) + "&"; 
        if (listOfMaxPerFields !== undefined)
            listOfMaxPerFields && listOfMaxPerFields.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "listOfMaxPerFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegmentLevelMaxPer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegmentLevelMaxPer(<any>response_);
                } catch (e) {
                    return <Observable<SegmentLevelMaxPerDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SegmentLevelMaxPerDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSegmentLevelMaxPer(response: HttpResponseBase): Observable<SegmentLevelMaxPerDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SegmentLevelMaxPerDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SegmentLevelMaxPerDto[]>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @param buildId (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getMaxPerFieldDropdownData(databaseId: number | null | undefined, buildId: number | null | undefined, filter: string | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetMaxPerFieldDropdownData?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (buildId !== undefined)
            url_ += "buildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaxPerFieldDropdownData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaxPerFieldDropdownData(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaxPerFieldDropdownData(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    launchOESS(input: CampaignOESSDto | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/LaunchOESS";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLaunchOESS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLaunchOESS(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processLaunchOESS(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param companyId (optional) 
     * @return Success
     */
    getDetailsByCompanyIdAndOrderId(campaignId: number | null | undefined, companyId: number | null | undefined): Observable<GetCampaignsOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetDetailsByCompanyIdAndOrderId?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailsByCompanyIdAndOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailsByCompanyIdAndOrderId(<any>response_);
                } catch (e) {
                    return <Observable<GetCampaignsOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCampaignsOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailsByCompanyIdAndOrderId(response: HttpResponseBase): Observable<GetCampaignsOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCampaignsOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCampaignsOutputDto>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    downloadOutputLayoutTemplateExcelTest(campaignId: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/DownloadOutputLayoutTemplateExcelTest?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadOutputLayoutTemplateExcelTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadOutputLayoutTemplateExcelTest(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadOutputLayoutTemplateExcelTest(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    getSplitPartForCampaignId(campaignId: number | null | undefined): Observable<Campaign> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetSplitPartForCampaignId?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSplitPartForCampaignId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSplitPartForCampaignId(<any>response_);
                } catch (e) {
                    return <Observable<Campaign>><any>_observableThrow(e);
                }
            } else
                return <Observable<Campaign>><any>_observableThrow(response_);
        }));
    }

    protected processGetSplitPartForCampaignId(response: HttpResponseBase): Observable<Campaign> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Campaign.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Campaign>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param part (optional) 
     * @return Success
     */
    getExportParts(campaignId: number | null | undefined, part: number | null | undefined): Observable<CampaignExportPartDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetExportParts?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (part !== undefined)
            url_ += "part=" + encodeURIComponent("" + part) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExportParts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExportParts(<any>response_);
                } catch (e) {
                    return <Observable<CampaignExportPartDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CampaignExportPartDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExportParts(response: HttpResponseBase): Observable<CampaignExportPartDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CampaignExportPartDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CampaignExportPartDto[]>(<any>null);
    }

    /**
     * @param campaignID (optional) 
     * @return Success
     */
    getExistingMultidimensionalReports(campaignID: number | null | undefined): Observable<GetCampaignMultidimensionalReportForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetExistingMultidimensionalReports?";
        if (campaignID !== undefined)
            url_ += "campaignID=" + encodeURIComponent("" + campaignID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExistingMultidimensionalReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExistingMultidimensionalReports(<any>response_);
                } catch (e) {
                    return <Observable<GetCampaignMultidimensionalReportForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCampaignMultidimensionalReportForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExistingMultidimensionalReports(response: HttpResponseBase): Observable<GetCampaignMultidimensionalReportForViewDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCampaignMultidimensionalReportForViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCampaignMultidimensionalReportForViewDto[]>(<any>null);
    }

    /**
     * @param campaignID (optional) 
     * @return Success
     */
    downloadMulticolumnReport(campaignID: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/DownloadMulticolumnReport?";
        if (campaignID !== undefined)
            url_ += "campaignID=" + encodeURIComponent("" + campaignID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadMulticolumnReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadMulticolumnReport(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadMulticolumnReport(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param campaignID (optional) 
     * @return Success
     */
    downloadXtabReport(campaignID: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/DownloadXtabReport?";
        if (campaignID !== undefined)
            url_ += "campaignID=" + encodeURIComponent("" + campaignID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadXtabReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadXtabReport(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadXtabReport(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param orderStatus (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCampaignDto | null | undefined, orderStatus: number | null | undefined): Observable<GetCampaignsListForView> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/CreateOrEditAsync?";
        if (orderStatus !== undefined)
            url_ += "orderStatus=" + encodeURIComponent("" + orderStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCampaignsListForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCampaignsListForView>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<GetCampaignsListForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCampaignsListForView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCampaignsListForView>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    validateCampaignForSAN(campaignId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/ValidateCampaignForSAN?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateCampaignForSAN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateCampaignForSAN(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processValidateCampaignForSAN(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param buildId (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    checkAutoSupress(buildId: number | null | undefined, databaseId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/CheckAutoSupress?";
        if (buildId !== undefined)
            url_ += "buildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAutoSupress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAutoSupress(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckAutoSupress(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param iD (optional) 
     * @param description (optional) 
     * @param status (optional) 
     * @param selectedDateRange (optional) 
     * @param userID (optional) 
     * @param userName (optional) 
     * @param databaseName (optional) 
     * @param customerName (optional) 
     * @param buildDescription (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCampaignsList(filter: string | null | undefined, iD: string | null | undefined, description: string | null | undefined, status: string | null | undefined, selectedDateRange: moment.Moment[] | null | undefined, userID: number | null | undefined, userName: string | null | undefined, databaseName: string | null | undefined, customerName: string | null | undefined, buildDescription: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCampaignsListForView> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetAllCampaignsList?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&"; 
        if (description !== undefined)
            url_ += "Description=" + encodeURIComponent("" + description) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (selectedDateRange !== undefined)
            selectedDateRange && selectedDateRange.forEach(item_ => { url_ += "selectedDateRange=" + encodeURIComponent(item_ ? "" + item_.toJSON() : "null") + "&"; });
        if (userID !== undefined)
            url_ += "UserID=" + encodeURIComponent("" + userID) + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (databaseName !== undefined)
            url_ += "DatabaseName=" + encodeURIComponent("" + databaseName) + "&"; 
        if (customerName !== undefined)
            url_ += "CustomerName=" + encodeURIComponent("" + customerName) + "&"; 
        if (buildDescription !== undefined)
            url_ += "BuildDescription=" + encodeURIComponent("" + buildDescription) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCampaignsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCampaignsList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCampaignsListForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCampaignsListForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCampaignsList(response: HttpResponseBase): Observable<PagedResultDtoOfGetCampaignsListForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCampaignsListForView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCampaignsListForView>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAllCampaignQueue(userId: number | null | undefined): Observable<CampaignQueueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetAllCampaignQueue?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCampaignQueue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCampaignQueue(<any>response_);
                } catch (e) {
                    return <Observable<CampaignQueueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CampaignQueueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCampaignQueue(response: HttpResponseBase): Observable<CampaignQueueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CampaignQueueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CampaignQueueDto[]>(<any>null);
    }

    /**
     * @param campaign (optional) 
     * @return Success
     */
    createCopyCampaign(campaign: CampaignCopyDto | null | undefined): Observable<GetCampaignsListForView[]> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/CreateCopyCampaign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(campaign);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCopyCampaign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCopyCampaign(<any>response_);
                } catch (e) {
                    return <Observable<GetCampaignsListForView[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCampaignsListForView[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCopyCampaign(response: HttpResponseBase): Observable<GetCampaignsListForView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCampaignsListForView.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCampaignsListForView[]>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    deleteCampaign(campaignId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/DeleteCampaign?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCampaign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCampaign(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCampaign(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    getCampaignForCopy(campaignId: number | null | undefined): Observable<GetCampaignForCopyOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetCampaignForCopy?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCampaignForCopy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCampaignForCopy(<any>response_);
                } catch (e) {
                    return <Observable<GetCampaignForCopyOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCampaignForCopyOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCampaignForCopy(response: HttpResponseBase): Observable<GetCampaignForCopyOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCampaignForCopyOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCampaignForCopyOutputDto>(<any>null);
    }

    /**
     * @param campaignid (optional) 
     * @param databaseId (optional) 
     * @param divisionId (optional) 
     * @return Success
     */
    getCampaignForEdit(campaignid: number | null | undefined, databaseId: number | null | undefined, divisionId: number | null | undefined): Observable<CreateOrEditCampaignDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetCampaignForEdit?";
        if (campaignid !== undefined)
            url_ += "campaignid=" + encodeURIComponent("" + campaignid) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (divisionId !== undefined)
            url_ += "divisionId=" + encodeURIComponent("" + divisionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCampaignForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCampaignForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditCampaignDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditCampaignDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCampaignForEdit(response: HttpResponseBase): Observable<CreateOrEditCampaignDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditCampaignDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditCampaignDto>(<any>null);
    }

    /**
     * @param userid (optional) 
     * @param currentDatabaseId (optional) 
     * @return Success
     */
    getAllDatabasesForDropdown(userid: number | null | undefined, currentDatabaseId: number | null | undefined): Observable<GetAllDatabasesDropdownDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetAllDatabasesForDropdown?";
        if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&"; 
        if (currentDatabaseId !== undefined)
            url_ += "currentDatabaseId=" + encodeURIComponent("" + currentDatabaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDatabasesForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDatabasesForDropdown(<any>response_);
                } catch (e) {
                    return <Observable<GetAllDatabasesDropdownDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllDatabasesDropdownDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDatabasesForDropdown(response: HttpResponseBase): Observable<GetAllDatabasesDropdownDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllDatabasesDropdownDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllDatabasesDropdownDto>(<any>null);
    }

    /**
     * @param iMailerID (optional) 
     * @return Success
     */
    getOffersDDForMailer(iMailerID: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetOffersDDForMailer?";
        if (iMailerID !== undefined)
            url_ += "iMailerID=" + encodeURIComponent("" + iMailerID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOffersDDForMailer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOffersDDForMailer(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOffersDDForMailer(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param defaultDatabaseId (optional) 
     * @return Success
     */
    getDatabaseWithLatestBuild(defaultDatabaseId: number | null | undefined): Observable<GetCampaignDropdownsDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetDatabaseWithLatestBuild?";
        if (defaultDatabaseId !== undefined)
            url_ += "defaultDatabaseId=" + encodeURIComponent("" + defaultDatabaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatabaseWithLatestBuild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatabaseWithLatestBuild(<any>response_);
                } catch (e) {
                    return <Observable<GetCampaignDropdownsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCampaignDropdownsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatabaseWithLatestBuild(response: HttpResponseBase): Observable<GetCampaignDropdownsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCampaignDropdownsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCampaignDropdownsDto>(<any>null);
    }

    /**
     * @param iDatabaseID (optional) 
     * @return Success
     */
    getFieldsOnDatabaseChange(iDatabaseID: number | null | undefined): Observable<GetCampaignDropdownsDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetFieldsOnDatabaseChange?";
        if (iDatabaseID !== undefined)
            url_ += "iDatabaseID=" + encodeURIComponent("" + iDatabaseID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFieldsOnDatabaseChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFieldsOnDatabaseChange(<any>response_);
                } catch (e) {
                    return <Observable<GetCampaignDropdownsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCampaignDropdownsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFieldsOnDatabaseChange(response: HttpResponseBase): Observable<GetCampaignDropdownsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCampaignDropdownsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCampaignDropdownsDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param databaseID (optional) 
     * @param divisionalDatabase (optional) 
     * @return Success
     */
    getSearchResultForMailer(filter: string | null | undefined, databaseID: number | null | undefined, divisionalDatabase: boolean | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetSearchResultForMailer?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (databaseID !== undefined)
            url_ += "DatabaseID=" + encodeURIComponent("" + databaseID) + "&"; 
        if (divisionalDatabase !== undefined)
            url_ += "DivisionalDatabase=" + encodeURIComponent("" + divisionalDatabase) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSearchResultForMailer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSearchResultForMailer(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSearchResultForMailer(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param databaseID (optional) 
     * @param divisionalDatabase (optional) 
     * @return Success
     */
    getDivisionBrokers(filter: string | null | undefined, databaseID: number | null | undefined, divisionalDatabase: boolean | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetDivisionBrokers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (databaseID !== undefined)
            url_ += "DatabaseID=" + encodeURIComponent("" + databaseID) + "&"; 
        if (divisionalDatabase !== undefined)
            url_ += "DivisionalDatabase=" + encodeURIComponent("" + divisionalDatabase) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDivisionBrokers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDivisionBrokers(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDivisionBrokers(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    fetchUserDatabaseMailerBasedOnUser(userId: number | null | undefined): Observable<UserDatabaseMailerDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/FetchUserDatabaseMailerBasedOnUser?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchUserDatabaseMailerBasedOnUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchUserDatabaseMailerBasedOnUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDatabaseMailerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDatabaseMailerDto>><any>_observableThrow(response_);
        }));
    }

    protected processFetchUserDatabaseMailerBasedOnUser(response: HttpResponseBase): Observable<UserDatabaseMailerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDatabaseMailerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDatabaseMailerDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCampaignForView(id: number | null | undefined): Observable<GetCampaignsListForView> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetCampaignForView?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCampaignForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCampaignForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCampaignsListForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCampaignsListForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetCampaignForView(response: HttpResponseBase): Observable<GetCampaignsListForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCampaignsListForView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCampaignsListForView>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    fetchOrderLevelMaxPer(campaignId: number | null | undefined): Observable<CampaignLevelMaxPerDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/FetchOrderLevelMaxPer?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchOrderLevelMaxPer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchOrderLevelMaxPer(<any>response_);
                } catch (e) {
                    return <Observable<CampaignLevelMaxPerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CampaignLevelMaxPerDto>><any>_observableThrow(response_);
        }));
    }

    protected processFetchOrderLevelMaxPer(response: HttpResponseBase): Observable<CampaignLevelMaxPerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CampaignLevelMaxPerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CampaignLevelMaxPerDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCampaignStatus(id: number | null | undefined): Observable<DropdownOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Campaigns/GetCampaignStatus?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCampaignStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCampaignStatus(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCampaignStatus(response: HttpResponseBase): Observable<DropdownOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DropdownOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserChatFriendsWithSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | null | undefined, minMessageId: number | null | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfChatMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | null | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDefaultEditionNameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class ContactsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param contactId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllContacts(contactId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, contactType: ContactType): Observable<PagedResultDtoOfContactDto> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetAllContacts?";
        if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (contactType === undefined || contactType === null)
            throw new Error("The parameter 'contactType' must be defined and cannot be null.");
        else
            url_ += "contactType=" + encodeURIComponent("" + contactType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContacts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfContactDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfContactDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllContacts(response: HttpResponseBase): Observable<PagedResultDtoOfContactDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfContactDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfContactDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContactForEdit(id: number | null | undefined): Observable<CreateOrEditContactDto> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetContactForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditContactDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditContactDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactForEdit(response: HttpResponseBase): Observable<CreateOrEditContactDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditContactDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditContactDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditContactDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DatabasesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param userID (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDatabases(filter: string | null | undefined, userID: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDatabaseDto> {
        let url_ = this.baseUrl + "/api/services/app/Databases/GetAllDatabases?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (userID !== undefined)
            url_ += "UserID=" + encodeURIComponent("" + userID) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDatabases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDatabases(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDatabaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDatabaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDatabases(response: HttpResponseBase): Observable<PagedResultDtoOfDatabaseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDatabaseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDatabaseDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDatabaseForEdit(id: number | null | undefined): Observable<CreateOrEditDatabaseDto> {
        let url_ = this.baseUrl + "/api/services/app/Databases/GetDatabaseForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatabaseForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatabaseForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditDatabaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditDatabaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatabaseForEdit(response: HttpResponseBase): Observable<CreateOrEditDatabaseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditDatabaseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditDatabaseDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDatabaseWithNoAccessCheck(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Databases/GetDatabaseWithNoAccessCheck";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatabaseWithNoAccessCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatabaseWithNoAccessCheck(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatabaseWithNoAccessCheck(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditDatabaseDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Databases/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    getDatabaseDropDownsDto(userId: number | null | undefined, databaseId: number | null | undefined): Observable<GetDatabaseDropDownsDto> {
        let url_ = this.baseUrl + "/api/services/app/Databases/GetDatabaseDropDownsDto?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatabaseDropDownsDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatabaseDropDownsDto(<any>response_);
                } catch (e) {
                    return <Observable<GetDatabaseDropDownsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDatabaseDropDownsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatabaseDropDownsDto(response: HttpResponseBase): Observable<GetDatabaseDropDownsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDatabaseDropDownsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDatabaseDropDownsDto>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @param databaseName (optional) 
     * @return Success
     */
    exportDatabaseExcel(databaseId: number | null | undefined, databaseName: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Databases/ExportDatabaseExcel?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (databaseName !== undefined)
            url_ += "databaseName=" + encodeURIComponent("" + databaseName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportDatabaseExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportDatabaseExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportDatabaseExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDatabasesForUser(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Databases/GetDatabasesForUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatabasesForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatabasesForUser(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatabasesForUser(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getExportLayoutDatabasesForUser(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Databases/GetExportLayoutDatabasesForUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExportLayoutDatabasesForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExportLayoutDatabasesForUser(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExportLayoutDatabasesForUser(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param userid (optional) 
     * @param currentDatabaseId (optional) 
     * @return Success
     */
    getAllDatabasesForUser(userid: number | null | undefined, currentDatabaseId: number | null | undefined): Observable<GetAllDatabaseForUserDto> {
        let url_ = this.baseUrl + "/api/services/app/Databases/GetAllDatabasesForUser?";
        if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&"; 
        if (currentDatabaseId !== undefined)
            url_ += "currentDatabaseId=" + encodeURIComponent("" + currentDatabaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDatabasesForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDatabasesForUser(<any>response_);
                } catch (e) {
                    return <Observable<GetAllDatabaseForUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllDatabaseForUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDatabasesForUser(response: HttpResponseBase): Observable<GetAllDatabaseForUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllDatabaseForUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllDatabaseForUserDto>(<any>null);
    }
}

@Injectable()
export class DecoysServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param selectedDatabase (optional) 
     * @param mailerId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDecoyMailers(filter: string | null | undefined, selectedDatabase: number | null | undefined, mailerId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfMailerDto> {
        let url_ = this.baseUrl + "/api/services/app/Decoys/GetAllDecoyMailers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (selectedDatabase !== undefined)
            url_ += "SelectedDatabase=" + encodeURIComponent("" + selectedDatabase) + "&"; 
        if (mailerId !== undefined)
            url_ += "mailerId=" + encodeURIComponent("" + mailerId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDecoyMailers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDecoyMailers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMailerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMailerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDecoyMailers(response: HttpResponseBase): Observable<PagedResultDtoOfMailerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMailerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMailerDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param selectedDatabase (optional) 
     * @param mailerId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getDecoysByMailer(filter: string | null | undefined, selectedDatabase: number | null | undefined, mailerId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDecoyDto> {
        let url_ = this.baseUrl + "/api/services/app/Decoys/GetDecoysByMailer?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (selectedDatabase !== undefined)
            url_ += "SelectedDatabase=" + encodeURIComponent("" + selectedDatabase) + "&"; 
        if (mailerId !== undefined)
            url_ += "mailerId=" + encodeURIComponent("" + mailerId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDecoysByMailer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDecoysByMailer(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDecoyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDecoyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDecoysByMailer(response: HttpResponseBase): Observable<PagedResultDtoOfDecoyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDecoyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDecoyDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDecoyForEdit(id: number | null | undefined): Observable<CreateOrEditDecoyDto> {
        let url_ = this.baseUrl + "/api/services/app/Decoys/GetDecoyForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDecoyForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDecoyForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditDecoyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditDecoyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDecoyForEdit(response: HttpResponseBase): Observable<CreateOrEditDecoyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditDecoyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditDecoyDto>(<any>null);
    }

    /**
     * @return Success
     */
    fillGroupsForEdit(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Decoys/FillGroupsForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillGroupsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillGroupsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processFillGroupsForEdit(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEditDecoy(input: CreateOrEditDecoyDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Decoys/CreateOrEditDecoy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditDecoy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditDecoy(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditDecoy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    copyDecoy(input: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Decoys/CopyDecoy?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyDecoy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyDecoy(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCopyDecoy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteDecoy(input: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Decoys/DeleteDecoy?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDecoy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDecoy(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDecoy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    exportToExcel(input: GetAllDecoysInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Decoys/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param selectedCountries (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(selectedCountries: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectedCountries);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(<any>response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringOutput>(<any>null);
    }
}

@Injectable()
export class DivisionBrokersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetDivisionBrokerForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DivisionBrokers/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDivisionBrokerForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDivisionBrokerForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDivisionBrokerForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetDivisionBrokerForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDivisionBrokerForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDivisionBrokerForEdit(id: number | null | undefined): Observable<GetDivisionBrokerForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DivisionBrokers/GetDivisionBrokerForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDivisionBrokerForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDivisionBrokerForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDivisionBrokerForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDivisionBrokerForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDivisionBrokerForEdit(response: HttpResponseBase): Observable<GetDivisionBrokerForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDivisionBrokerForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDivisionBrokerForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditDivisionBrokerDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DivisionBrokers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DivisionBrokers/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DivisionMailersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param isActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDivisionMailerList(filter: string | null | undefined, isActive: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetDivisionMailerForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DivisionMailers/GetAllDivisionMailerList?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDivisionMailerList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDivisionMailerList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDivisionMailerForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDivisionMailerForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDivisionMailerList(response: HttpResponseBase): Observable<PagedResultDtoOfGetDivisionMailerForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetDivisionMailerForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDivisionMailerForViewDto>(<any>null);
    }

    /**
     * @param divisionMailerId (optional) 
     * @return Success
     */
    getDivisionMailerForEdit(divisionMailerId: number | null | undefined): Observable<CreateOrEditDivisionMailerDto> {
        let url_ = this.baseUrl + "/api/services/app/DivisionMailers/GetDivisionMailerForEdit?";
        if (divisionMailerId !== undefined)
            url_ += "DivisionMailerId=" + encodeURIComponent("" + divisionMailerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDivisionMailerForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDivisionMailerForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditDivisionMailerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditDivisionMailerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDivisionMailerForEdit(response: HttpResponseBase): Observable<CreateOrEditDivisionMailerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditDivisionMailerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditDivisionMailerDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEditDivisionMailer(input: CreateOrEditDivisionMailerDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DivisionMailers/CreateOrEditDivisionMailer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditDivisionMailer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditDivisionMailer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditDivisionMailer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filters (optional) 
     * @return Success
     */
    divisionMailerExcel(filters: GetAllDivisionMailersInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DivisionMailers/DivisionMailerExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDivisionMailerExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDivisionMailerExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDivisionMailerExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class DivisionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDivisionDropdownsForUser(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Divisions/GetDivisionDropdownsForUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDivisionDropdownsForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDivisionDropdownsForUser(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDivisionDropdownsForUser(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }
}

@Injectable()
export class DivisionShipTosServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param iIsActiveFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDivisionalShipTo(filter: string | null | undefined, iIsActiveFilter: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetDivisionShipToForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DivisionShipTos/GetAllDivisionalShipTo?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (iIsActiveFilter !== undefined)
            url_ += "iIsActiveFilter=" + encodeURIComponent("" + iIsActiveFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDivisionalShipTo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDivisionalShipTo(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDivisionShipToForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDivisionShipToForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDivisionalShipTo(response: HttpResponseBase): Observable<PagedResultDtoOfGetDivisionShipToForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetDivisionShipToForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDivisionShipToForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDivisionShipToForEdit(id: number | null | undefined): Observable<CreateOrEditDivisionShipToDto> {
        let url_ = this.baseUrl + "/api/services/app/DivisionShipTos/GetDivisionShipToForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDivisionShipToForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDivisionShipToForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditDivisionShipToDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditDivisionShipToDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDivisionShipToForEdit(response: HttpResponseBase): Observable<CreateOrEditDivisionShipToDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditDivisionShipToDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditDivisionShipToDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditDivisionShipToDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DivisionShipTos/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfEditionListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createEdition(input: CreateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateEdition(input: UpdateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(input: MoveTenantsToAnotherEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | null | undefined, onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class ExportLayoutDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param exportLayoutcDescriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, exportLayoutcDescriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetExportLayoutDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayoutDetails/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (exportLayoutcDescriptionFilter !== undefined)
            url_ += "ExportLayoutcDescriptionFilter=" + encodeURIComponent("" + exportLayoutcDescriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetExportLayoutDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetExportLayoutDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetExportLayoutDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetExportLayoutDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetExportLayoutDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getExportLayoutDetailForEdit(id: number | null | undefined): Observable<GetExportLayoutDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayoutDetails/GetExportLayoutDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExportLayoutDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExportLayoutDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetExportLayoutDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetExportLayoutDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetExportLayoutDetailForEdit(response: HttpResponseBase): Observable<GetExportLayoutDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExportLayoutDetailForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExportLayoutDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditExportLayoutDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayoutDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayoutDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllExportLayoutForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfExportLayoutDetailExportLayoutLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayoutDetails/GetAllExportLayoutForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExportLayoutForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExportLayoutForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfExportLayoutDetailExportLayoutLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfExportLayoutDetailExportLayoutLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllExportLayoutForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfExportLayoutDetailExportLayoutLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExportLayoutDetailExportLayoutLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfExportLayoutDetailExportLayoutLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ExportLayoutsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOutputCaseDropDownValues(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/GetOutputCaseDropDownValues";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOutputCaseDropDownValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOutputCaseDropDownValues(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOutputCaseDropDownValues(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param maintenanceBuildId (optional) 
     * @param isCampaign (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    getTableDescriptionDropDownValues(campaignId: number | null | undefined, maintenanceBuildId: number | null | undefined, isCampaign: boolean | null | undefined, databaseId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/GetTableDescriptionDropDownValues?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (maintenanceBuildId !== undefined)
            url_ += "maintenanceBuildId=" + encodeURIComponent("" + maintenanceBuildId) + "&"; 
        if (isCampaign !== undefined)
            url_ += "isCampaign=" + encodeURIComponent("" + isCampaign) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTableDescriptionDropDownValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTableDescriptionDropDownValues(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTableDescriptionDropDownValues(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param tableId (optional) 
     * @param campaignId (optional) 
     * @param isCampaign (optional) 
     * @param exportLayoutId (optional) 
     * @param maintainanceBuildId (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    getExportLayoutAddField(tableId: number | null | undefined, campaignId: number | null | undefined, isCampaign: boolean | null | undefined, exportLayoutId: number | null | undefined, maintainanceBuildId: number | null | undefined, databaseId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/GetExportLayoutAddField?";
        if (tableId !== undefined)
            url_ += "tableId=" + encodeURIComponent("" + tableId) + "&"; 
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (isCampaign !== undefined)
            url_ += "isCampaign=" + encodeURIComponent("" + isCampaign) + "&"; 
        if (exportLayoutId !== undefined)
            url_ += "exportLayoutId=" + encodeURIComponent("" + exportLayoutId) + "&"; 
        if (maintainanceBuildId !== undefined)
            url_ += "maintainanceBuildId=" + encodeURIComponent("" + maintainanceBuildId) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExportLayoutAddField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExportLayoutAddField(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExportLayoutAddField(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param databaseID (optional) 
     * @return Success
     */
    getCampaignRecordForCampaignId(campaignId: number | null | undefined, databaseID: number | null | undefined): Observable<Campaign> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/GetCampaignRecordForCampaignId?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (databaseID !== undefined)
            url_ += "databaseID=" + encodeURIComponent("" + databaseID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCampaignRecordForCampaignId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCampaignRecordForCampaignId(<any>response_);
                } catch (e) {
                    return <Observable<Campaign>><any>_observableThrow(e);
                }
            } else
                return <Observable<Campaign>><any>_observableThrow(response_);
        }));
    }

    protected processGetCampaignRecordForCampaignId(response: HttpResponseBase): Observable<Campaign> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Campaign.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Campaign>(<any>null);
    }

    /**
     * @param camapignId (optional) 
     * @param outputCase (optional) 
     * @param campaignStatus (optional) 
     * @return Success
     */
    saveLayoutOutputCase(camapignId: number | null | undefined, outputCase: string | null | undefined, campaignStatus: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/SaveLayoutOutputCase?";
        if (camapignId !== undefined)
            url_ += "camapignId=" + encodeURIComponent("" + camapignId) + "&"; 
        if (outputCase !== undefined)
            url_ += "outputCase=" + encodeURIComponent("" + outputCase) + "&"; 
        if (campaignStatus !== undefined)
            url_ += "campaignStatus=" + encodeURIComponent("" + campaignStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveLayoutOutputCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveLayoutOutputCase(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveLayoutOutputCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedFields (optional) 
     * @param tableId (optional) 
     * @param campaignId (optional) 
     * @param maintainanceBuildId (optional) 
     * @param isCampaign (optional) 
     * @param exportLayoutId (optional) 
     * @param databaseId (optional) 
     * @param campaignStatus (optional) 
     * @return Success
     */
    addNewSelectedFields(selectedFields: string | null | undefined, tableId: number | null | undefined, campaignId: number | null | undefined, maintainanceBuildId: number | null | undefined, isCampaign: boolean | null | undefined, exportLayoutId: number | null | undefined, databaseId: number | null | undefined, campaignStatus: number | null | undefined): Observable<GetExportLayoutSelectedFieldsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/AddNewSelectedFields?";
        if (selectedFields !== undefined)
            url_ += "selectedFields=" + encodeURIComponent("" + selectedFields) + "&"; 
        if (tableId !== undefined)
            url_ += "tableId=" + encodeURIComponent("" + tableId) + "&"; 
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (maintainanceBuildId !== undefined)
            url_ += "maintainanceBuildId=" + encodeURIComponent("" + maintainanceBuildId) + "&"; 
        if (isCampaign !== undefined)
            url_ += "isCampaign=" + encodeURIComponent("" + isCampaign) + "&"; 
        if (exportLayoutId !== undefined)
            url_ += "exportLayoutId=" + encodeURIComponent("" + exportLayoutId) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (campaignStatus !== undefined)
            url_ += "campaignStatus=" + encodeURIComponent("" + campaignStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewSelectedFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewSelectedFields(<any>response_);
                } catch (e) {
                    return <Observable<GetExportLayoutSelectedFieldsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetExportLayoutSelectedFieldsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processAddNewSelectedFields(response: HttpResponseBase): Observable<GetExportLayoutSelectedFieldsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetExportLayoutSelectedFieldsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExportLayoutSelectedFieldsDto[]>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param isCampaign (optional) 
     * @param exportLayoutId (optional) 
     * @return Success
     */
    updateOrdersAfterDeletion(campaignId: number | null | undefined, isCampaign: boolean | null | undefined, exportLayoutId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/UpdateOrdersAfterDeletion?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (isCampaign !== undefined)
            url_ += "isCampaign=" + encodeURIComponent("" + isCampaign) + "&"; 
        if (exportLayoutId !== undefined)
            url_ += "exportLayoutId=" + encodeURIComponent("" + exportLayoutId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrdersAfterDeletion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrdersAfterDeletion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrdersAfterDeletion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @param campaignId (optional) 
     * @param isCampaign (optional) 
     * @param exportLayoutId (optional) 
     * @param campaignStatus (optional) 
     * @return Success
     */
    deleteExportLayoutRecord(ids: number[] | null | undefined, campaignId: number | null | undefined, isCampaign: boolean | null | undefined, exportLayoutId: number | null | undefined, campaignStatus: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/DeleteExportLayoutRecord?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (isCampaign !== undefined)
            url_ += "isCampaign=" + encodeURIComponent("" + isCampaign) + "&"; 
        if (exportLayoutId !== undefined)
            url_ += "exportLayoutId=" + encodeURIComponent("" + exportLayoutId) + "&"; 
        if (campaignStatus !== undefined)
            url_ += "campaignStatus=" + encodeURIComponent("" + campaignStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteExportLayoutRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteExportLayoutRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteExportLayoutRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param record (optional) 
     * @param isCampaign (optional) 
     * @param campaignId (optional) 
     * @param campaignStatus (optional) 
     * @param maintainanceBuildId (optional) 
     * @param databaseId (optional) 
     * @param tableId (optional) 
     * @return Success
     */
    updateExportLayoutRecords(record: GetExportLayoutSelectedFieldsDto | null | undefined, isCampaign: boolean | null | undefined, campaignId: number | null | undefined, campaignStatus: number | null | undefined, maintainanceBuildId: number | null | undefined, databaseId: number | null | undefined, tableId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/UpdateExportLayoutRecords?";
        if (isCampaign !== undefined)
            url_ += "isCampaign=" + encodeURIComponent("" + isCampaign) + "&"; 
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (campaignStatus !== undefined)
            url_ += "campaignStatus=" + encodeURIComponent("" + campaignStatus) + "&"; 
        if (maintainanceBuildId !== undefined)
            url_ += "maintainanceBuildId=" + encodeURIComponent("" + maintainanceBuildId) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (tableId !== undefined)
            url_ += "tableId=" + encodeURIComponent("" + tableId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(record);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateExportLayoutRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateExportLayoutRecords(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateExportLayoutRecords(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param exportLayout (optional) 
     * @return Success
     */
    checkForFixedAndCuStomFields(exportLayout: GetExportLayoutSelectedFieldsDto[] | null | undefined): Observable<GetExportLayoutSelectedFieldsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/CheckForFixedAndCuStomFields";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(exportLayout);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckForFixedAndCuStomFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckForFixedAndCuStomFields(<any>response_);
                } catch (e) {
                    return <Observable<GetExportLayoutSelectedFieldsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetExportLayoutSelectedFieldsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCheckForFixedAndCuStomFields(response: HttpResponseBase): Observable<GetExportLayoutSelectedFieldsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetExportLayoutSelectedFieldsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExportLayoutSelectedFieldsDto[]>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param isCampaign (optional) 
     * @param exportLayoutId (optional) 
     * @param maintainanceBuildId (optional) 
     * @return Success
     */
    getExportLayoutSelectedFields(campaignId: number | null | undefined, isCampaign: boolean | null | undefined, exportLayoutId: number | null | undefined, maintainanceBuildId: number | null | undefined): Observable<GetExportLayoutSelectedFieldsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/GetExportLayoutSelectedFields?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (isCampaign !== undefined)
            url_ += "isCampaign=" + encodeURIComponent("" + isCampaign) + "&"; 
        if (exportLayoutId !== undefined)
            url_ += "exportLayoutId=" + encodeURIComponent("" + exportLayoutId) + "&"; 
        if (maintainanceBuildId !== undefined)
            url_ += "maintainanceBuildId=" + encodeURIComponent("" + maintainanceBuildId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExportLayoutSelectedFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExportLayoutSelectedFields(<any>response_);
                } catch (e) {
                    return <Observable<GetExportLayoutSelectedFieldsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetExportLayoutSelectedFieldsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExportLayoutSelectedFields(response: HttpResponseBase): Observable<GetExportLayoutSelectedFieldsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetExportLayoutSelectedFieldsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExportLayoutSelectedFieldsDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param orderId (optional) 
     * @param campaignId (optional) 
     * @param isCampaign (optional) 
     * @return Success
     */
    reorderExportLayoutOrderId(id: number | null | undefined, orderId: number | null | undefined, campaignId: number | null | undefined, isCampaign: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/ReorderExportLayoutOrderId?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (isCampaign !== undefined)
            url_ += "isCampaign=" + encodeURIComponent("" + isCampaign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReorderExportLayoutOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReorderExportLayoutOrderId(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReorderExportLayoutOrderId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param outputCase (optional) 
     * @param fieldDescription (optional) 
     * @param databaseId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllExportLayoutsList(outputCase: string | null | undefined, fieldDescription: string | null | undefined, databaseId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetExportLayoutForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/GetAllExportLayoutsList?";
        if (outputCase !== undefined)
            url_ += "outputCase=" + encodeURIComponent("" + outputCase) + "&"; 
        if (fieldDescription !== undefined)
            url_ += "fieldDescription=" + encodeURIComponent("" + fieldDescription) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExportLayoutsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExportLayoutsList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetExportLayoutForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetExportLayoutForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllExportLayoutsList(response: HttpResponseBase): Observable<PagedResultDtoOfGetExportLayoutForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetExportLayoutForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetExportLayoutForViewDto>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    getGroupNames(databaseId: number | null | undefined, isActive: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/GetGroupNames?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupNames(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupNames(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param iExportLOID (optional) 
     * @return Success
     */
    getExportLayoutFields(iExportLOID: number | null | undefined): Observable<ExportLayoutFieldsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/GetExportLayoutFields?";
        if (iExportLOID !== undefined)
            url_ += "iExportLOID=" + encodeURIComponent("" + iExportLOID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExportLayoutFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExportLayoutFields(<any>response_);
                } catch (e) {
                    return <Observable<ExportLayoutFieldsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExportLayoutFieldsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExportLayoutFields(response: HttpResponseBase): Observable<ExportLayoutFieldsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExportLayoutFieldsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExportLayoutFieldsDto[]>(<any>null);
    }

    /**
     * @param record (optional) 
     * @return Success
     */
    addExportLayoutRecord(record: CreateOrEditExportLayoutDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/AddExportLayoutRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(record);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddExportLayoutRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddExportLayoutRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddExportLayoutRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param record (optional) 
     * @return Success
     */
    updateMaitainanceExportLayoutRecords(record: GetExportLayoutForViewDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/UpdateMaitainanceExportLayoutRecords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(record);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMaitainanceExportLayoutRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMaitainanceExportLayoutRecords(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMaitainanceExportLayoutRecords(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteMaintainanceExportLayoutRecord(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/DeleteMaintainanceExportLayoutRecord?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMaintainanceExportLayoutRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMaintainanceExportLayoutRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMaintainanceExportLayoutRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param record (optional) 
     * @return Success
     */
    copyExportLayout(record: GetExportLayoutForViewDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/CopyExportLayout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(record);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyExportLayout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyExportLayout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCopyExportLayout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @return Success
     */
    getBuildsByDatabase(databaseId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/GetBuildsByDatabase?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildsByDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildsByDatabase(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildsByDatabase(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param exportLayoutId (optional) 
     * @param databaseId (optional) 
     * @param buildId (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    downloadExportLayoutExcel(exportLayoutId: number | null | undefined, databaseId: number | null | undefined, buildId: number | null | undefined, isActive: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/DownloadExportLayoutExcel?";
        if (exportLayoutId !== undefined)
            url_ += "exportLayoutId=" + encodeURIComponent("" + exportLayoutId) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (buildId !== undefined)
            url_ += "buildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadExportLayoutExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadExportLayoutExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadExportLayoutExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @param groupId (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getAllExportLayout(databaseId: number | null | undefined, groupId: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfGetCopyAllExportLayoutForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/GetAllExportLayout?";
        if (databaseId !== undefined)
            url_ += "DatabaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (groupId !== undefined)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExportLayout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExportLayout(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCopyAllExportLayoutForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCopyAllExportLayoutForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllExportLayout(response: HttpResponseBase): Observable<PagedResultDtoOfGetCopyAllExportLayoutForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCopyAllExportLayoutForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCopyAllExportLayoutForViewDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    copyAllExportLayout(input: CopyAllExportLayoutDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/CopyAllExportLayout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyAllExportLayout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyAllExportLayout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCopyAllExportLayout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param layoutId (optional) 
     * @return Success
     */
    getFieldsCounts(layoutId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/GetFieldsCounts?";
        if (layoutId !== undefined)
            url_ += "layoutId=" + encodeURIComponent("" + layoutId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFieldsCounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFieldsCounts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetFieldsCounts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @return Success
     */
    getTemplatePath(databaseId: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/GetTemplatePath?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplatePath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplatePath(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTemplatePath(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param maintainanceBuildId (optional) 
     * @param campaignId (optional) 
     * @param isCampaign (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    importLayout(input: ImportLayoutDto | null | undefined, maintainanceBuildId: number | null | undefined, campaignId: number | null | undefined, isCampaign: boolean | null | undefined, databaseId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/ImportLayout?";
        if (maintainanceBuildId !== undefined)
            url_ += "maintainanceBuildId=" + encodeURIComponent("" + maintainanceBuildId) + "&"; 
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (isCampaign !== undefined)
            url_ += "isCampaign=" + encodeURIComponent("" + isCampaign) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportLayout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportLayout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processImportLayout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param maintainanceBuildId (optional) 
     * @param campaignId (optional) 
     * @param isCampaign (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    validateFile(input: ImportLayoutDto | null | undefined, maintainanceBuildId: number | null | undefined, campaignId: number | null | undefined, isCampaign: boolean | null | undefined, databaseId: number | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/services/app/ExportLayouts/ValidateFile?";
        if (maintainanceBuildId !== undefined)
            url_ += "maintainanceBuildId=" + encodeURIComponent("" + maintainanceBuildId) + "&"; 
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (isCampaign !== undefined)
            url_ += "isCampaign=" + encodeURIComponent("" + isCampaign) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateFile(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processValidateFile(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class ExternalBuildTableDatabasesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param exporttoexcel (optional) 
     * @return Success
     */
    getAllLinks(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, exporttoexcel: boolean | null | undefined): Observable<PagedResultDtoOfExternalBuildTableDatabaseForAllDto> {
        let url_ = this.baseUrl + "/api/services/app/ExternalBuildTableDatabases/GetAllLinks?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (exporttoexcel !== undefined)
            url_ += "exporttoexcel=" + encodeURIComponent("" + exporttoexcel) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLinks(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfExternalBuildTableDatabaseForAllDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfExternalBuildTableDatabaseForAllDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLinks(response: HttpResponseBase): Observable<PagedResultDtoOfExternalBuildTableDatabaseForAllDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExternalBuildTableDatabaseForAllDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfExternalBuildTableDatabaseForAllDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllBuildTableDescForDropdown(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ExternalBuildTableDatabases/GetAllBuildTableDescForDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBuildTableDescForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBuildTableDescForDropdown(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBuildTableDescForDropdown(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | null | undefined): Observable<ExternalBuildTableDatabase> {
        let url_ = this.baseUrl + "/api/services/app/ExternalBuildTableDatabases/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ExternalBuildTableDatabase>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalBuildTableDatabase>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ExternalBuildTableDatabase> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalBuildTableDatabase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalBuildTableDatabase>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRecord(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExternalBuildTableDatabases/deleteRecord?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param exporttoexcel (optional) 
     * @return Success
     */
    exportAllExternalDbLinksToExcel(input: GetAllForLookupTableInput | null | undefined, exporttoexcel: boolean | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ExternalBuildTableDatabases/ExportAllExternalDbLinksToExcel?";
        if (exporttoexcel !== undefined)
            url_ += "exporttoexcel=" + encodeURIComponent("" + exporttoexcel) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportAllExternalDbLinksToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportAllExternalDbLinksToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportAllExternalDbLinksToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditExternalBuildTableDatabaseDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExternalBuildTableDatabases/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createFriendshipRequest(input: CreateFriendshipRequestInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    blockUser(input: BlockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unblockUser(input: UnblockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    acceptFriendshipRequest(input: AcceptFriendshipRequestInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GroupBrokersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param groupId (optional) 
     * @param databaseId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllGroupBroker(filter: string | null | undefined, groupId: number | null | undefined, databaseId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGroupBrokerDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupBrokers/GetAllGroupBroker?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (groupId !== undefined)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&"; 
        if (databaseId !== undefined)
            url_ += "DatabaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGroupBroker(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGroupBroker(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGroupBrokerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGroupBrokerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGroupBroker(response: HttpResponseBase): Observable<PagedResultDtoOfGroupBrokerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGroupBrokerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGroupBrokerDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param groupId (optional) 
     * @param databaseId (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getAllBroker(filter: string | null | undefined, groupId: number | null | undefined, databaseId: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfGroupBrokerDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupBrokers/GetAllBroker?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (groupId !== undefined)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&"; 
        if (databaseId !== undefined)
            url_ += "DatabaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBroker(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBroker(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGroupBrokerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGroupBrokerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBroker(response: HttpResponseBase): Observable<PagedResultDtoOfGroupBrokerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGroupBrokerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGroupBrokerDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addSelectedBroker(input: AddBrokerForGroupDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GroupBrokers/AddSelectedBroker";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSelectedBroker(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSelectedBroker(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddSelectedBroker(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<HostDashboardData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetDashboardStatisticsData?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStatisticsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStatisticsData(<any>response_);
                } catch (e) {
                    return <Observable<HostDashboardData>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostDashboardData>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardStatisticsData(response: HttpResponseBase): Observable<HostDashboardData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostDashboardData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostDashboardData>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncomeStatisticsDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionTenantStatisticsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: HostSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class IDMSConfigurationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllConfiguration(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAllConfigurationsForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/IDMSConfigurations/GetAllConfiguration?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAllConfigurationsForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAllConfigurationsForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllConfiguration(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllConfigurationsForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllConfigurationsForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAllConfigurationsForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getConfigurationForEdit(id: number | null | undefined): Observable<CreateOrEditConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/IDMSConfigurations/GetConfigurationForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigurationForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigurationForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigurationForEdit(response: HttpResponseBase): Observable<CreateOrEditConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditConfigurationDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEditIDMSConfig(input: CreateOrEditConfigurationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IDMSConfigurations/CreateOrEditIDMSConfig";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditIDMSConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditIDMSConfig(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditIDMSConfig(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfigurationItems(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IDMSConfigurations/GetConfigurationItems";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigurationItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigurationItems(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigurationItems(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param cItem (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    getConfigurationValue(cItem: string | null | undefined, databaseId: number | null | undefined): Observable<IDMSConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/IDMSConfigurations/GetConfigurationValue?";
        if (cItem !== undefined)
            url_ += "cItem=" + encodeURIComponent("" + cItem) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigurationValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigurationValue(<any>response_);
                } catch (e) {
                    return <Observable<IDMSConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDMSConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigurationValue(response: HttpResponseBase): Observable<IDMSConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IDMSConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDMSConfigurationDto>(<any>null);
    }

    /**
     * @param cItem (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    getMultipleConfigurationsValue(cItem: string[] | null | undefined, databaseId: number | null | undefined): Observable<IDMSConfigurationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IDMSConfigurations/GetMultipleConfigurationsValue?";
        if (cItem !== undefined)
            cItem && cItem.forEach(item => { url_ += "cItem=" + encodeURIComponent("" + item) + "&"; });
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMultipleConfigurationsValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMultipleConfigurationsValue(<any>response_);
                } catch (e) {
                    return <Observable<IDMSConfigurationDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IDMSConfigurationDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMultipleConfigurationsValue(response: HttpResponseBase): Observable<IDMSConfigurationDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IDMSConfigurationDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IDMSConfigurationDto[]>(<any>null);
    }
}

@Injectable()
export class IDMSTasksServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getAllTask(filter: string | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfGetIDMSTaskForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/GetAllTask?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTask(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetIDMSTaskForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetIDMSTaskForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTask(response: HttpResponseBase): Observable<PagedResultDtoOfGetIDMSTaskForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetIDMSTaskForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetIDMSTaskForViewDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setValidEmailFlag(input: SetValidEmailFlagDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/SetValidEmailFlag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetValidEmailFlag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetValidEmailFlag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetValidEmailFlag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    aOPFrompreviousbuild(input: AOPFromPreviousBuildDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/AOPFrompreviousbuild";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAOPFrompreviousbuild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAOPFrompreviousbuild(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAOPFrompreviousbuild(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    loadMailerUsage(input: LoadMailerUsageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/LoadMailerUsage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadMailerUsage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadMailerUsage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLoadMailerUsage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    enhancedAuditReport(input: EnhancedAuditReportDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/EnhancedAuditReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnhancedAuditReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnhancedAuditReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEnhancedAuditReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    exportListConversionData(input: ExportListConversionDataDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/ExportListConversionData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportListConversionData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportListConversionData(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processExportListConversionData(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    apogeeCustomExportTask(input: ApogeeCustomExportTaskDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/ApogeeCustomExportTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApogeeCustomExportTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApogeeCustomExportTask(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApogeeCustomExportTask(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    apogeeExportPointInTimeTask(input: ApogeeExportPointInTimeTaskDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/ApogeeExportPointInTimeTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApogeeExportPointInTimeTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApogeeExportPointInTimeTask(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApogeeExportPointInTimeTask(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getFilePathOfApogeePIT(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/getFilePathOfApogeePIT";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilePathOfApogeePIT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilePathOfApogeePIT(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetFilePathOfApogeePIT(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    searchPreviousOrderHistorybyKeyTask(input: SearchPreviousOrderHistorybyKeyTaskDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/SearchPreviousOrderHistorybyKeyTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchPreviousOrderHistorybyKeyTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchPreviousOrderHistorybyKeyTask(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSearchPreviousOrderHistorybyKeyTask(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    copyBuild(input: CopyBuildDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/CopyBuild";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyBuild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyBuild(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCopyBuild(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    optoutHardbounceTask(input: OptoutHardbounceTaskDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/OptoutHardbounceTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptoutHardbounceTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptoutHardbounceTask(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processOptoutHardbounceTask(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getFilePathOfOptoutHardbounce(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/getFilePathOfOptoutHardbounce";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilePathOfOptoutHardbounce(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilePathOfOptoutHardbounce(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetFilePathOfOptoutHardbounce(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    exportEmailHygieneData(input: ExportEmailHygieneDataDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/ExportEmailHygieneData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportEmailHygieneData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportEmailHygieneData(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processExportEmailHygieneData(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    importEmailHygieneData(input: ImportEmailHygieneDataDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/ImportEmailHygieneData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportEmailHygieneData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportEmailHygieneData(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processImportEmailHygieneData(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param databaseID (optional) 
     * @return Success
     */
    getImportEmailHygieneLoadPath(databaseID: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/GetImportEmailHygieneLoadPath?";
        if (databaseID !== undefined)
            url_ += "databaseID=" + encodeURIComponent("" + databaseID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImportEmailHygieneLoadPath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImportEmailHygieneLoadPath(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetImportEmailHygieneLoadPath(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    activateLinkTableBuild(input: ActivateLinkTableBuildDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/ActivateLinkTableBuild";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateLinkTableBuild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateLinkTableBuild(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processActivateLinkTableBuild(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTableDescriptionForBuild(): Observable<GetAllTableDescriptionFromBuild> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/GetAllTableDescriptionForBuild";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTableDescriptionForBuild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTableDescriptionForBuild(<any>response_);
                } catch (e) {
                    return <Observable<GetAllTableDescriptionFromBuild>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllTableDescriptionFromBuild>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTableDescriptionForBuild(response: HttpResponseBase): Observable<GetAllTableDescriptionFromBuild> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllTableDescriptionFromBuild.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllTableDescriptionFromBuild>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    closeNotificationJob(input: TaskGeneralDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/CloseNotificationJob";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCloseNotificationJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCloseNotificationJob(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCloseNotificationJob(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    buildDeleteTask(input: TaskGeneralDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/BuildDeleteTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuildDeleteTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuildDeleteTask(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processBuildDeleteTask(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    bulkUpdateListAction(input: BulkUpdateListActionDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/BulkUpdateListAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkUpdateListAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkUpdateListAction(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processBulkUpdateListAction(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param buildID (optional) 
     * @return Success
     */
    getAllExportFlagFieldForBuild(buildID: number | null | undefined): Observable<GetAllExportFlagFieldForBuildDto> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/GetAllExportFlagFieldForBuild?";
        if (buildID !== undefined)
            url_ += "BuildID=" + encodeURIComponent("" + buildID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExportFlagFieldForBuild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExportFlagFieldForBuild(<any>response_);
                } catch (e) {
                    return <Observable<GetAllExportFlagFieldForBuildDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllExportFlagFieldForBuildDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllExportFlagFieldForBuild(response: HttpResponseBase): Observable<GetAllExportFlagFieldForBuildDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllExportFlagFieldForBuildDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllExportFlagFieldForBuildDto>(<any>null);
    }

    /**
     * @return Success
     */
    getServerDate(): Observable<GetServerDateTime> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/GetServerDate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServerDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServerDate(<any>response_);
                } catch (e) {
                    return <Observable<GetServerDateTime>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetServerDateTime>><any>_observableThrow(response_);
        }));
    }

    protected processGetServerDate(response: HttpResponseBase): Observable<GetServerDateTime> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetServerDateTime.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetServerDateTime>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    saveModelPivotReport(input: ModelPivotReportDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IDMSTasks/SaveModelPivotReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveModelPivotReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveModelPivotReport(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSaveModelPivotReport(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class IDMSUsersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfIDMSUserDto> {
        let url_ = this.baseUrl + "/api/services/app/IDMSUsers/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIDMSUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIDMSUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfIDMSUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIDMSUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIDMSUserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTblUserForView(id: number | null | undefined): Observable<GetIDMSUserForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/IDMSUsers/GetTblUserForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTblUserForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTblUserForView(<any>response_);
                } catch (e) {
                    return <Observable<GetIDMSUserForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIDMSUserForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTblUserForView(response: HttpResponseBase): Observable<GetIDMSUserForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIDMSUserForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIDMSUserForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTblUserForEdit(id: number | null | undefined): Observable<GetIDMSUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/IDMSUsers/GetTblUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTblUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTblUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetIDMSUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIDMSUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTblUserForEdit(response: HttpResponseBase): Observable<GetIDMSUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIDMSUserForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIDMSUserForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditIDMSUserDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IDMSUsers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IDMSUsers/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class IndustryCodesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetIndustryCodeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/IndustryCodes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetIndustryCodeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetIndustryCodeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetIndustryCodeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetIndustryCodeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetIndustryCodeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getIndustryCodeForEdit(id: number | null | undefined): Observable<GetIndustryCodeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/IndustryCodes/GetIndustryCodeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndustryCodeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndustryCodeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetIndustryCodeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIndustryCodeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIndustryCodeForEdit(response: HttpResponseBase): Observable<GetIndustryCodeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIndustryCodeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIndustryCodeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditIndustryCodeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IndustryCodes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IndustryCodes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setup(input: InstallDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingsJsonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(<any>response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckDatabaseOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class IntentTopicsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllIntentTopics(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IntentTopics/GetAllIntentTopics";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIntentTopics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIntentTopics(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIntentTopics(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | null | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createInvoice(input: CreateInvoiceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguagesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateLanguage(input: CreateOrUpdateLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setDefaultLanguage(input: SetDefaultLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLanguageTextListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateLanguageText(input: UpdateLanguageTextInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ListAutomatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getServerDateForTime(): Observable<GetServerDateTime> {
        let url_ = this.baseUrl + "/api/services/app/ListAutomates/GetServerDateForTime";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServerDateForTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServerDateForTime(<any>response_);
                } catch (e) {
                    return <Observable<GetServerDateTime>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetServerDateTime>><any>_observableThrow(response_);
        }));
    }

    protected processGetServerDateForTime(response: HttpResponseBase): Observable<GetServerDateTime> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetServerDateTime.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetServerDateTime>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllListAutomate(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfIListAutomateDto> {
        let url_ = this.baseUrl + "/api/services/app/ListAutomates/GetAllListAutomate?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllListAutomate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllListAutomate(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIListAutomateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIListAutomateDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllListAutomate(response: HttpResponseBase): Observable<PagedResultDtoOfIListAutomateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIListAutomateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIListAutomateDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getIListAutomateForEdit(id: number | null | undefined): Observable<CreateOrEditIListAutomateDto> {
        let url_ = this.baseUrl + "/api/services/app/ListAutomates/GetIListAutomateForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIListAutomateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIListAutomateForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditIListAutomateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditIListAutomateDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIListAutomateForEdit(response: HttpResponseBase): Observable<CreateOrEditIListAutomateDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditIListAutomateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditIListAutomateDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditIListAutomateDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ListAutomates/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getFrequency(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ListAutomates/GetFrequency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFrequency(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFrequency(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }
}

@Injectable()
export class ListLoadStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetListLoadStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ListLoadStatuses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetListLoadStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetListLoadStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetListLoadStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetListLoadStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetListLoadStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getListLoadStatusForEdit(id: number | null | undefined): Observable<GetListLoadStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ListLoadStatuses/GetListLoadStatusForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListLoadStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListLoadStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetListLoadStatusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetListLoadStatusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetListLoadStatusForEdit(response: HttpResponseBase): Observable<GetListLoadStatusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetListLoadStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetListLoadStatusForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditListLoadStatusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ListLoadStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ListLoadStatuses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ListMailerRequestedsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxMailerIDFilter (optional) 
     * @param minMailerIDFilter (optional) 
     * @param cCreatedByFilter (optional) 
     * @param maxdCreatedDateFilter (optional) 
     * @param mindCreatedDateFilter (optional) 
     * @param cModifiedByFilter (optional) 
     * @param maxdModifiedDateFilter (optional) 
     * @param mindModifiedDateFilter (optional) 
     * @param masterLoLcListNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxMailerIDFilter: number | null | undefined, minMailerIDFilter: number | null | undefined, cCreatedByFilter: string | null | undefined, maxdCreatedDateFilter: moment.Moment | null | undefined, mindCreatedDateFilter: moment.Moment | null | undefined, cModifiedByFilter: string | null | undefined, maxdModifiedDateFilter: moment.Moment | null | undefined, mindModifiedDateFilter: moment.Moment | null | undefined, masterLoLcListNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetListMailerRequestedForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ListMailerRequesteds/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxMailerIDFilter !== undefined)
            url_ += "MaxMailerIDFilter=" + encodeURIComponent("" + maxMailerIDFilter) + "&"; 
        if (minMailerIDFilter !== undefined)
            url_ += "MinMailerIDFilter=" + encodeURIComponent("" + minMailerIDFilter) + "&"; 
        if (cCreatedByFilter !== undefined)
            url_ += "cCreatedByFilter=" + encodeURIComponent("" + cCreatedByFilter) + "&"; 
        if (maxdCreatedDateFilter !== undefined)
            url_ += "MaxdCreatedDateFilter=" + encodeURIComponent(maxdCreatedDateFilter ? "" + maxdCreatedDateFilter.toJSON() : "") + "&"; 
        if (mindCreatedDateFilter !== undefined)
            url_ += "MindCreatedDateFilter=" + encodeURIComponent(mindCreatedDateFilter ? "" + mindCreatedDateFilter.toJSON() : "") + "&"; 
        if (cModifiedByFilter !== undefined)
            url_ += "cModifiedByFilter=" + encodeURIComponent("" + cModifiedByFilter) + "&"; 
        if (maxdModifiedDateFilter !== undefined)
            url_ += "MaxdModifiedDateFilter=" + encodeURIComponent(maxdModifiedDateFilter ? "" + maxdModifiedDateFilter.toJSON() : "") + "&"; 
        if (mindModifiedDateFilter !== undefined)
            url_ += "MindModifiedDateFilter=" + encodeURIComponent(mindModifiedDateFilter ? "" + mindModifiedDateFilter.toJSON() : "") + "&"; 
        if (masterLoLcListNameFilter !== undefined)
            url_ += "MasterLoLcListNameFilter=" + encodeURIComponent("" + masterLoLcListNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetListMailerRequestedForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetListMailerRequestedForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetListMailerRequestedForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetListMailerRequestedForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetListMailerRequestedForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getListMailerRequestedForView(id: number | null | undefined): Observable<GetListMailerRequestedForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ListMailerRequesteds/GetListMailerRequestedForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListMailerRequestedForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListMailerRequestedForView(<any>response_);
                } catch (e) {
                    return <Observable<GetListMailerRequestedForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetListMailerRequestedForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetListMailerRequestedForView(response: HttpResponseBase): Observable<GetListMailerRequestedForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetListMailerRequestedForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetListMailerRequestedForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getListMailerRequestedForEdit(id: number | null | undefined): Observable<GetListMailerRequestedForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ListMailerRequesteds/GetListMailerRequestedForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListMailerRequestedForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListMailerRequestedForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetListMailerRequestedForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetListMailerRequestedForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetListMailerRequestedForEdit(response: HttpResponseBase): Observable<GetListMailerRequestedForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetListMailerRequestedForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetListMailerRequestedForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditListMailerRequestedDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ListMailerRequesteds/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ListMailerRequesteds/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxMailerIDFilter (optional) 
     * @param minMailerIDFilter (optional) 
     * @param cCreatedByFilter (optional) 
     * @param maxdCreatedDateFilter (optional) 
     * @param mindCreatedDateFilter (optional) 
     * @param cModifiedByFilter (optional) 
     * @param maxdModifiedDateFilter (optional) 
     * @param mindModifiedDateFilter (optional) 
     * @param masterLoLcListNameFilter (optional) 
     * @return Success
     */
    getListMailerRequestedsToExcel(filter: string | null | undefined, maxMailerIDFilter: number | null | undefined, minMailerIDFilter: number | null | undefined, cCreatedByFilter: string | null | undefined, maxdCreatedDateFilter: moment.Moment | null | undefined, mindCreatedDateFilter: moment.Moment | null | undefined, cModifiedByFilter: string | null | undefined, maxdModifiedDateFilter: moment.Moment | null | undefined, mindModifiedDateFilter: moment.Moment | null | undefined, masterLoLcListNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ListMailerRequesteds/GetListMailerRequestedsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxMailerIDFilter !== undefined)
            url_ += "MaxMailerIDFilter=" + encodeURIComponent("" + maxMailerIDFilter) + "&"; 
        if (minMailerIDFilter !== undefined)
            url_ += "MinMailerIDFilter=" + encodeURIComponent("" + minMailerIDFilter) + "&"; 
        if (cCreatedByFilter !== undefined)
            url_ += "cCreatedByFilter=" + encodeURIComponent("" + cCreatedByFilter) + "&"; 
        if (maxdCreatedDateFilter !== undefined)
            url_ += "MaxdCreatedDateFilter=" + encodeURIComponent(maxdCreatedDateFilter ? "" + maxdCreatedDateFilter.toJSON() : "") + "&"; 
        if (mindCreatedDateFilter !== undefined)
            url_ += "MindCreatedDateFilter=" + encodeURIComponent(mindCreatedDateFilter ? "" + mindCreatedDateFilter.toJSON() : "") + "&"; 
        if (cModifiedByFilter !== undefined)
            url_ += "cModifiedByFilter=" + encodeURIComponent("" + cModifiedByFilter) + "&"; 
        if (maxdModifiedDateFilter !== undefined)
            url_ += "MaxdModifiedDateFilter=" + encodeURIComponent(maxdModifiedDateFilter ? "" + maxdModifiedDateFilter.toJSON() : "") + "&"; 
        if (mindModifiedDateFilter !== undefined)
            url_ += "MindModifiedDateFilter=" + encodeURIComponent(mindModifiedDateFilter ? "" + mindModifiedDateFilter.toJSON() : "") + "&"; 
        if (masterLoLcListNameFilter !== undefined)
            url_ += "MasterLoLcListNameFilter=" + encodeURIComponent("" + masterLoLcListNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListMailerRequestedsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListMailerRequestedsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetListMailerRequestedsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterLoLForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfListMailerRequestedMasterLoLLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ListMailerRequesteds/GetAllMasterLoLForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterLoLForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterLoLForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfListMailerRequestedMasterLoLLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfListMailerRequestedMasterLoLLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMasterLoLForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfListMailerRequestedMasterLoLLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfListMailerRequestedMasterLoLLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfListMailerRequestedMasterLoLLookupTableDto>(<any>null);
    }
}

@Injectable()
export class ListMailersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxIDFilter (optional) 
     * @param minIDFilter (optional) 
     * @param maxMailerIDFilter (optional) 
     * @param minMailerIDFilter (optional) 
     * @param maxdCreatedDateFilter (optional) 
     * @param mindCreatedDateFilter (optional) 
     * @param cCreatedByFilter (optional) 
     * @param cModifiedByFilter (optional) 
     * @param maxdModifiedDateFilter (optional) 
     * @param mindModifiedDateFilter (optional) 
     * @param masterLoLcListNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxIDFilter: number | null | undefined, minIDFilter: number | null | undefined, maxMailerIDFilter: number | null | undefined, minMailerIDFilter: number | null | undefined, maxdCreatedDateFilter: moment.Moment | null | undefined, mindCreatedDateFilter: moment.Moment | null | undefined, cCreatedByFilter: string | null | undefined, cModifiedByFilter: string | null | undefined, maxdModifiedDateFilter: moment.Moment | null | undefined, mindModifiedDateFilter: moment.Moment | null | undefined, masterLoLcListNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetListMailerForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ListMailers/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxIDFilter !== undefined)
            url_ += "MaxIDFilter=" + encodeURIComponent("" + maxIDFilter) + "&"; 
        if (minIDFilter !== undefined)
            url_ += "MinIDFilter=" + encodeURIComponent("" + minIDFilter) + "&"; 
        if (maxMailerIDFilter !== undefined)
            url_ += "MaxMailerIDFilter=" + encodeURIComponent("" + maxMailerIDFilter) + "&"; 
        if (minMailerIDFilter !== undefined)
            url_ += "MinMailerIDFilter=" + encodeURIComponent("" + minMailerIDFilter) + "&"; 
        if (maxdCreatedDateFilter !== undefined)
            url_ += "MaxdCreatedDateFilter=" + encodeURIComponent(maxdCreatedDateFilter ? "" + maxdCreatedDateFilter.toJSON() : "") + "&"; 
        if (mindCreatedDateFilter !== undefined)
            url_ += "MindCreatedDateFilter=" + encodeURIComponent(mindCreatedDateFilter ? "" + mindCreatedDateFilter.toJSON() : "") + "&"; 
        if (cCreatedByFilter !== undefined)
            url_ += "cCreatedByFilter=" + encodeURIComponent("" + cCreatedByFilter) + "&"; 
        if (cModifiedByFilter !== undefined)
            url_ += "cModifiedByFilter=" + encodeURIComponent("" + cModifiedByFilter) + "&"; 
        if (maxdModifiedDateFilter !== undefined)
            url_ += "MaxdModifiedDateFilter=" + encodeURIComponent(maxdModifiedDateFilter ? "" + maxdModifiedDateFilter.toJSON() : "") + "&"; 
        if (mindModifiedDateFilter !== undefined)
            url_ += "MindModifiedDateFilter=" + encodeURIComponent(mindModifiedDateFilter ? "" + mindModifiedDateFilter.toJSON() : "") + "&"; 
        if (masterLoLcListNameFilter !== undefined)
            url_ += "MasterLoLcListNameFilter=" + encodeURIComponent("" + masterLoLcListNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetListMailerForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetListMailerForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetListMailerForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetListMailerForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetListMailerForViewDto>(<any>null);
    }
}

@Injectable()
export class LoadProcessStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetLoadProcessStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/LoadProcessStatuses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetLoadProcessStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetLoadProcessStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetLoadProcessStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetLoadProcessStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetLoadProcessStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLoadProcessStatusForEdit(id: number | null | undefined): Observable<GetLoadProcessStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/LoadProcessStatuses/GetLoadProcessStatusForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoadProcessStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoadProcessStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLoadProcessStatusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLoadProcessStatusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoadProcessStatusForEdit(response: HttpResponseBase): Observable<GetLoadProcessStatusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLoadProcessStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLoadProcessStatusForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditLoadProcessStatusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LoadProcessStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LoadProcessStatuses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LookupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLookups(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLookupDto> {
        let url_ = this.baseUrl + "/api/services/app/Lookups/GetAllLookups?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLookups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLookups(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLookupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLookupDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLookups(response: HttpResponseBase): Observable<PagedResultDtoOfLookupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLookupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLookupDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLookupForEdit(id: number | null | undefined): Observable<CreateOrEditLookupDto> {
        let url_ = this.baseUrl + "/api/services/app/Lookups/GetLookupForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookupForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookupForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditLookupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditLookupDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLookupForEdit(response: HttpResponseBase): Observable<CreateOrEditLookupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditLookupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditLookupDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLookupsForDropdown(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Lookups/GetAllLookupsForDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLookupsForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLookupsForDropdown(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLookupsForDropdown(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditLookupDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Lookups/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MailersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param iIsActiveFilter (optional) 
     * @param selectedDatabase (optional) 
     * @param contactLastNameFilterText (optional) 
     * @param contactEmailFilterText (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMailers(filter: string | null | undefined, iIsActiveFilter: number | null | undefined, selectedDatabase: number | null | undefined, contactLastNameFilterText: string | null | undefined, contactEmailFilterText: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfMailerDto> {
        let url_ = this.baseUrl + "/api/services/app/Mailers/GetAllMailers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (iIsActiveFilter !== undefined)
            url_ += "iIsActiveFilter=" + encodeURIComponent("" + iIsActiveFilter) + "&"; 
        if (selectedDatabase !== undefined)
            url_ += "SelectedDatabase=" + encodeURIComponent("" + selectedDatabase) + "&"; 
        if (contactLastNameFilterText !== undefined)
            url_ += "ContactLastNameFilterText=" + encodeURIComponent("" + contactLastNameFilterText) + "&"; 
        if (contactEmailFilterText !== undefined)
            url_ += "ContactEmailFilterText=" + encodeURIComponent("" + contactEmailFilterText) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMailers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMailers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMailerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMailerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMailers(response: HttpResponseBase): Observable<PagedResultDtoOfMailerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMailerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMailerDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMailerForEdit(id: number | null | undefined): Observable<CreateOrEditMailerDto> {
        let url_ = this.baseUrl + "/api/services/app/Mailers/GetMailerForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailerForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailerForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditMailerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditMailerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMailerForEdit(response: HttpResponseBase): Observable<CreateOrEditMailerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditMailerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditMailerDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditMailerDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Mailers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    exportAllMailerToExcel(input: GetAllSetupInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Mailers/ExportAllMailerToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportAllMailerToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportAllMailerToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportAllMailerToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    exportOffers(input: GetAllSetupInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Mailers/ExportOffers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportOffers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportOffers(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportOffers(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @return Success
     */
    getAllBrokersbyDatabaseId(databaseId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Mailers/GetAllBrokersbyDatabaseId?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBrokersbyDatabaseId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBrokersbyDatabaseId(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBrokersbyDatabaseId(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }
}

@Injectable()
export class ManagersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param iIsActiveFilter (optional) 
     * @param selectedDatabase (optional) 
     * @param contactLastNameFilterText (optional) 
     * @param contactEmailFilterText (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllManagers(filter: string | null | undefined, iIsActiveFilter: number | null | undefined, selectedDatabase: number | null | undefined, contactLastNameFilterText: string | null | undefined, contactEmailFilterText: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfManagerDto> {
        let url_ = this.baseUrl + "/api/services/app/Managers/GetAllManagers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (iIsActiveFilter !== undefined)
            url_ += "iIsActiveFilter=" + encodeURIComponent("" + iIsActiveFilter) + "&"; 
        if (selectedDatabase !== undefined)
            url_ += "SelectedDatabase=" + encodeURIComponent("" + selectedDatabase) + "&"; 
        if (contactLastNameFilterText !== undefined)
            url_ += "ContactLastNameFilterText=" + encodeURIComponent("" + contactLastNameFilterText) + "&"; 
        if (contactEmailFilterText !== undefined)
            url_ += "ContactEmailFilterText=" + encodeURIComponent("" + contactEmailFilterText) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllManagers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllManagers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfManagerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfManagerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllManagers(response: HttpResponseBase): Observable<PagedResultDtoOfManagerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfManagerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfManagerDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getManagerForEdit(id: number | null | undefined): Observable<CreateOrEditManagerDto> {
        let url_ = this.baseUrl + "/api/services/app/Managers/GetManagerForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManagerForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManagerForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditManagerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditManagerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManagerForEdit(response: HttpResponseBase): Observable<CreateOrEditManagerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditManagerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditManagerDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditManagerDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Managers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    exportManagersToExcel(input: GetAllSetupInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Managers/ExportManagersToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportManagersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportManagersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportManagersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filters (optional) 
     * @return Success
     */
    exportContactAssignmentsToExcel(filters: GetAllSetupInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Managers/ExportContactAssignmentsToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportContactAssignmentsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportContactAssignmentsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportContactAssignmentsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class MasterLoLsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param databaseID (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, databaseID: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfMasterLoLForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (databaseID !== undefined)
            url_ += "DatabaseID=" + encodeURIComponent("" + databaseID) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMasterLoLForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMasterLoLForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfMasterLoLForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMasterLoLForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMasterLoLForViewDto>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @return Success
     */
    getAllOwners(databaseId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/GetAllOwners?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOwners(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOwners(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOwners(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @return Success
     */
    getAllManagers(databaseId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/GetAllManagers?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllManagers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllManagers(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllManagers(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param ownerid (optional) 
     * @param managerid (optional) 
     * @return Success
     */
    getAllContacts(ownerid: number | null | undefined, managerid: number | null | undefined): Observable<PagedResultDtoOfContactTableDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/GetAllContacts?";
        if (ownerid !== undefined)
            url_ += "ownerid=" + encodeURIComponent("" + ownerid) + "&"; 
        if (managerid !== undefined)
            url_ += "managerid=" + encodeURIComponent("" + managerid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContacts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfContactTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfContactTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllContacts(response: HttpResponseBase): Observable<PagedResultDtoOfContactTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfContactTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfContactTableDto>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @return Success
     */
    getAllReqMailers(databaseId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/GetAllReqMailers?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllReqMailers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllReqMailers(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllReqMailers(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @return Success
     */
    getAllAvailableMailersForDropdown(databaseId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/GetAllAvailableMailersForDropdown?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAvailableMailersForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAvailableMailersForDropdown(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAvailableMailersForDropdown(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getallDropdownsfromLookup(): Observable<PagedResultDtoOfLookupForListofListDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/GetallDropdownsfromLookup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallDropdownsfromLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallDropdownsfromLookup(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLookupForListofListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLookupForListofListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetallDropdownsfromLookup(response: HttpResponseBase): Observable<PagedResultDtoOfLookupForListofListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLookupForListofListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLookupForListofListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditMasterLoLDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    getListById(id: number | null | undefined, databaseId: number | null | undefined): Observable<CreateOrEditMasterLoLDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/GetListById?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListById(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditMasterLoLDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditMasterLoLDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetListById(response: HttpResponseBase): Observable<CreateOrEditMasterLoLDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditMasterLoLDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditMasterLoLDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    fetchMailers(id: number | null | undefined): Observable<PagedResultDtoOfCreateOrEditListMailerDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/FetchMailers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchMailers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchMailers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCreateOrEditListMailerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCreateOrEditListMailerDto>><any>_observableThrow(response_);
        }));
    }

    protected processFetchMailers(response: HttpResponseBase): Observable<PagedResultDtoOfCreateOrEditListMailerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCreateOrEditListMailerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCreateOrEditListMailerDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    fetchCASContact(id: number | null | undefined): Observable<PagedResultDtoOfCreateOrEditListCASContacts> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/FetchCASContact?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchCASContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchCASContact(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCreateOrEditListCASContacts>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCreateOrEditListCASContacts>><any>_observableThrow(response_);
        }));
    }

    protected processFetchCASContact(response: HttpResponseBase): Observable<PagedResultDtoOfCreateOrEditListCASContacts> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCreateOrEditListCASContacts.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCreateOrEditListCASContacts>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    fetchReqMailers(id: number | null | undefined): Observable<PagedResultDtoOfCreateOrEditListMailerRequestedDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/FetchReqMailers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchReqMailers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchReqMailers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCreateOrEditListMailerRequestedDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCreateOrEditListMailerRequestedDto>><any>_observableThrow(response_);
        }));
    }

    protected processFetchReqMailers(response: HttpResponseBase): Observable<PagedResultDtoOfCreateOrEditListMailerRequestedDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCreateOrEditListMailerRequestedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCreateOrEditListMailerRequestedDto>(<any>null);
    }

    /**
     * @param dwapContacts (optional) 
     * @param listId (optional) 
     * @return Success
     */
    createOrEditForDwapContacts(dwapContacts: number[] | null | undefined, listId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/CreateOrEditForDwapContacts?";
        if (listId !== undefined)
            url_ += "listId=" + encodeURIComponent("" + listId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dwapContacts);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditForDwapContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditForDwapContacts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditForDwapContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param requestedByMailer (optional) 
     * @param listId (optional) 
     * @return Success
     */
    createOrEditForRequestedMailer(requestedByMailer: number[] | null | undefined, listId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/CreateOrEditForRequestedMailer?";
        if (listId !== undefined)
            url_ += "listId=" + encodeURIComponent("" + listId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestedByMailer);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditForRequestedMailer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditForRequestedMailer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditForRequestedMailer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param availableToMailer (optional) 
     * @param listId (optional) 
     * @return Success
     */
    createOrEditForAvailableMailer(availableToMailer: number[] | null | undefined, listId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/CreateOrEditForAvailableMailer?";
        if (listId !== undefined)
            url_ += "listId=" + encodeURIComponent("" + listId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(availableToMailer);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditForAvailableMailer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditForAvailableMailer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditForAvailableMailer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    validateListName(input: CreateOrEditMasterLoLDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/ValidateListName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateListName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateListName(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processValidateListName(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param selectedDatabase (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getDataExportAllMailerAccessToExcel(filter: string | null | undefined, selectedDatabase: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<ExportToExcelMasterLolDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/GetDataExportAllMailerAccessToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (selectedDatabase !== undefined)
            url_ += "SelectedDatabase=" + encodeURIComponent("" + selectedDatabase) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataExportAllMailerAccessToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataExportAllMailerAccessToExcel(<any>response_);
                } catch (e) {
                    return <Observable<ExportToExcelMasterLolDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExportToExcelMasterLolDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataExportAllMailerAccessToExcel(response: HttpResponseBase): Observable<ExportToExcelMasterLolDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExportToExcelMasterLolDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExportToExcelMasterLolDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param selectedDatabase (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getExportAllListMailerAccessToExcel(filter: string | null | undefined, selectedDatabase: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<ExportListMailerAccess[]> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/GetExportAllListMailerAccessToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (selectedDatabase !== undefined)
            url_ += "SelectedDatabase=" + encodeURIComponent("" + selectedDatabase) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExportAllListMailerAccessToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExportAllListMailerAccessToExcel(<any>response_);
                } catch (e) {
                    return <Observable<ExportListMailerAccess[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExportListMailerAccess[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExportAllListMailerAccessToExcel(response: HttpResponseBase): Observable<ExportListMailerAccess[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExportListMailerAccess.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExportListMailerAccess[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    exportAllListMailerAccessToExcel(input: GetAllForTableInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/ExportAllListMailerAccessToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportAllListMailerAccessToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportAllListMailerAccessToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportAllListMailerAccessToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    exportAllMailerAccessToExcel(input: GetAllForTableInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterLoLs/ExportAllMailerAccessToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportAllMailerAccessToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportAllMailerAccessToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportAllMailerAccessToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class MatchAppendDatabaseUsersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetMatchAppendDatabaseUserForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendDatabaseUsers/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMatchAppendDatabaseUserForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMatchAppendDatabaseUserForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMatchAppendDatabaseUserForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMatchAppendDatabaseUserForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMatchAppendDatabaseUserForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMatchAppendDatabaseUserForEdit(id: number | null | undefined): Observable<GetMatchAppendDatabaseUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendDatabaseUsers/GetMatchAppendDatabaseUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchAppendDatabaseUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchAppendDatabaseUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMatchAppendDatabaseUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMatchAppendDatabaseUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchAppendDatabaseUserForEdit(response: HttpResponseBase): Observable<GetMatchAppendDatabaseUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMatchAppendDatabaseUserForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMatchAppendDatabaseUserForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditMatchAppendDatabaseUserDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendDatabaseUsers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendDatabaseUsers/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MatchAppendInputLayoutsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param matchAppendcClientNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, matchAppendcClientNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetMatchAppendInputLayoutForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendInputLayouts/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (matchAppendcClientNameFilter !== undefined)
            url_ += "MatchAppendcClientNameFilter=" + encodeURIComponent("" + matchAppendcClientNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMatchAppendInputLayoutForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMatchAppendInputLayoutForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMatchAppendInputLayoutForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMatchAppendInputLayoutForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMatchAppendInputLayoutForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMatchAppendInputLayoutForEdit(id: number | null | undefined): Observable<GetMatchAppendInputLayoutForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendInputLayouts/GetMatchAppendInputLayoutForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchAppendInputLayoutForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchAppendInputLayoutForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMatchAppendInputLayoutForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMatchAppendInputLayoutForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchAppendInputLayoutForEdit(response: HttpResponseBase): Observable<GetMatchAppendInputLayoutForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMatchAppendInputLayoutForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMatchAppendInputLayoutForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditMatchAppendInputLayoutDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendInputLayouts/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendInputLayouts/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMatchAppendForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfMatchAppendInputLayoutMatchAppendLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendInputLayouts/GetAllMatchAppendForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMatchAppendForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMatchAppendForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMatchAppendInputLayoutMatchAppendLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMatchAppendInputLayoutMatchAppendLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMatchAppendForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMatchAppendInputLayoutMatchAppendLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMatchAppendInputLayoutMatchAppendLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMatchAppendInputLayoutMatchAppendLookupTableDto>(<any>null);
    }
}

@Injectable()
export class MatchAppendOutputLayoutsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetMatchAppendOutputLayoutForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendOutputLayouts/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMatchAppendOutputLayoutForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMatchAppendOutputLayoutForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMatchAppendOutputLayoutForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMatchAppendOutputLayoutForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMatchAppendOutputLayoutForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMatchAppendOutputLayoutForEdit(id: number | null | undefined): Observable<GetMatchAppendOutputLayoutForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendOutputLayouts/GetMatchAppendOutputLayoutForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchAppendOutputLayoutForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchAppendOutputLayoutForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMatchAppendOutputLayoutForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMatchAppendOutputLayoutForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchAppendOutputLayoutForEdit(response: HttpResponseBase): Observable<GetMatchAppendOutputLayoutForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMatchAppendOutputLayoutForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMatchAppendOutputLayoutForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditMatchAppendOutputLayoutDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendOutputLayouts/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendOutputLayouts/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MatchAppendsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param userNameFiler (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMatchAppendTasks(filter: string | null | undefined, userNameFiler: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetMatchAppendForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/GetAllMatchAppendTasks?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (userNameFiler !== undefined)
            url_ += "UserNameFiler=" + encodeURIComponent("" + userNameFiler) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMatchAppendTasks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMatchAppendTasks(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMatchAppendForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMatchAppendForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMatchAppendTasks(response: HttpResponseBase): Observable<PagedResultDtoOfGetMatchAppendForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMatchAppendForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMatchAppendForViewDto>(<any>null);
    }

    /**
     * @param matchAppendId (optional) 
     * @return Success
     */
    copyMatchAppendTask(matchAppendId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/CopyMatchAppendTask?";
        if (matchAppendId !== undefined)
            url_ += "matchAppendId=" + encodeURIComponent("" + matchAppendId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyMatchAppendTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyMatchAppendTask(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCopyMatchAppendTask(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param matchAppendId (optional) 
     * @param isSubmit (optional) 
     * @return Success
     */
    submitUnlockMatchAppendTask(matchAppendId: number | null | undefined, isSubmit: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/SubmitUnlockMatchAppendTask?";
        if (matchAppendId !== undefined)
            url_ += "matchAppendId=" + encodeURIComponent("" + matchAppendId) + "&"; 
        if (isSubmit !== undefined)
            url_ += "isSubmit=" + encodeURIComponent("" + isSubmit) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitUnlockMatchAppendTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitUnlockMatchAppendTask(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitUnlockMatchAppendTask(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getMatchAppendDatabasesBasedOnUserId(userId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/GetMatchAppendDatabasesBasedOnUserId?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchAppendDatabasesBasedOnUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchAppendDatabasesBasedOnUserId(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchAppendDatabasesBasedOnUserId(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @return Success
     */
    getLatestBuildFromDatabaseId(databaseId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/GetLatestBuildFromDatabaseId?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestBuildFromDatabaseId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestBuildFromDatabaseId(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestBuildFromDatabaseId(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param matchAppendId (optional) 
     * @return Success
     */
    getMatchAppendStatusHistory(matchAppendId: number | null | undefined): Observable<MatchAndAppendStatusDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/GetMatchAppendStatusHistory?";
        if (matchAppendId !== undefined)
            url_ += "matchAppendId=" + encodeURIComponent("" + matchAppendId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchAppendStatusHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchAppendStatusHistory(<any>response_);
                } catch (e) {
                    return <Observable<MatchAndAppendStatusDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchAndAppendStatusDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchAppendStatusHistory(response: HttpResponseBase): Observable<MatchAndAppendStatusDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MatchAndAppendStatusDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchAndAppendStatusDto[]>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @return Success
     */
    getReadyToLoadPathFromConfiguration(databaseId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/GetReadyToLoadPathFromConfiguration?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReadyToLoadPathFromConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReadyToLoadPathFromConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetReadyToLoadPathFromConfiguration(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param fileNameFromControl (optional) 
     * @param fileNameFromFreeText (optional) 
     * @return Success
     */
    processDatabaseSetupStep(input: MatchAppendDto | null | undefined, fileNameFromControl: string | null | undefined, fileNameFromFreeText: string | null | undefined): Observable<MatchAppendDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/ProcessDatabaseSetupStep?";
        if (fileNameFromControl !== undefined)
            url_ += "fileNameFromControl=" + encodeURIComponent("" + fileNameFromControl) + "&"; 
        if (fileNameFromFreeText !== undefined)
            url_ += "fileNameFromFreeText=" + encodeURIComponent("" + fileNameFromFreeText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessDatabaseSetupStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessDatabaseSetupStep(<any>response_);
                } catch (e) {
                    return <Observable<MatchAppendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchAppendDto>><any>_observableThrow(response_);
        }));
    }

    protected processProcessDatabaseSetupStep(response: HttpResponseBase): Observable<MatchAppendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchAppendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchAppendDto>(<any>null);
    }

    /**
     * @param matchAppendinputLayout (optional) 
     * @param fileType (optional) 
     * @param databaseID (optional) 
     * @return Success
     */
    processInputLayoutStep(matchAppendinputLayout: MatchAndAppendInputLayoutDto[] | null | undefined, fileType: string | null | undefined, databaseID: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/ProcessInputLayoutStep?";
        if (fileType !== undefined)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&"; 
        if (databaseID !== undefined)
            url_ += "databaseID=" + encodeURIComponent("" + databaseID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(matchAppendinputLayout);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessInputLayoutStep(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessInputLayoutStep(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processProcessInputLayoutStep(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getMatchAppendFileTypes(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/GetMatchAppendFileTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchAppendFileTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchAppendFileTypes(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchAppendFileTypes(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param importFieldString (optional) 
     * @param matchAppendId (optional) 
     * @param matchAppendDto (optional) 
     * @return Success
     */
    importFielList(importFieldString: string | null | undefined, matchAppendId: number | null | undefined, matchAppendDto: CreateOrEditMatchAppendDto | null | undefined): Observable<MatchAndAppendInputLayoutDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/ImportFielList?";
        if (importFieldString !== undefined)
            url_ += "importFieldString=" + encodeURIComponent("" + importFieldString) + "&"; 
        if (matchAppendId !== undefined)
            url_ += "matchAppendId=" + encodeURIComponent("" + matchAppendId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(matchAppendDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportFielList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportFielList(<any>response_);
                } catch (e) {
                    return <Observable<MatchAndAppendInputLayoutDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchAndAppendInputLayoutDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processImportFielList(response: HttpResponseBase): Observable<MatchAndAppendInputLayoutDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MatchAndAppendInputLayoutDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchAndAppendInputLayoutDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getMatchAppendOutputTypes(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/GetMatchAppendOutputTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchAppendOutputTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchAppendOutputTypes(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchAppendOutputTypes(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param iBuildID (optional) 
     * @return Success
     */
    getBuildTableLayoutFieldByBuildID(iBuildID: string | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/GetBuildTableLayoutFieldByBuildID?";
        if (iBuildID !== undefined)
            url_ += "iBuildID=" + encodeURIComponent("" + iBuildID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuildTableLayoutFieldByBuildID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuildTableLayoutFieldByBuildID(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuildTableLayoutFieldByBuildID(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param buildId (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    getSourceDropdownList(buildId: number | null | undefined, databaseId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/GetSourceDropdownList?";
        if (buildId !== undefined)
            url_ += "buildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSourceDropdownList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSourceDropdownList(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSourceDropdownList(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param tableId (optional) 
     * @param list (optional) 
     * @return Success
     */
    getMatchAppendAvailabelFields(tableId: string | null | undefined, list: string[] | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/GetMatchAppendAvailabelFields?";
        if (tableId !== undefined)
            url_ += "tableId=" + encodeURIComponent("" + tableId) + "&"; 
        if (list !== undefined)
            list && list.forEach(item => { url_ += "list=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchAppendAvailabelFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchAppendAvailabelFields(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchAppendAvailabelFields(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param matchAppendDto (optional) 
     * @param matchAppendId (optional) 
     * @return Success
     */
    addMatchAppendSelectedFields(matchAppendDto: CreateOrEditMatchAppendDto | null | undefined, matchAppendId: number | null | undefined): Observable<MatchAndAppendOutputLayoutDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/AddMatchAppendSelectedFields?";
        if (matchAppendId !== undefined)
            url_ += "matchAppendId=" + encodeURIComponent("" + matchAppendId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(matchAppendDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMatchAppendSelectedFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMatchAppendSelectedFields(<any>response_);
                } catch (e) {
                    return <Observable<MatchAndAppendOutputLayoutDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchAndAppendOutputLayoutDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processAddMatchAppendSelectedFields(response: HttpResponseBase): Observable<MatchAndAppendOutputLayoutDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MatchAndAppendOutputLayoutDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchAndAppendOutputLayoutDto[]>(<any>null);
    }

    /**
     * @param matchAppendId (optional) 
     * @return Success
     */
    getMatchAppendForEdit(matchAppendId: number | null | undefined): Observable<GetMatchAppendForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/GetMatchAppendForEdit?";
        if (matchAppendId !== undefined)
            url_ += "matchAppendId=" + encodeURIComponent("" + matchAppendId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchAppendForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchAppendForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMatchAppendForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMatchAppendForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchAppendForEdit(response: HttpResponseBase): Observable<GetMatchAppendForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMatchAppendForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMatchAppendForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditMatchAppendDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createEditAndSubmit(input: CreateOrEditMatchAppendDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppends/CreateEditAndSubmit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEditAndSubmit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEditAndSubmit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEditAndSubmit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MatchAppendStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetMatchAppendStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendStatuses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMatchAppendStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMatchAppendStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMatchAppendStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMatchAppendStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMatchAppendStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMatchAppendStatusForEdit(id: number | null | undefined): Observable<GetMatchAppendStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendStatuses/GetMatchAppendStatusForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchAppendStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchAppendStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMatchAppendStatusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMatchAppendStatusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchAppendStatusForEdit(response: HttpResponseBase): Observable<GetMatchAppendStatusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMatchAppendStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMatchAppendStatusForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditMatchAppendStatusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchAppendStatuses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ModelDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetModelDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ModelDetails/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetModelDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetModelDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetModelDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetModelDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetModelDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getModelDetailForEdit(id: number | null | undefined): Observable<GetModelDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ModelDetails/GetModelDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModelDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModelDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetModelDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetModelDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetModelDetailForEdit(response: HttpResponseBase): Observable<GetModelDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetModelDetailForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetModelDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditModelDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ModelDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ModelDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ModelQueuesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetModelQueueForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ModelQueues/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetModelQueueForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetModelQueueForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetModelQueueForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetModelQueueForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetModelQueueForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getModelQueueForEdit(id: number | null | undefined): Observable<GetModelQueueForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ModelQueues/GetModelQueueForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModelQueueForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModelQueueForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetModelQueueForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetModelQueueForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetModelQueueForEdit(response: HttpResponseBase): Observable<GetModelQueueForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetModelQueueForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetModelQueueForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditModelQueueDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ModelQueues/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ModelQueues/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ModelsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllModels(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfModelScoringDto> {
        let url_ = this.baseUrl + "/api/services/app/Models/GetAllModels?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllModels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllModels(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfModelScoringDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfModelScoringDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllModels(response: HttpResponseBase): Observable<PagedResultDtoOfModelScoringDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfModelScoringDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfModelScoringDto>(<any>null);
    }

    /**
     * @return Success
     */
    getModelTypeAndWeight(): Observable<GetModelTypeAndWeightDto> {
        let url_ = this.baseUrl + "/api/services/app/Models/GetModelTypeAndWeight";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModelTypeAndWeight(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModelTypeAndWeight(<any>response_);
                } catch (e) {
                    return <Observable<GetModelTypeAndWeightDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetModelTypeAndWeightDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetModelTypeAndWeight(response: HttpResponseBase): Observable<GetModelTypeAndWeightDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetModelTypeAndWeightDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetModelTypeAndWeightDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateOrEditModelDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Models/CreateAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param modelDetailId (optional) 
     * @param isCopy (optional) 
     * @return Success
     */
    getModelForEdit(modelDetailId: number | null | undefined, isCopy: boolean | null | undefined): Observable<CreateOrEditModelDto> {
        let url_ = this.baseUrl + "/api/services/app/Models/GetModelForEdit?";
        if (modelDetailId !== undefined)
            url_ += "modelDetailId=" + encodeURIComponent("" + modelDetailId) + "&"; 
        if (isCopy !== undefined)
            url_ += "isCopy=" + encodeURIComponent("" + isCopy) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModelForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModelForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditModelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditModelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetModelForEdit(response: HttpResponseBase): Observable<CreateOrEditModelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditModelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditModelDto>(<any>null);
    }

    /**
     * @param defaultDatabaseId (optional) 
     * @return Success
     */
    getDatabaseWithLatestBuild(defaultDatabaseId: number | null | undefined): Observable<GetModelScoringDropdownDto> {
        let url_ = this.baseUrl + "/api/services/app/Models/GetDatabaseWithLatestBuild?";
        if (defaultDatabaseId !== undefined)
            url_ += "defaultDatabaseId=" + encodeURIComponent("" + defaultDatabaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatabaseWithLatestBuild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatabaseWithLatestBuild(<any>response_);
                } catch (e) {
                    return <Observable<GetModelScoringDropdownDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetModelScoringDropdownDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatabaseWithLatestBuild(response: HttpResponseBase): Observable<GetModelScoringDropdownDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetModelScoringDropdownDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetModelScoringDropdownDto>(<any>null);
    }

    /**
     * @param userid (optional) 
     * @param currentDatabaseId (optional) 
     * @return Success
     */
    getAllDatabasesForDropdown(userid: number | null | undefined, currentDatabaseId: number | null | undefined): Observable<GetAllDatabaseDto> {
        let url_ = this.baseUrl + "/api/services/app/Models/GetAllDatabasesForDropdown?";
        if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&"; 
        if (currentDatabaseId !== undefined)
            url_ += "currentDatabaseId=" + encodeURIComponent("" + currentDatabaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDatabasesForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDatabasesForDropdown(<any>response_);
                } catch (e) {
                    return <Observable<GetAllDatabaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllDatabaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDatabasesForDropdown(response: HttpResponseBase): Observable<GetAllDatabaseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllDatabaseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllDatabaseDto>(<any>null);
    }

    /**
     * @param iDatabaseID (optional) 
     * @return Success
     */
    getFieldsOnDatabaseChange(iDatabaseID: number | null | undefined): Observable<GetModelScoringDropdownDto> {
        let url_ = this.baseUrl + "/api/services/app/Models/GetFieldsOnDatabaseChange?";
        if (iDatabaseID !== undefined)
            url_ += "iDatabaseID=" + encodeURIComponent("" + iDatabaseID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFieldsOnDatabaseChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFieldsOnDatabaseChange(<any>response_);
                } catch (e) {
                    return <Observable<GetModelScoringDropdownDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetModelScoringDropdownDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFieldsOnDatabaseChange(response: HttpResponseBase): Observable<GetModelScoringDropdownDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetModelScoringDropdownDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetModelScoringDropdownDto>(<any>null);
    }

    /**
     * @param modelDetailID (optional) 
     * @param isSampleScore (optional) 
     * @return Success
     */
    modelsActions(modelDetailID: number | null | undefined, isSampleScore: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Models/ModelsActions?";
        if (modelDetailID !== undefined)
            url_ += "modelDetailID=" + encodeURIComponent("" + modelDetailID) + "&"; 
        if (isSampleScore !== undefined)
            url_ += "isSampleScore=" + encodeURIComponent("" + isSampleScore) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModelsActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModelsActions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processModelsActions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param modelDetailID (optional) 
     * @return Success
     */
    modelsActionsCancel(modelDetailID: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Models/ModelsActionsCancel?";
        if (modelDetailID !== undefined)
            url_ += "modelDetailID=" + encodeURIComponent("" + modelDetailID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModelsActionsCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModelsActionsCancel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processModelsActionsCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param modelDetailId (optional) 
     * @return Success
     */
    getStatusHistory(modelDetailId: number | null | undefined): Observable<ModelStatusDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Models/GetStatusHistory?";
        if (modelDetailId !== undefined)
            url_ += "modelDetailId=" + encodeURIComponent("" + modelDetailId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatusHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusHistory(<any>response_);
                } catch (e) {
                    return <Observable<ModelStatusDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModelStatusDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatusHistory(response: HttpResponseBase): Observable<ModelStatusDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModelStatusDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModelStatusDto[]>(<any>null);
    }
}

@Injectable()
export class NeighborhoodsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetNeighborhoodForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Neighborhoods/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetNeighborhoodForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetNeighborhoodForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetNeighborhoodForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetNeighborhoodForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetNeighborhoodForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getNeighborhoodForEdit(id: number | null | undefined): Observable<GetNeighborhoodForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Neighborhoods/GetNeighborhoodForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNeighborhoodForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNeighborhoodForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetNeighborhoodForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNeighborhoodForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNeighborhoodForEdit(response: HttpResponseBase): Observable<GetNeighborhoodForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNeighborhoodForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNeighborhoodForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditNeighborhoodDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Neighborhoods/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Neighborhoods/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setNotificationAsRead(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateNotificationSettings(input: UpdateNotificationSettingsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    deleteAllUserNotifications(state: UserNotificationState | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteAllUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAllUserNotifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OccupationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param databaseId (optional) 
     * @param buildId (optional) 
     * @return Success
     */
    getInitialData(databaseId: number | null | undefined, buildId: number | null | undefined, screen: AdvanceSelectionScreen): Observable<GetOccupationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Occupations/GetInitialData?";
        if (databaseId !== undefined)
            url_ += "DatabaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (buildId !== undefined)
            url_ += "BuildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (screen === undefined || screen === null)
            throw new Error("The parameter 'screen' must be defined and cannot be null.");
        else
            url_ += "Screen=" + encodeURIComponent("" + screen) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInitialData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInitialData(<any>response_);
                } catch (e) {
                    return <Observable<GetOccupationForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOccupationForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInitialData(response: HttpResponseBase): Observable<GetOccupationForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetOccupationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOccupationForViewDto>(<any>null);
    }

    /**
     * @param industryCode (optional) 
     * @return Success
     */
    getAllOccupationByIndustry(industryCode: string | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Occupations/GetAllOccupationByIndustry?";
        if (industryCode !== undefined)
            url_ += "industryCode=" + encodeURIComponent("" + industryCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOccupationByIndustry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOccupationByIndustry(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOccupationByIndustry(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param industryCode (optional) 
     * @param occupationCode (optional) 
     * @return Success
     */
    getAllSpecialtyTitleByIndustryOccupation(industryCode: string | null | undefined, occupationCode: string | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Occupations/GetAllSpecialtyTitleByIndustryOccupation?";
        if (industryCode !== undefined)
            url_ += "industryCode=" + encodeURIComponent("" + industryCode) + "&"; 
        if (occupationCode !== undefined)
            url_ += "occupationCode=" + encodeURIComponent("" + occupationCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSpecialtyTitleByIndustryOccupation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSpecialtyTitleByIndustryOccupation(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSpecialtyTitleByIndustryOccupation(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }
}

@Injectable()
export class OffersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param mailerId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllOffers(mailerId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetOfferForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Offers/GetAllOffers?";
        if (mailerId !== undefined)
            url_ += "MailerId=" + encodeURIComponent("" + mailerId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOffers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOffers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetOfferForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetOfferForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOffers(response: HttpResponseBase): Observable<PagedResultDtoOfGetOfferForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetOfferForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetOfferForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOfferForEdit(id: number | null | undefined): Observable<GetOfferForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Offers/GetOfferForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOfferForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOfferForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetOfferForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOfferForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetOfferForEdit(response: HttpResponseBase): Observable<GetOfferForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetOfferForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOfferForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditOfferDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Offers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getDDForOfferType(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Offers/GetDDForOfferType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDDForOfferType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDDForOfferType(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDDForOfferType(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }
}

@Injectable()
export class OfferSamplesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param offerId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllOfferSamples(offerId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOfferSampleDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferSamples/GetAllOfferSamples?";
        if (offerId !== undefined)
            url_ += "OfferId=" + encodeURIComponent("" + offerId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOfferSamples(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOfferSamples(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOfferSampleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOfferSampleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOfferSamples(response: HttpResponseBase): Observable<PagedResultDtoOfOfferSampleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOfferSampleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOfferSampleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOfferSampleForEdit(id: number | null | undefined): Observable<CreateOrEditOfferSampleDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferSamples/GetOfferSampleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOfferSampleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOfferSampleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditOfferSampleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditOfferSampleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOfferSampleForEdit(response: HttpResponseBase): Observable<CreateOrEditOfferSampleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditOfferSampleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditOfferSampleDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param clientFileName (optional) 
     * @param path (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditOfferSampleDto | null | undefined, clientFileName: string | null | undefined, path: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OfferSamples/CreateOrEdit?";
        if (clientFileName !== undefined)
            url_ += "clientFileName=" + encodeURIComponent("" + clientFileName) + "&"; 
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OfferSamples/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @param offerSampleId (optional) 
     * @return Success
     */
    downloadOfferSample(databaseId: number | null | undefined, offerSampleId: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/OfferSamples/DownloadOfferSample?";
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (offerSampleId !== undefined)
            url_ += "offerSampleId=" + encodeURIComponent("" + offerSampleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadOfferSample(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadOfferSample(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadOfferSample(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class OrderExportPartsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param editCampaignExportPartList (optional) 
     * @param userName (optional) 
     * @return Success
     */
    insert(editCampaignExportPartList: EditCampaignExportPartDto[] | null | undefined, userName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrderExportParts/Insert?";
        if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(editCampaignExportPartList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    delete(campaignId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrderExportParts/Delete?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrderStatusServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    getStatusHistory(campaignId: number | null | undefined): Observable<CampaignStatusDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OrderStatus/GetStatusHistory?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatusHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusHistory(<any>response_);
                } catch (e) {
                    return <Observable<CampaignStatusDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CampaignStatusDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatusHistory(response: HttpResponseBase): Observable<CampaignStatusDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CampaignStatusDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CampaignStatusDto[]>(<any>null);
    }

    /**
     * @param campaignID (optional) 
     * @return Success
     */
    updateCampaignStatus(campaignID: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrderStatus/UpdateCampaignStatus?";
        if (campaignID !== undefined)
            url_ += "campaignID=" + encodeURIComponent("" + campaignID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCampaignStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCampaignStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCampaignStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param campaignID (optional) 
     * @param databaseID (optional) 
     * @return Success
     */
    getLastLogStatement(campaignID: number | null | undefined, databaseID: number | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/OrderStatus/GetLastLogStatement?";
        if (campaignID !== undefined)
            url_ += "campaignID=" + encodeURIComponent("" + campaignID) + "&"; 
        if (databaseID !== undefined)
            url_ += "databaseID=" + encodeURIComponent("" + databaseID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastLogStatement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastLogStatement(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastLogStatement(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfOrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrganizationUnit(input: CreateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateOrganizationUnit(input: UpdateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveOrganizationUnit(input: MoveOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(input: UsersToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(input: RolesToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: FindOrganizationUnitUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findRoles(input: FindOrganizationUnitRolesInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class OwnersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param iIsActiveFilter (optional) 
     * @param selectedDatabase (optional) 
     * @param contactLastNameFilterText (optional) 
     * @param contactEmailFilterText (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllOwners(filter: string | null | undefined, iIsActiveFilter: number | null | undefined, selectedDatabase: number | null | undefined, contactLastNameFilterText: string | null | undefined, contactEmailFilterText: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOwnerDto> {
        let url_ = this.baseUrl + "/api/services/app/Owners/GetAllOwners?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (iIsActiveFilter !== undefined)
            url_ += "iIsActiveFilter=" + encodeURIComponent("" + iIsActiveFilter) + "&"; 
        if (selectedDatabase !== undefined)
            url_ += "SelectedDatabase=" + encodeURIComponent("" + selectedDatabase) + "&"; 
        if (contactLastNameFilterText !== undefined)
            url_ += "ContactLastNameFilterText=" + encodeURIComponent("" + contactLastNameFilterText) + "&"; 
        if (contactEmailFilterText !== undefined)
            url_ += "ContactEmailFilterText=" + encodeURIComponent("" + contactEmailFilterText) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOwners(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOwners(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOwnerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOwnerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOwners(response: HttpResponseBase): Observable<PagedResultDtoOfOwnerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOwnerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOwnerDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOwnerForEdit(id: number | null | undefined): Observable<CreateOrEditOwnerDto> {
        let url_ = this.baseUrl + "/api/services/app/Owners/GetOwnerForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwnerForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnerForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditOwnerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditOwnerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOwnerForEdit(response: HttpResponseBase): Observable<CreateOrEditOwnerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditOwnerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditOwnerDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditOwnerDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Owners/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    exportToExcel(input: GetAllSetupInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Owners/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInfoDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createPayment(input: CreatePaymentDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cancelPayment(input: CancelPaymentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }

    /**
     * @param recurringPaymentsEnabled (optional) 
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | null | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled !== undefined)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(<any>response_);
                } catch (e) {
                    return <Observable<PaymentGatewayModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentGatewayModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentGatewayModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentGatewayModel[]>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPayment(paymentId: number | null | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentAsync?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    buyNowSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    upgradeSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    extendSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    paymentFailed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param paymentId (optional) 
     * @param paypalOrderId (optional) 
     * @return Success
     */
    confirmPayment(paymentId: number | null | undefined, paypalOrderId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        if (paypalOrderId !== undefined)
            url_ += "paypalOrderId=" + encodeURIComponent("" + paypalOrderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<PayPalConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayPalConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalConfigurationDto>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }
}

@Injectable()
export class ProcessQueueDatabasesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param databases (optional) 
     * @param pQID (optional) 
     * @return Success
     */
    createOrEdit(databases: DropdownForProcessQueueDto[] | null | undefined, pQID: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProcessQueueDatabases/CreateOrEdit?";
        if (pQID !== undefined)
            url_ += "PQID=" + encodeURIComponent("" + pQID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(databases);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProcessQueueDatabases/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProcessQueuesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfProcessQueueDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessQueues/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProcessQueueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProcessQueueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfProcessQueueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProcessQueueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProcessQueueDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param pQID (optional) 
     * @return Success
     */
    getAllDbSet(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, pQID: number | null | undefined): Observable<PagedResultDtoOfProcessQueueDatabaseDtoForView> {
        let url_ = this.baseUrl + "/api/services/app/ProcessQueues/GetAllDbSet?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (pQID !== undefined)
            url_ += "PQID=" + encodeURIComponent("" + pQID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDbSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDbSet(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProcessQueueDatabaseDtoForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProcessQueueDatabaseDtoForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDbSet(response: HttpResponseBase): Observable<PagedResultDtoOfProcessQueueDatabaseDtoForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProcessQueueDatabaseDtoForView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProcessQueueDatabaseDtoForView>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLookupsForDropdown(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProcessQueues/GetAllLookupsForDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLookupsForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLookupsForDropdown(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLookupsForDropdown(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getAllLookupsOfProcessTypeForDropdown(code: string | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProcessQueues/GetAllLookupsOfProcessTypeForDropdown?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLookupsOfProcessTypeForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLookupsOfProcessTypeForDropdown(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLookupsOfProcessTypeForDropdown(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProcessQueueForView(id: number | null | undefined): Observable<GetProcessQueueForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessQueues/GetProcessQueueForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessQueueForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessQueueForView(<any>response_);
                } catch (e) {
                    return <Observable<GetProcessQueueForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProcessQueueForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessQueueForView(response: HttpResponseBase): Observable<GetProcessQueueForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProcessQueueForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProcessQueueForViewDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditProcessQueueDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProcessQueues/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProcessQueues/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    verifySmsCode(input: VerifySmsCodeInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateProfilePicture(input: UpdateProfilePictureInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPasswordComplexitySettingOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | null | undefined, userId: number | null | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RedisCachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<RedisCacheDto[]> {
        let url_ = this.baseUrl + "/api/services/app/RedisCaching/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RedisCacheDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RedisCacheDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RedisCacheDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RedisCacheDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RedisCacheDto[]>(<any>null);
    }

    /**
     * @param keyPrefix (optional) 
     * @return Success
     */
    clearCache(keyPrefix: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RedisCaching/ClearCache?";
        if (keyPrefix !== undefined)
            url_ += "keyPrefix=" + encodeURIComponent("" + keyPrefix) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RedisCaching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ReportsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getReports(): Observable<GetReportForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Reports/GetReports";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReports(<any>response_);
                } catch (e) {
                    return <Observable<GetReportForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReportForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReports(response: HttpResponseBase): Observable<GetReportForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetReportForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportForViewDto>(<any>null);
    }

    /**
     * @param excelData (optional) 
     * @return Success
     */
    generateExcelReport(excelData: { [key: string]: any; } | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Reports/GenerateExcelReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(excelData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateExcelReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateExcelReport(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateExcelReport(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param reportType (optional) 
     * @param segmentId (optional) 
     * @param campaignId (optional) 
     * @return Success
     */
    getInstantBreakDown(reportType: string | null | undefined, segmentId: number | null | undefined, campaignId: number | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/services/app/Reports/GetInstantBreakDown?";
        if (reportType !== undefined)
            url_ += "reportType=" + encodeURIComponent("" + reportType) + "&"; 
        if (segmentId !== undefined)
            url_ += "segmentId=" + encodeURIComponent("" + segmentId) + "&"; 
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstantBreakDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstantBreakDown(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetInstantBreakDown(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return Success
     */
    getAllForReportsDropdown(): Observable<ReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Reports/GetAllForReportsDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllForReportsDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllForReportsDropdown(<any>response_);
                } catch (e) {
                    return <Observable<ReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllForReportsDropdown(response: HttpResponseBase): Observable<ReportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEditUserReport(input: UserReport | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Reports/CreateOrEditUserReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditUserReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditUserReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditUserReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param permissions (optional) 
     * @return Success
     */
    getRoles(permissions: string[] | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateRole(input: CreateOrUpdateRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @param permissions (optional) 
     * @return Success
     */
    getRolesToExcel(roleId: number | null | undefined, permissions: string[] | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRolesToExcel?";
        if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class RoleListExcelExporterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param userReportDtos (optional) 
     * @return Success
     */
    exportToFile(userReportDtos: RoleReportDto[] | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/RoleListExcelExporter/ExportToFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userReportDtos);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToFile(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToFile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class SavedSelectionDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param segmentID (optional) 
     * @param savedSelectionID (optional) 
     * @param userDefault (optional) 
     * @return Success
     */
    getAllSavedSelectionsDetails(segmentID: number | null | undefined, savedSelectionID: number | null | undefined, userDefault: boolean | null | undefined): Observable<GetSavedSelectionDetailForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SavedSelectionDetails/GetAllSavedSelectionsDetails?";
        if (segmentID !== undefined)
            url_ += "segmentID=" + encodeURIComponent("" + segmentID) + "&"; 
        if (savedSelectionID !== undefined)
            url_ += "savedSelectionID=" + encodeURIComponent("" + savedSelectionID) + "&"; 
        if (userDefault !== undefined)
            url_ += "userDefault=" + encodeURIComponent("" + userDefault) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSavedSelectionsDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSavedSelectionsDetails(<any>response_);
                } catch (e) {
                    return <Observable<GetSavedSelectionDetailForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSavedSelectionDetailForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSavedSelectionsDetails(response: HttpResponseBase): Observable<GetSavedSelectionDetailForViewDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetSavedSelectionDetailForViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSavedSelectionDetailForViewDto[]>(<any>null);
    }
}

@Injectable()
export class SavedSelectionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param campaignID (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSavedSelections(filter: string | null | undefined, campaignID: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetSavedSelectionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SavedSelections/GetAllSavedSelections?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (campaignID !== undefined)
            url_ += "CampaignID=" + encodeURIComponent("" + campaignID) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSavedSelections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSavedSelections(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSavedSelectionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSavedSelectionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSavedSelections(response: HttpResponseBase): Observable<PagedResultDtoOfGetSavedSelectionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSavedSelectionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSavedSelectionForViewDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addSavedSelections(input: AddSavedSelection | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SavedSelections/AddSavedSelectionsAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSavedSelections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSavedSelections(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddSavedSelections(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSavedSelection(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SavedSelections/DeleteSavedSelectionAsync?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSavedSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSavedSelection(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSavedSelection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUserSavedSelection(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SavedSelections/DeleteUserSavedSelectionAsync?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserSavedSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserSavedSelection(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserSavedSelection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ruleId (optional) 
     * @param isDefault (optional) 
     * @return Success
     */
    updateIsDefaultRule(ruleId: number | null | undefined, isDefault: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SavedSelections/UpdateIsDefaultRule?";
        if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&"; 
        if (isDefault !== undefined)
            url_ += "isDefault=" + encodeURIComponent("" + isDefault) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIsDefaultRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIsDefaultRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateIsDefaultRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SecurityGroupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param selectedDatabase (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSecurityGroups(filter: string | null | undefined, selectedDatabase: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfSecurityGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/SecurityGroups/GetAllSecurityGroups?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (selectedDatabase !== undefined)
            url_ += "SelectedDatabase=" + encodeURIComponent("" + selectedDatabase) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSecurityGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSecurityGroups(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSecurityGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSecurityGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSecurityGroups(response: HttpResponseBase): Observable<PagedResultDtoOfSecurityGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSecurityGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSecurityGroupDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSecurityGroupForEdit(id: number | null | undefined): Observable<CreateOrEditSecurityGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/SecurityGroups/GetSecurityGroupForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSecurityGroupForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSecurityGroupForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditSecurityGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditSecurityGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSecurityGroupForEdit(response: HttpResponseBase): Observable<CreateOrEditSecurityGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditSecurityGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditSecurityGroupDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditSecurityGroupDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SecurityGroups/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    groupNameValidation(input: CreateOrEditSecurityGroupDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SecurityGroups/GroupNameValidation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGroupNameValidation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGroupNameValidation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGroupNameValidation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    exportToExcel(input: GetAllSecurityGroupsInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SecurityGroups/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param groupID (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getAllUserCount(filter: string | null | undefined, groupID: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfUserCountDto> {
        let url_ = this.baseUrl + "/api/services/app/SecurityGroups/GetAllUserCount?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (groupID !== undefined)
            url_ += "GroupID=" + encodeURIComponent("" + groupID) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserCount(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserCountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserCountDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserCount(response: HttpResponseBase): Observable<PagedResultDtoOfUserCountDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserCountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserCountDto>(<any>null);
    }
}

@Injectable()
export class SegmentListsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    fetchApprovedSources(input: GetAllApprovedSourcesInput | null | undefined): Observable<SourceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SegmentLists/FetchApprovedSources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchApprovedSources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchApprovedSources(<any>response_);
                } catch (e) {
                    return <Observable<SourceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SourceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processFetchApprovedSources(response: HttpResponseBase): Observable<SourceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SourceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SourceDto[]>(<any>null);
    }

    /**
     * @param iSegmentID (optional) 
     * @return Success
     */
    getExistingSourceData(iSegmentID: number | null | undefined): Observable<GetExistingSourceDataForView> {
        let url_ = this.baseUrl + "/api/services/app/SegmentLists/GetExistingSourceData?";
        if (iSegmentID !== undefined)
            url_ += "iSegmentID=" + encodeURIComponent("" + iSegmentID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExistingSourceData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExistingSourceData(<any>response_);
                } catch (e) {
                    return <Observable<GetExistingSourceDataForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetExistingSourceDataForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetExistingSourceData(response: HttpResponseBase): Observable<GetExistingSourceDataForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExistingSourceDataForView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExistingSourceDataForView>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    saveSources(input: SaveSourcesInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SegmentLists/SaveSources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSources(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveSources(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SegmentPrevOrdersesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param campaignId (optional) 
     * @param segmentID (optional) 
     * @param filter (optional) 
     * @param isFromSearch (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllPrevOrdersList(campaignId: number | null | undefined, segmentID: number | null | undefined, filter: string | null | undefined, isFromSearch: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<GetSegmentPrevOrdersForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SegmentPrevOrderses/GetAllPrevOrdersList?";
        if (campaignId !== undefined)
            url_ += "CampaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (segmentID !== undefined)
            url_ += "SegmentID=" + encodeURIComponent("" + segmentID) + "&"; 
        if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (isFromSearch !== undefined)
            url_ += "isFromSearch=" + encodeURIComponent("" + isFromSearch) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPrevOrdersList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPrevOrdersList(<any>response_);
                } catch (e) {
                    return <Observable<GetSegmentPrevOrdersForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSegmentPrevOrdersForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPrevOrdersList(response: HttpResponseBase): Observable<GetSegmentPrevOrdersForViewDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetSegmentPrevOrdersForViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSegmentPrevOrdersForViewDto[]>(<any>null);
    }

    /**
     * @param campaignID (optional) 
     * @param segmentID (optional) 
     * @return Success
     */
    getExistingPreviousOrders(campaignID: number | null | undefined, segmentID: number | null | undefined): Observable<SegmentPrevOrdersView> {
        let url_ = this.baseUrl + "/api/services/app/SegmentPrevOrderses/GetExistingPreviousOrders?";
        if (campaignID !== undefined)
            url_ += "campaignID=" + encodeURIComponent("" + campaignID) + "&"; 
        if (segmentID !== undefined)
            url_ += "segmentID=" + encodeURIComponent("" + segmentID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExistingPreviousOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExistingPreviousOrders(<any>response_);
                } catch (e) {
                    return <Observable<SegmentPrevOrdersView>><any>_observableThrow(e);
                }
            } else
                return <Observable<SegmentPrevOrdersView>><any>_observableThrow(response_);
        }));
    }

    protected processGetExistingPreviousOrders(response: HttpResponseBase): Observable<SegmentPrevOrdersView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SegmentPrevOrdersView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SegmentPrevOrdersView>(<any>null);
    }

    /**
     * @param previousOrderID (optional) 
     * @return Success
     */
    getListOfSegmentIDs(previousOrderID: number | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/SegmentPrevOrderses/GetListOfSegmentIDs?";
        if (previousOrderID !== undefined)
            url_ += "previousOrderID=" + encodeURIComponent("" + previousOrderID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListOfSegmentIDs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOfSegmentIDs(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListOfSegmentIDs(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    savePreviousOrders(input: CreateOrEditSegmentPrevOrdersDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SegmentPrevOrderses/SavePreviousOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePreviousOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePreviousOrders(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSavePreviousOrders(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param buildId (optional) 
     * @return Success
     */
    getFieldNamesBasedOnBuildId(filter: string | null | undefined, buildId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SegmentPrevOrderses/GetFieldNamesBasedOnBuildId?";
        if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (buildId !== undefined)
            url_ += "buildId=" + encodeURIComponent("" + buildId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFieldNamesBasedOnBuildId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFieldNamesBasedOnBuildId(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFieldNamesBasedOnBuildId(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }
}

@Injectable()
export class SegmentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param segmentId (optional) 
     * @param isExportLayout (optional) 
     * @return Success
     */
    getRecordDump(segmentId: number | null | undefined, isExportLayout: boolean | null | undefined): Observable<SegmentDataPreviewDto> {
        let url_ = this.baseUrl + "/api/services/app/Segments/GetRecordDumpAsync?";
        if (segmentId !== undefined)
            url_ += "segmentId=" + encodeURIComponent("" + segmentId) + "&"; 
        if (isExportLayout !== undefined)
            url_ += "isExportLayout=" + encodeURIComponent("" + isExportLayout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecordDump(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecordDump(<any>response_);
                } catch (e) {
                    return <Observable<SegmentDataPreviewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SegmentDataPreviewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecordDump(response: HttpResponseBase): Observable<SegmentDataPreviewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SegmentDataPreviewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SegmentDataPreviewDto>(<any>null);
    }

    /**
     * @param segmentId (optional) 
     * @param isExportLayout (optional) 
     * @return Success
     */
    downloadDataPreview(segmentId: number | null | undefined, isExportLayout: boolean | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Segments/DownloadDataPreview?";
        if (segmentId !== undefined)
            url_ += "segmentId=" + encodeURIComponent("" + segmentId) + "&"; 
        if (isExportLayout !== undefined)
            url_ += "isExportLayout=" + encodeURIComponent("" + isExportLayout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadDataPreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadDataPreview(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadDataPreview(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param orderId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSegmentList(filter: string | null | undefined, orderId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<GetAllSegmentForCampaign> {
        let url_ = this.baseUrl + "/api/services/app/Segments/GetAllSegmentList?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegmentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegmentList(<any>response_);
                } catch (e) {
                    return <Observable<GetAllSegmentForCampaign>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllSegmentForCampaign>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSegmentList(response: HttpResponseBase): Observable<GetAllSegmentForCampaign> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllSegmentForCampaign.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllSegmentForCampaign>(<any>null);
    }

    /**
     * @param segmentIds (optional) 
     * @return Success
     */
    getSegmentsBasedOnIds(segmentIds: number | null | undefined): Observable<GetSegmentListForView> {
        let url_ = this.baseUrl + "/api/services/app/Segments/GetSegmentsBasedOnIds?";
        if (segmentIds !== undefined)
            url_ += "segmentIds=" + encodeURIComponent("" + segmentIds) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSegmentsBasedOnIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSegmentsBasedOnIds(<any>response_);
                } catch (e) {
                    return <Observable<GetSegmentListForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSegmentListForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetSegmentsBasedOnIds(response: HttpResponseBase): Observable<GetSegmentListForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSegmentListForView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSegmentListForView>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    getAllSegmentForDropdown(campaignId: number | null | undefined, databaseId: number | null | undefined): Observable<GetAllSegmentsDropdownOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Segments/GetAllSegmentForDropdown?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSegmentForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegmentForDropdown(<any>response_);
                } catch (e) {
                    return <Observable<GetAllSegmentsDropdownOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllSegmentsDropdownOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSegmentForDropdown(response: HttpResponseBase): Observable<GetAllSegmentsDropdownOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllSegmentsDropdownOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllSegmentsDropdownOutputDto>(<any>null);
    }

    /**
     * @param segmentId (optional) 
     * @return Success
     */
    getSegmentForEdit(segmentId: number | null | undefined): Observable<CreateOrEditSegmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Segments/GetSegmentForEdit?";
        if (segmentId !== undefined)
            url_ += "segmentId=" + encodeURIComponent("" + segmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSegmentForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSegmentForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditSegmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditSegmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSegmentForEdit(response: HttpResponseBase): Observable<CreateOrEditSegmentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditSegmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditSegmentDto>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    getIsAutoSupress(campaignId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Segments/GetIsAutoSupress?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIsAutoSupress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIsAutoSupress(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetIsAutoSupress(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param segmentId (optional) 
     * @return Success
     */
    getMaxPerGroups(campaignId: number | null | undefined, segmentId: number | null | undefined): Observable<GetAllSegmentsDropdownOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Segments/GetMaxPerGroups?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (segmentId !== undefined)
            url_ += "segmentId=" + encodeURIComponent("" + segmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaxPerGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaxPerGroups(<any>response_);
                } catch (e) {
                    return <Observable<GetAllSegmentsDropdownOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllSegmentsDropdownOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaxPerGroups(response: HttpResponseBase): Observable<GetAllSegmentsDropdownOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllSegmentsDropdownOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllSegmentsDropdownOutputDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getLatestIdedupeorderSpecified(orderId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Segments/GetLatestIdedupeorderSpecified?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestIdedupeorderSpecified(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestIdedupeorderSpecified(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestIdedupeorderSpecified(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    fetchConfigValueForCalculateDistance(campaignId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Segments/FetchConfigValueForCalculateDistance?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchConfigValueForCalculateDistance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchConfigValueForCalculateDistance(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processFetchConfigValueForCalculateDistance(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param segment (optional) 
     * @param orderStatus (optional) 
     * @return Success
     */
    createOrEdit(segment: CreateOrEditSegmentDto | null | undefined, orderStatus: number | null | undefined): Observable<CreateOrEditSegmentOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Segments/CreateOrEdit?";
        if (orderStatus !== undefined)
            url_ += "orderStatus=" + encodeURIComponent("" + orderStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(segment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditSegmentOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditSegmentOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<CreateOrEditSegmentOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditSegmentOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditSegmentOutputDto>(<any>null);
    }

    /**
     * @param segmentID (optional) 
     * @return Success
     */
    getQuickCount(segmentID: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Segments/GetQuickCountAsync?";
        if (segmentID !== undefined)
            url_ += "segmentID=" + encodeURIComponent("" + segmentID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuickCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuickCount(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuickCount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Segments/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    copy(input: CopySegmentDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Segments/Copy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopy(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCopy(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    importSegment(input: ImportSegmentDTO | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Segments/ImportSegment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportSegment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportSegment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processImportSegment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param iCopyToOrderID (optional) 
     * @param iCopyFromOrderID (optional) 
     * @return Success
     */
    validateCampaignIDForImportSegment(iCopyToOrderID: number | null | undefined, iCopyFromOrderID: number | null | undefined): Observable<ImportSegmentDTO> {
        let url_ = this.baseUrl + "/api/services/app/Segments/ValidateCampaignIDForImportSegment?";
        if (iCopyToOrderID !== undefined)
            url_ += "iCopyToOrderID=" + encodeURIComponent("" + iCopyToOrderID) + "&"; 
        if (iCopyFromOrderID !== undefined)
            url_ += "iCopyFromOrderID=" + encodeURIComponent("" + iCopyFromOrderID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateCampaignIDForImportSegment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateCampaignIDForImportSegment(<any>response_);
                } catch (e) {
                    return <Observable<ImportSegmentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportSegmentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processValidateCampaignIDForImportSegment(response: HttpResponseBase): Observable<ImportSegmentDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportSegmentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportSegmentDTO>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getMaximumIDedupeNumber(orderId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Segments/GetMaximumIDedupeNumber?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaximumIDedupeNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaximumIDedupeNumber(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaximumIDedupeNumber(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param segmentid (optional) 
     * @param fromSegment (optional) 
     * @param toSegment (optional) 
     * @param toLocation (optional) 
     * @param campaignId (optional) 
     * @return Success
     */
    moveSegment(segmentid: number | null | undefined, fromSegment: number | null | undefined, toSegment: number | null | undefined, toLocation: number | null | undefined, campaignId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Segments/MoveSegment?";
        if (segmentid !== undefined)
            url_ += "segmentid=" + encodeURIComponent("" + segmentid) + "&"; 
        if (fromSegment !== undefined)
            url_ += "fromSegment=" + encodeURIComponent("" + fromSegment) + "&"; 
        if (toSegment !== undefined)
            url_ += "toSegment=" + encodeURIComponent("" + toSegment) + "&"; 
        if (toLocation !== undefined)
            url_ += "toLocation=" + encodeURIComponent("" + toLocation) + "&"; 
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveSegment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveSegment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveSegment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSegmentForView(id: number | null | undefined): Observable<GetSegmentListForView> {
        let url_ = this.baseUrl + "/api/services/app/Segments/GetSegmentForView?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSegmentForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSegmentForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSegmentListForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSegmentListForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetSegmentForView(response: HttpResponseBase): Observable<GetSegmentListForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSegmentListForView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSegmentListForView>(<any>null);
    }
}

@Injectable()
export class SegmentSelectionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param orderId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getSegmentsForInlineEdit(filter: string | null | undefined, orderId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<BatchEditSegmentDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetSegmentsForInlineEdit?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSegmentsForInlineEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSegmentsForInlineEdit(<any>response_);
                } catch (e) {
                    return <Observable<BatchEditSegmentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BatchEditSegmentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSegmentsForInlineEdit(response: HttpResponseBase): Observable<BatchEditSegmentDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BatchEditSegmentDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BatchEditSegmentDto[]>(<any>null);
    }

    /**
     * @param buildId (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    getInitialStateForBatchEdit(buildId: number | null | undefined, databaseId: number | null | undefined): Observable<GetInitialStateForBatchEdit> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetInitialStateForBatchEdit?";
        if (buildId !== undefined)
            url_ += "buildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInitialStateForBatchEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInitialStateForBatchEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetInitialStateForBatchEdit>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInitialStateForBatchEdit>><any>_observableThrow(response_);
        }));
    }

    protected processGetInitialStateForBatchEdit(response: HttpResponseBase): Observable<GetInitialStateForBatchEdit> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInitialStateForBatchEdit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInitialStateForBatchEdit>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    saveBatchSegments(input: SaveBatchSegmentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/SaveBatchSegments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveBatchSegments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveBatchSegments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveBatchSegments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param bulkSegmentData (optional) 
     * @return Success
     */
    saveBulkSegmentFileData(bulkSegmentData: BulkSegmentDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/SaveBulkSegmentFileData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bulkSegmentData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveBulkSegmentFileData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveBulkSegmentFileData(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSaveBulkSegmentFileData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param isDefaultFormat (optional) 
     * @param databaseId (optional) 
     * @return Success
     */
    downloadTemplate(isDefaultFormat: boolean | null | undefined, databaseId: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/DownloadTemplate?";
        if (isDefaultFormat !== undefined)
            url_ += "isDefaultFormat=" + encodeURIComponent("" + isDefaultFormat) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTemplate(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadTemplate(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param orderId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getSegmentsForGlobalChanges(filter: string | null | undefined, orderId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<GlobalChangesDto> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetSegmentsForGlobalChanges?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSegmentsForGlobalChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSegmentsForGlobalChanges(<any>response_);
                } catch (e) {
                    return <Observable<GlobalChangesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GlobalChangesDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSegmentsForGlobalChanges(response: HttpResponseBase): Observable<GlobalChangesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GlobalChangesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GlobalChangesDto>(<any>null);
    }

    /**
     * @param buildId (optional) 
     * @param databaseId (optional) 
     * @param mailerId (optional) 
     * @return Success
     */
    getFieldsForFindReplace(buildId: number | null | undefined, databaseId: number | null | undefined, mailerId: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetFieldsForFindReplace?";
        if (buildId !== undefined)
            url_ += "buildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (mailerId !== undefined)
            url_ += "mailerId=" + encodeURIComponent("" + mailerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFieldsForFindReplace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFieldsForFindReplace(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFieldsForFindReplace(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    saveGlobalChanges(input: SaveGlobalChangesInputDto | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/SaveGlobalChanges";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveGlobalChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveGlobalChanges(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSaveGlobalChanges(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param input (optional) 
     * @return Success
     */
    saveAdvanceSelection(campaignId: number | null | undefined, input: AdvanceSelectionsInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/SaveAdvanceSelection?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAdvanceSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAdvanceSelection(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveAdvanceSelection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param databaseId (optional) 
     * @param segmentId (optional) 
     * @param mainTableName (optional) 
     * @param addressFilter (optional) 
     * @return Success
     */
    getAddressDetails(databaseId: number | null | undefined, segmentId: number | null | undefined, mainTableName: string | null | undefined, addressFilter: string | null | undefined): Observable<AddressDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetAddressDetails?";
        if (databaseId !== undefined)
            url_ += "DatabaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (segmentId !== undefined)
            url_ += "SegmentId=" + encodeURIComponent("" + segmentId) + "&"; 
        if (mainTableName !== undefined)
            url_ += "MainTableName=" + encodeURIComponent("" + mainTableName) + "&"; 
        if (addressFilter !== undefined)
            url_ += "AddressFilter=" + encodeURIComponent("" + addressFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressDetails(<any>response_);
                } catch (e) {
                    return <Observable<AddressDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAddressDetails(response: HttpResponseBase): Observable<AddressDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AddressDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressDetailDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    saveGeoRadiusSelection(input: SaveGeoRadiusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/SaveGeoRadiusSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveGeoRadiusSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveGeoRadiusSelection(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveGeoRadiusSelection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    saveGeoMappingSelection(input: SaveGeoRadiusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/SaveGeoMappingSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveGeoMappingSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveGeoMappingSelection(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveGeoMappingSelection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selections (optional) 
     * @return Success
     */
    saveMultiFieldSelection(selections: SegmentSelectionSaveDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/SaveMultiFieldSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selections);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveMultiFieldSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveMultiFieldSelection(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveMultiFieldSelection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    getLayoutNameFromCampaignId(campaignId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetLayoutNameFromCampaignId?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLayoutNameFromCampaignId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLayoutNameFromCampaignId(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetLayoutNameFromCampaignId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param isFromSelection (optional) 
     * @return Success
     */
    createSegmentSelectionDetails(input: SegmentSelectionSaveDto | null | undefined, isFromSelection: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/CreateSegmentSelectionDetails?";
        if (isFromSelection !== undefined)
            url_ += "isFromSelection=" + encodeURIComponent("" + isFromSelection) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSegmentSelectionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSegmentSelectionDetails(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSegmentSelectionDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @return Success
     */
    getSegmentIdForOrderLevel(campaignId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetSegmentIdForOrderLevel?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSegmentIdForOrderLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSegmentIdForOrderLevel(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetSegmentIdForOrderLevel(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param segmentId (optional) 
     * @param campaignId (optional) 
     * @return Success
     */
    deleteAll(segmentId: number | null | undefined, campaignId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/DeleteAll?";
        if (segmentId !== undefined)
            url_ += "segmentId=" + encodeURIComponent("" + segmentId) + "&"; 
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isSegment (optional) 
     * @param databaseId (optional) 
     * @param buildId (optional) 
     * @param mailerId (optional) 
     * @return Success
     */
    getSelectionFieldsNew(id: number | null | undefined, isSegment: string | null | undefined, databaseId: number | null | undefined, buildId: number | null | undefined, mailerId: number | null | undefined): Observable<GetQueryBuilderDetails> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetSelectionFieldsNew?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (isSegment !== undefined)
            url_ += "isSegment=" + encodeURIComponent("" + isSegment) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (buildId !== undefined)
            url_ += "buildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (mailerId !== undefined)
            url_ += "mailerId=" + encodeURIComponent("" + mailerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSelectionFieldsNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSelectionFieldsNew(<any>response_);
                } catch (e) {
                    return <Observable<GetQueryBuilderDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetQueryBuilderDetails>><any>_observableThrow(response_);
        }));
    }

    protected processGetSelectionFieldsNew(response: HttpResponseBase): Observable<GetQueryBuilderDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetQueryBuilderDetails.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetQueryBuilderDetails>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isSegment (optional) 
     * @param databaseId (optional) 
     * @param buildId (optional) 
     * @param mailerId (optional) 
     * @return Success
     */
    getSubSelectSelections(id: number | null | undefined, isSegment: string | null | undefined, databaseId: number | null | undefined, buildId: number | null | undefined, mailerId: number | null | undefined): Observable<ColumnDefinition[]> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetSubSelectSelections?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (isSegment !== undefined)
            url_ += "isSegment=" + encodeURIComponent("" + isSegment) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (buildId !== undefined)
            url_ += "buildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (mailerId !== undefined)
            url_ += "mailerId=" + encodeURIComponent("" + mailerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubSelectSelections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubSelectSelections(<any>response_);
                } catch (e) {
                    return <Observable<ColumnDefinition[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ColumnDefinition[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubSelectSelections(response: HttpResponseBase): Observable<ColumnDefinition[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ColumnDefinition.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ColumnDefinition[]>(<any>null);
    }

    /**
     * @param fieldId (optional) 
     * @param iBuildLoLID (optional) 
     * @return Success
     */
    getFieldValues(fieldId: string | null | undefined, iBuildLoLID: number | null | undefined): Observable<ValueList[]> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetFieldValues?";
        if (fieldId !== undefined)
            url_ += "fieldId=" + encodeURIComponent("" + fieldId) + "&"; 
        if (iBuildLoLID !== undefined)
            url_ += "iBuildLoLID=" + encodeURIComponent("" + iBuildLoLID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFieldValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFieldValues(<any>response_);
                } catch (e) {
                    return <Observable<ValueList[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ValueList[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFieldValues(response: HttpResponseBase): Observable<ValueList[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ValueList.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValueList[]>(<any>null);
    }

    /**
     * @param fieldId (optional) 
     * @param iBuildLoLID (optional) 
     * @return Success
     */
    getSubSelectFieldValues(fieldId: string | null | undefined, iBuildLoLID: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetSubSelectFieldValues?";
        if (fieldId !== undefined)
            url_ += "fieldId=" + encodeURIComponent("" + fieldId) + "&"; 
        if (iBuildLoLID !== undefined)
            url_ += "iBuildLoLID=" + encodeURIComponent("" + iBuildLoLID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubSelectFieldValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubSelectFieldValues(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubSelectFieldValues(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getOperators(): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetOperators";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperators(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperators(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOperators(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param segmentId (optional) 
     * @param buildId (optional) 
     * @param databaseId (optional) 
     * @param channelType (optional) 
     * @return Success
     */
    addDefaultSelections(segmentId: number | null | undefined, buildId: number | null | undefined, databaseId: number | null | undefined, channelType: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/AddDefaultSelections?";
        if (segmentId !== undefined)
            url_ += "segmentId=" + encodeURIComponent("" + segmentId) + "&"; 
        if (buildId !== undefined)
            url_ += "buildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (databaseId !== undefined)
            url_ += "databaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (channelType !== undefined)
            url_ += "channelType=" + encodeURIComponent("" + channelType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDefaultSelections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDefaultSelections(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddDefaultSelections(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param buildId (optional) 
     * @return Success
     */
    getMainTableNameByBuildID(buildId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetMainTableNameByBuildID?";
        if (buildId !== undefined)
            url_ += "buildId=" + encodeURIComponent("" + buildId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMainTableNameByBuildID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMainTableNameByBuildID(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetMainTableNameByBuildID(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param segmentId (optional) 
     * @return Success
     */
    getNewMaxGroupId(segmentId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetNewMaxGroupId?";
        if (segmentId !== undefined)
            url_ += "segmentId=" + encodeURIComponent("" + segmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewMaxGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewMaxGroupId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetNewMaxGroupId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param databseId (optional) 
     * @return Success
     */
    getAdminEmailAddress(databseId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SegmentSelections/GetAdminEmailAddress?";
        if (databseId !== undefined)
            url_ += "databseId=" + encodeURIComponent("" + databseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminEmailAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminEmailAddress(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdminEmailAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SelectionFieldCountReportsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param selectedDatabase (optional) 
     * @param selectedcQuestionFieldName (optional) 
     * @param selectediStatus (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSelectionFieldCountReports(filter: string | null | undefined, selectedDatabase: number | null | undefined, selectedcQuestionFieldName: string | null | undefined, selectediStatus: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetSelectionFieldCountReportView> {
        let url_ = this.baseUrl + "/api/services/app/SelectionFieldCountReports/GetAllSelectionFieldCountReports?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (selectedDatabase !== undefined)
            url_ += "SelectedDatabase=" + encodeURIComponent("" + selectedDatabase) + "&"; 
        if (selectedcQuestionFieldName !== undefined)
            url_ += "SelectedcQuestionFieldName=" + encodeURIComponent("" + selectedcQuestionFieldName) + "&"; 
        if (selectediStatus !== undefined)
            url_ += "SelectediStatus=" + encodeURIComponent("" + selectediStatus) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSelectionFieldCountReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSelectionFieldCountReports(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSelectionFieldCountReportView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSelectionFieldCountReportView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSelectionFieldCountReports(response: HttpResponseBase): Observable<PagedResultDtoOfGetSelectionFieldCountReportView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSelectionFieldCountReportView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSelectionFieldCountReportView>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param cQuestionFieldName (optional) 
     * @param iStatus (optional) 
     * @param selectedDatabase (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getOrderDetails(filter: string | null | undefined, cQuestionFieldName: string | null | undefined, iStatus: number | null | undefined, selectedDatabase: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetOrderDetailsView> {
        let url_ = this.baseUrl + "/api/services/app/SelectionFieldCountReports/GetOrderDetails?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (cQuestionFieldName !== undefined)
            url_ += "cQuestionFieldName=" + encodeURIComponent("" + cQuestionFieldName) + "&"; 
        if (iStatus !== undefined)
            url_ += "iStatus=" + encodeURIComponent("" + iStatus) + "&"; 
        if (selectedDatabase !== undefined)
            url_ += "SelectedDatabase=" + encodeURIComponent("" + selectedDatabase) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderDetails(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetOrderDetailsView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetOrderDetailsView>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderDetails(response: HttpResponseBase): Observable<PagedResultDtoOfGetOrderDetailsView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetOrderDetailsView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetOrderDetailsView>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    downloadSelectionFieldCountReport(input: GetSelectionFieldCountReportInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SelectionFieldCountReports/DownloadSelectionFieldCountReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadSelectionFieldCountReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadSelectionFieldCountReport(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadSelectionFieldCountReport(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateUserSignInTokenOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class ShippedReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllShippedReports(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetShippedReportView> {
        let url_ = this.baseUrl + "/api/services/app/ShippedReport/GetAllShippedReports?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllShippedReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllShippedReports(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetShippedReportView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetShippedReportView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllShippedReports(response: HttpResponseBase): Observable<PagedResultDtoOfGetShippedReportView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetShippedReportView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetShippedReportView>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    downloadShippedReport(input: GetShippedReportInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ShippedReport/DownloadShippedReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadShippedReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadShippedReport(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadShippedReport(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class ShortSearchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getSearchHelpText(pageID: PageID): Observable<HelpText> {
        let url_ = this.baseUrl + "/api/services/app/ShortSearch/GetSearchHelpText?";
        if (pageID === undefined || pageID === null)
            throw new Error("The parameter 'pageID' must be defined and cannot be null.");
        else
            url_ += "pageID=" + encodeURIComponent("" + pageID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSearchHelpText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSearchHelpText(<any>response_);
                } catch (e) {
                    return <Observable<HelpText>><any>_observableThrow(e);
                }
            } else
                return <Observable<HelpText>><any>_observableThrow(response_);
        }));
    }

    protected processGetSearchHelpText(response: HttpResponseBase): Observable<HelpText> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HelpText.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HelpText>(<any>null);
    }
}

@Injectable()
export class SICCodeRelatedsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetSICCodeRelatedForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SICCodeRelateds/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSICCodeRelatedForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSICCodeRelatedForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSICCodeRelatedForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSICCodeRelatedForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSICCodeRelatedForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSICCodeRelatedForEdit(id: number | null | undefined): Observable<GetSICCodeRelatedForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SICCodeRelateds/GetSICCodeRelatedForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSICCodeRelatedForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSICCodeRelatedForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSICCodeRelatedForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSICCodeRelatedForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSICCodeRelatedForEdit(response: HttpResponseBase): Observable<GetSICCodeRelatedForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSICCodeRelatedForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSICCodeRelatedForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditSICCodeRelatedDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SICCodeRelateds/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SICCodeRelateds/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SICCodesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param cType (optional) 
     * @param isSortyBySICCode (optional) 
     * @return Success
     */
    getSICCode(filter: string | null | undefined, cType: string | null | undefined, isSortyBySICCode: boolean | null | undefined): Observable<TreeNode[]> {
        let url_ = this.baseUrl + "/api/services/app/SICCodes/GetSICCode?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (cType !== undefined)
            url_ += "cType=" + encodeURIComponent("" + cType) + "&"; 
        if (isSortyBySICCode !== undefined)
            url_ += "IsSortyBySICCode=" + encodeURIComponent("" + isSortyBySICCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSICCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSICCode(<any>response_);
                } catch (e) {
                    return <Observable<TreeNode[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeNode[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSICCode(response: HttpResponseBase): Observable<TreeNode[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeNode.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeNode[]>(<any>null);
    }

    /**
     * @param cSICCode (optional) 
     * @param cIndicator (optional) 
     * @return Success
     */
    getFranchiseNIndustryCode(cSICCode: string | null | undefined, cIndicator: string | null | undefined): Observable<FranchiseNIndusdustry> {
        let url_ = this.baseUrl + "/api/services/app/SICCodes/GetFranchiseNIndustryCode?";
        if (cSICCode !== undefined)
            url_ += "cSICCode=" + encodeURIComponent("" + cSICCode) + "&"; 
        if (cIndicator !== undefined)
            url_ += "cIndicator=" + encodeURIComponent("" + cIndicator) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFranchiseNIndustryCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFranchiseNIndustryCode(<any>response_);
                } catch (e) {
                    return <Observable<FranchiseNIndusdustry>><any>_observableThrow(e);
                }
            } else
                return <Observable<FranchiseNIndusdustry>><any>_observableThrow(response_);
        }));
    }

    protected processGetFranchiseNIndustryCode(response: HttpResponseBase): Observable<FranchiseNIndusdustry> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FranchiseNIndusdustry.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FranchiseNIndusdustry>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    validateSICCodes(input: ValidateSICCodesInputDto | null | undefined): Observable<SmartAddOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/SICCodes/ValidateSICCodes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateSICCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateSICCodes(<any>response_);
                } catch (e) {
                    return <Observable<SmartAddOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SmartAddOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processValidateSICCodes(response: HttpResponseBase): Observable<SmartAddOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SmartAddOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SmartAddOutputDto>(<any>null);
    }
}

@Injectable()
export class SICFranchiseCodesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetSICFranchiseCodeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SICFranchiseCodes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSICFranchiseCodeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSICFranchiseCodeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSICFranchiseCodeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSICFranchiseCodeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSICFranchiseCodeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSICFranchiseCodeForEdit(id: number | null | undefined): Observable<GetSICFranchiseCodeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SICFranchiseCodes/GetSICFranchiseCodeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSICFranchiseCodeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSICFranchiseCodeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSICFranchiseCodeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSICFranchiseCodeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSICFranchiseCodeForEdit(response: HttpResponseBase): Observable<GetSICFranchiseCodeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSICFranchiseCodeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSICFranchiseCodeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditSICFranchiseCodeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SICFranchiseCodes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SICFranchiseCodes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class StateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param databaseId (optional) 
     * @param buildId (optional) 
     * @return Success
     */
    getState(databaseId: number | null | undefined, buildId: number | null | undefined, screen: AdvanceSelectionScreen): Observable<GetStateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/State/GetState?";
        if (databaseId !== undefined)
            url_ += "DatabaseId=" + encodeURIComponent("" + databaseId) + "&"; 
        if (buildId !== undefined)
            url_ += "BuildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (screen === undefined || screen === null)
            throw new Error("The parameter 'screen' must be defined and cannot be null.");
        else
            url_ += "Screen=" + encodeURIComponent("" + screen) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetState(<any>response_);
                } catch (e) {
                    return <Observable<GetStateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetStateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetState(response: HttpResponseBase): Observable<GetStateForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetStateForViewDto>(<any>null);
    }

    /**
     * @param cStateCode (optional) 
     * @param databaseID (optional) 
     * @return Success
     */
    getCounty(cStateCode: string | null | undefined, databaseID: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/State/GetCounty?";
        if (cStateCode !== undefined)
            url_ += "cStateCode=" + encodeURIComponent("" + cStateCode) + "&"; 
        if (databaseID !== undefined)
            url_ += "databaseID=" + encodeURIComponent("" + databaseID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCounty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCounty(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCounty(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param cStateCode (optional) 
     * @param cCountyCode (optional) 
     * @param databaseID (optional) 
     * @return Success
     */
    getCity(cStateCode: string | null | undefined, cCountyCode: string | null | undefined, databaseID: number | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/State/GetCity?";
        if (cStateCode !== undefined)
            url_ += "cStateCode=" + encodeURIComponent("" + cStateCode) + "&"; 
        if (cCountyCode !== undefined)
            url_ += "cCountyCode=" + encodeURIComponent("" + cCountyCode) + "&"; 
        if (databaseID !== undefined)
            url_ += "databaseID=" + encodeURIComponent("" + databaseID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCity(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCity(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }

    /**
     * @param cStateCode (optional) 
     * @param databaseID (optional) 
     * @param city (optional) 
     * @return Success
     */
    getNeighborhood(cStateCode: string | null | undefined, databaseID: number | null | undefined, city: string | null | undefined): Observable<DropdownOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/State/GetNeighborhood?";
        if (cStateCode !== undefined)
            url_ += "cStateCode=" + encodeURIComponent("" + cStateCode) + "&"; 
        if (databaseID !== undefined)
            url_ += "databaseID=" + encodeURIComponent("" + databaseID) + "&"; 
        if (city !== undefined)
            url_ += "city=" + encodeURIComponent("" + city) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNeighborhood(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNeighborhood(<any>response_);
                } catch (e) {
                    return <Observable<DropdownOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DropdownOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNeighborhood(response: HttpResponseBase): Observable<DropdownOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DropdownOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DropdownOutputDto[]>(<any>null);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    confirmPayment(input: StripeConfirmPaymentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/ConfirmPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createSubscription(input: StripeCreateSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateSubscription(input: StripeUpdateSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<StripeConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripeConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripeConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeConfigurationDto>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SubSelectListsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param subSelectId (optional) 
     * @return Success
     */
    getSubSelectSourcesForEdit(subSelectId: number | null | undefined): Observable<GetSubSelectSourcesForView[]> {
        let url_ = this.baseUrl + "/api/services/app/SubSelectLists/GetSubSelectSourcesForEdit?";
        if (subSelectId !== undefined)
            url_ += "subSelectId=" + encodeURIComponent("" + subSelectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubSelectSourcesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubSelectSourcesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSubSelectSourcesForView[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSubSelectSourcesForView[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubSelectSourcesForEdit(response: HttpResponseBase): Observable<GetSubSelectSourcesForView[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetSubSelectSourcesForView.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSubSelectSourcesForView[]>(<any>null);
    }
}

@Injectable()
export class SubSelectsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param segmentId (optional) 
     * @return Success
     */
    getAllSubSelect(segmentId: number | null | undefined): Observable<SubSelectForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SubSelects/GetAllSubSelect?";
        if (segmentId !== undefined)
            url_ += "segmentId=" + encodeURIComponent("" + segmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubSelect(<any>response_);
                } catch (e) {
                    return <Observable<SubSelectForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubSelectForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubSelect(response: HttpResponseBase): Observable<SubSelectForViewDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubSelectForViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubSelectForViewDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createSubSelect(input: CreateOrEditSubSelectDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SubSelects/CreateSubSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubSelect(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubSelect(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateSubSelect(input: CreateOrEditSubSelectDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SubSelects/UpdateSubSelect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubSelect(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubSelect(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param campaignId (optional) 
     * @param subSelectId (optional) 
     * @return Success
     */
    deleteSubSelect(campaignId: number | null | undefined, subSelectId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SubSelects/DeleteSubSelect?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (subSelectId !== undefined)
            url_ += "subSelectId=" + encodeURIComponent("" + subSelectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSubSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSubSelect(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSubSelect(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SubSelectSelectionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param iSubSelectID (optional) 
     * @param segmentId (optional) 
     * @param buildId (optional) 
     * @param isSegment (optional) 
     * @param subSelectcIncludeExcludeFilter (optional) 
     * @return Success
     */
    getAllSubSelectSelections(iSubSelectID: number | null | undefined, segmentId: number | null | undefined, buildId: number | null | undefined, isSegment: string | null | undefined, subSelectcIncludeExcludeFilter: string | null | undefined): Observable<SubSelectSelectionsDetailsDto> {
        let url_ = this.baseUrl + "/api/services/app/SubSelectSelections/GetAllSubSelectSelections?";
        if (iSubSelectID !== undefined)
            url_ += "iSubSelectID=" + encodeURIComponent("" + iSubSelectID) + "&"; 
        if (segmentId !== undefined)
            url_ += "SegmentId=" + encodeURIComponent("" + segmentId) + "&"; 
        if (buildId !== undefined)
            url_ += "BuildId=" + encodeURIComponent("" + buildId) + "&"; 
        if (isSegment !== undefined)
            url_ += "isSegment=" + encodeURIComponent("" + isSegment) + "&"; 
        if (subSelectcIncludeExcludeFilter !== undefined)
            url_ += "SubSelectcIncludeExcludeFilter=" + encodeURIComponent("" + subSelectcIncludeExcludeFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubSelectSelections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubSelectSelections(<any>response_);
                } catch (e) {
                    return <Observable<SubSelectSelectionsDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubSelectSelectionsDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubSelectSelections(response: HttpResponseBase): Observable<SubSelectSelectionsDetailsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubSelectSelectionsDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubSelectSelectionsDetailsDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEditSubSelectSelection(input: SubSelectSelectionsDTO | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SubSelectSelections/CreateOrEditSubSelectSelection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditSubSelectSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditSubSelectSelection(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditSubSelectSelection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param subSelectSelectionId (optional) 
     * @param addedFilterId (optional) 
     * @param campaignId (optional) 
     * @return Success
     */
    deleteSubSelectSelection(subSelectSelectionId: number | null | undefined, addedFilterId: number | null | undefined, campaignId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SubSelectSelections/DeleteSubSelectSelection?";
        if (subSelectSelectionId !== undefined)
            url_ += "subSelectSelectionId=" + encodeURIComponent("" + subSelectSelectionId) + "&"; 
        if (addedFilterId !== undefined)
            url_ += "addedFilterId=" + encodeURIComponent("" + addedFilterId) + "&"; 
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSubSelectSelection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSubSelectSelection(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSubSelectSelection(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SysSendMailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetSysSendMailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SysSendMails/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSysSendMailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSysSendMailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSysSendMailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSysSendMailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSysSendMailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSysSendMailForEdit(id: number | null | undefined): Observable<GetSysSendMailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SysSendMails/GetSysSendMailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSysSendMailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSysSendMailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSysSendMailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSysSendMailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSysSendMailForEdit(response: HttpResponseBase): Observable<GetSysSendMailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSysSendMailForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSysSendMailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditSysSendMailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SysSendMails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SysSendMails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, subscriptionEndDateStart: moment.Moment | null | undefined, subscriptionEndDateEnd: moment.Moment | null | undefined, creationDateStart: moment.Moment | null | undefined, creationDateEnd: moment.Moment | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&"; 
        if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&"; 
        if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTenantListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createTenant(input: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | null | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTenant(input: TenantEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | null | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTenantFeaturesEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTenantFeatures(input: UpdateTenantFeaturesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlockTenantAdmin(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMemberActivityOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDashboardDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSalesSummaryOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(<any>response_);
                } catch (e) {
                    return <Observable<GetRegionalStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRegionalStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRegionalStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(<any>response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeneralStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    registerTenant(input: RegisterTenantInput | null | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterTenantOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionsSelectOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionsSelectOutput>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | null | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(<any>response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: TenantSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | null | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<RefreshTokenResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RefreshTokenResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RefreshTokenResult>(<any>null);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(model: SendTwoFactorAuthCodeModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchedAccountAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&"; 
        if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<ThemeSettingsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThemeSettingsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThemeSettingsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThemeSettingsDto[]>(<any>null);
    }

    /**
     * @param themeName (optional) 
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName !== undefined)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param settings (optional) 
     * @return Success
     */
    updateUiManagementSettings(settings: ThemeSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param settings (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(settings: ThemeSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string | null | undefined, permissions: string[] | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getUsersToExcel(filter: string | null | undefined, permissions: string[] | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | null | undefined, sorting: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | null | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPermissionsForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateUserPermissions(input: UpdateUserPermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateUser(input: CreateOrUpdateUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlockUser(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param objUserLoginAttempt (optional) 
     * @return Success
     */
    insertUserLoginAttempt(objUserLoginAttempt: UserLoginAttempt | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/InsertUserLoginAttempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(objUserLoginAttempt);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUserLoginAttempt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUserLoginAttempt(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUserLoginAttempt(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserAccessObjectsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param iDMSUsercUserIDFilter (optional) 
     * @param accessObjectcCodeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, iDMSUsercUserIDFilter: string | null | undefined, accessObjectcCodeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUserAccessObjectForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UserAccessObjects/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (iDMSUsercUserIDFilter !== undefined)
            url_ += "IDMSUsercUserIDFilter=" + encodeURIComponent("" + iDMSUsercUserIDFilter) + "&"; 
        if (accessObjectcCodeFilter !== undefined)
            url_ += "AccessObjectcCodeFilter=" + encodeURIComponent("" + accessObjectcCodeFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUserAccessObjectForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUserAccessObjectForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetUserAccessObjectForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUserAccessObjectForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUserAccessObjectForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserAccessObjectForEdit(id: number | null | undefined): Observable<GetUserAccessObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/UserAccessObjects/GetUserAccessObjectForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAccessObjectForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAccessObjectForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserAccessObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserAccessObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserAccessObjectForEdit(response: HttpResponseBase): Observable<GetUserAccessObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserAccessObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserAccessObjectForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditUserAccessObjectDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserAccessObjects/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserAccessObjects/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllIDMSUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserAccessObjectIDMSUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UserAccessObjects/GetAllIDMSUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIDMSUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIDMSUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserAccessObjectIDMSUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserAccessObjectIDMSUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIDMSUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUserAccessObjectIDMSUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserAccessObjectIDMSUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserAccessObjectIDMSUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAccessObjectForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserAccessObjectAccessObjectLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UserAccessObjects/GetAllAccessObjectForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccessObjectForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccessObjectForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserAccessObjectAccessObjectLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserAccessObjectAccessObjectLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAccessObjectForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUserAccessObjectAccessObjectLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserAccessObjectAccessObjectLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserAccessObjectAccessObjectLookupTableDto>(<any>null);
    }
}

@Injectable()
export class UserDatabaseAccessObjectsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param iDMSUsercFirstNameFilter (optional) 
     * @param accessObjectcCodeFilter (optional) 
     * @param databasecDatabaseNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, iDMSUsercFirstNameFilter: string | null | undefined, accessObjectcCodeFilter: string | null | undefined, databasecDatabaseNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUserDatabaseAccessObjectForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDatabaseAccessObjects/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (iDMSUsercFirstNameFilter !== undefined)
            url_ += "IDMSUsercFirstNameFilter=" + encodeURIComponent("" + iDMSUsercFirstNameFilter) + "&"; 
        if (accessObjectcCodeFilter !== undefined)
            url_ += "AccessObjectcCodeFilter=" + encodeURIComponent("" + accessObjectcCodeFilter) + "&"; 
        if (databasecDatabaseNameFilter !== undefined)
            url_ += "DatabasecDatabaseNameFilter=" + encodeURIComponent("" + databasecDatabaseNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUserDatabaseAccessObjectForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUserDatabaseAccessObjectForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetUserDatabaseAccessObjectForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUserDatabaseAccessObjectForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUserDatabaseAccessObjectForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserDatabaseAccessObjectForEdit(id: number | null | undefined): Observable<GetUserDatabaseAccessObjectForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/UserDatabaseAccessObjects/GetUserDatabaseAccessObjectForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDatabaseAccessObjectForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDatabaseAccessObjectForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserDatabaseAccessObjectForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserDatabaseAccessObjectForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDatabaseAccessObjectForEdit(response: HttpResponseBase): Observable<GetUserDatabaseAccessObjectForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserDatabaseAccessObjectForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserDatabaseAccessObjectForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditUserDatabaseAccessObjectDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDatabaseAccessObjects/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDatabaseAccessObjects/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllIDMSUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDatabaseAccessObjectIDMSUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDatabaseAccessObjects/GetAllIDMSUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIDMSUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIDMSUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDatabaseAccessObjectIDMSUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDatabaseAccessObjectIDMSUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIDMSUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUserDatabaseAccessObjectIDMSUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDatabaseAccessObjectIDMSUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDatabaseAccessObjectIDMSUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAccessObjectForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDatabaseAccessObjectAccessObjectLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDatabaseAccessObjects/GetAllAccessObjectForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccessObjectForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccessObjectForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDatabaseAccessObjectAccessObjectLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDatabaseAccessObjectAccessObjectLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAccessObjectForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUserDatabaseAccessObjectAccessObjectLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDatabaseAccessObjectAccessObjectLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDatabaseAccessObjectAccessObjectLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDatabaseForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDatabaseAccessObjectDatabaseLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDatabaseAccessObjects/GetAllDatabaseForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDatabaseForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDatabaseForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDatabaseAccessObjectDatabaseLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDatabaseAccessObjectDatabaseLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDatabaseForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUserDatabaseAccessObjectDatabaseLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDatabaseAccessObjectDatabaseLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDatabaseAccessObjectDatabaseLookupTableDto>(<any>null);
    }
}

@Injectable()
export class UserDatabasesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param userNameFilter (optional) 
     * @param databasecDatabaseNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, userNameFilter: string | null | undefined, databasecDatabaseNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUserDatabaseForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDatabases/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (databasecDatabaseNameFilter !== undefined)
            url_ += "DatabasecDatabaseNameFilter=" + encodeURIComponent("" + databasecDatabaseNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUserDatabaseForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUserDatabaseForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetUserDatabaseForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUserDatabaseForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUserDatabaseForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserDatabaseForEdit(id: number | null | undefined): Observable<GetUserDatabaseForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/UserDatabases/GetUserDatabaseForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDatabaseForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDatabaseForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserDatabaseForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserDatabaseForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDatabaseForEdit(response: HttpResponseBase): Observable<GetUserDatabaseForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserDatabaseForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserDatabaseForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditUserDatabaseDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDatabases/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDatabases/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDatabaseUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDatabases/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDatabaseUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDatabaseUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUserDatabaseUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDatabaseUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDatabaseUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDatabaseForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDatabaseDatabaseLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDatabases/GetAllDatabaseForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDatabaseForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDatabaseForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDatabaseDatabaseLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDatabaseDatabaseLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDatabaseForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUserDatabaseDatabaseLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDatabaseDatabaseLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDatabaseDatabaseLookupTableDto>(<any>null);
    }
}

@Injectable()
export class UserDivisionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param tblUsercFirstNameFilter (optional) 
     * @param divisioncDivisionNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, tblUsercFirstNameFilter: string | null | undefined, divisioncDivisionNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUserDivisionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDivisions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tblUsercFirstNameFilter !== undefined)
            url_ += "tblUsercFirstNameFilter=" + encodeURIComponent("" + tblUsercFirstNameFilter) + "&"; 
        if (divisioncDivisionNameFilter !== undefined)
            url_ += "DivisioncDivisionNameFilter=" + encodeURIComponent("" + divisioncDivisionNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUserDivisionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUserDivisionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetUserDivisionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUserDivisionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUserDivisionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserDivisionForEdit(id: number | null | undefined): Observable<GetUserDivisionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/UserDivisions/GetUserDivisionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDivisionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDivisionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserDivisionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserDivisionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDivisionForEdit(response: HttpResponseBase): Observable<GetUserDivisionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserDivisionForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserDivisionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditUserDivisionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDivisions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDivisions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAlltblUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDivisiontblUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDivisions/GetAlltblUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAlltblUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAlltblUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDivisiontblUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDivisiontblUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAlltblUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUserDivisiontblUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDivisiontblUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDivisiontblUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDivisionForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDivisionDivisionLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDivisions/GetAllDivisionForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDivisionForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDivisionForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDivisionDivisionLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDivisionDivisionLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDivisionForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUserDivisionDivisionLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDivisionDivisionLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDivisionDivisionLookupTableDto>(<any>null);
    }
}

@Injectable()
export class UserGroupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param tblUsercFirstNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, tblUsercFirstNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUserGroupForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UserGroups/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tblUsercFirstNameFilter !== undefined)
            url_ += "TblUsercFirstNameFilter=" + encodeURIComponent("" + tblUsercFirstNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUserGroupForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUserGroupForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetUserGroupForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUserGroupForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUserGroupForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserGroupForEdit(id: number | null | undefined): Observable<GetUserGroupForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/UserGroups/GetUserGroupForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserGroupForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserGroupForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserGroupForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserGroupForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserGroupForEdit(response: HttpResponseBase): Observable<GetUserGroupForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserGroupForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserGroupForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditUserGroupDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserGroups/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserGroups/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTblUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserGroupTblUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UserGroups/GetAllTblUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTblUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTblUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserGroupTblUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserGroupTblUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTblUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUserGroupTblUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserGroupTblUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserGroupTblUserLookupTableDto>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    linkToUser(input: LinkToUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlinkUser(input: UnlinkUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class UserReportsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxIDFilter (optional) 
     * @param minIDFilter (optional) 
     * @param maxReportIDFilter (optional) 
     * @param minReportIDFilter (optional) 
     * @param tBlUserIDFIlter (optional) 
     * @param tblUsercFirstNameFilter (optional) 
     * @param reportcReportNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxIDFilter: number | null | undefined, minIDFilter: number | null | undefined, maxReportIDFilter: number | null | undefined, minReportIDFilter: number | null | undefined, tBlUserIDFIlter: string | null | undefined, tblUsercFirstNameFilter: string | null | undefined, reportcReportNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUserReportForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UserReports/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxIDFilter !== undefined)
            url_ += "MaxIDFilter=" + encodeURIComponent("" + maxIDFilter) + "&"; 
        if (minIDFilter !== undefined)
            url_ += "MinIDFilter=" + encodeURIComponent("" + minIDFilter) + "&"; 
        if (maxReportIDFilter !== undefined)
            url_ += "MaxReportIDFilter=" + encodeURIComponent("" + maxReportIDFilter) + "&"; 
        if (minReportIDFilter !== undefined)
            url_ += "MinReportIDFilter=" + encodeURIComponent("" + minReportIDFilter) + "&"; 
        if (tBlUserIDFIlter !== undefined)
            url_ += "TBlUserIDFIlter=" + encodeURIComponent("" + tBlUserIDFIlter) + "&"; 
        if (tblUsercFirstNameFilter !== undefined)
            url_ += "TblUsercFirstNameFilter=" + encodeURIComponent("" + tblUsercFirstNameFilter) + "&"; 
        if (reportcReportNameFilter !== undefined)
            url_ += "ReportcReportNameFilter=" + encodeURIComponent("" + reportcReportNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUserReportForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUserReportForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetUserReportForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUserReportForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUserReportForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserReportForEdit(id: number | null | undefined): Observable<GetUserReportForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/UserReports/GetUserReportForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserReportForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserReportForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserReportForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserReportForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserReportForEdit(response: HttpResponseBase): Observable<GetUserReportForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserReportForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserReportForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditUserReportDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserReports/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserReports/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTblUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserReportTblUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UserReports/GetAllTblUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTblUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTblUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserReportTblUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserReportTblUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTblUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUserReportTblUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserReportTblUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserReportTblUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllReportForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserReportReportLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UserReports/GetAllReportForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllReportForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllReportForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserReportReportLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserReportReportLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllReportForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUserReportReportLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserReportReportLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserReportReportLookupTableDto>(<any>null);
    }
}

@Injectable()
export class UserSavedSelectionDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param userSavedSelectioncDescriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, userSavedSelectioncDescriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUserSavedSelectionDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UserSavedSelectionDetails/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (userSavedSelectioncDescriptionFilter !== undefined)
            url_ += "UserSavedSelectioncDescriptionFilter=" + encodeURIComponent("" + userSavedSelectioncDescriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUserSavedSelectionDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUserSavedSelectionDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetUserSavedSelectionDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUserSavedSelectionDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUserSavedSelectionDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserSavedSelectionDetailForEdit(id: number | null | undefined): Observable<GetUserSavedSelectionDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/UserSavedSelectionDetails/GetUserSavedSelectionDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserSavedSelectionDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserSavedSelectionDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserSavedSelectionDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserSavedSelectionDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserSavedSelectionDetailForEdit(response: HttpResponseBase): Observable<GetUserSavedSelectionDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserSavedSelectionDetailForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserSavedSelectionDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditUserSavedSelectionDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserSavedSelectionDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserSavedSelectionDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserSavedSelectionForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserSavedSelectionDetailUserSavedSelectionLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UserSavedSelectionDetails/GetAllUserSavedSelectionForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserSavedSelectionForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserSavedSelectionForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserSavedSelectionDetailUserSavedSelectionLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserSavedSelectionDetailUserSavedSelectionLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserSavedSelectionForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUserSavedSelectionDetailUserSavedSelectionLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserSavedSelectionDetailUserSavedSelectionLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserSavedSelectionDetailUserSavedSelectionLookupTableDto>(<any>null);
    }
}

@Injectable()
export class UserSavedSelectionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param sourceSegment (optional) 
     * @param input (optional) 
     * @return Success
     */
    create(sourceSegment: number | null | undefined, input: CreateOrEditUserSavedSelectionDto | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/UserSavedSelections/Create?";
        if (sourceSegment !== undefined)
            url_ += "sourceSegment=" + encodeURIComponent("" + sourceSegment) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLatestWebLogsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

export class PagedResultDtoOfGetAccessObjectForViewDto implements IPagedResultDtoOfGetAccessObjectForViewDto {
    totalCount!: number | undefined;
    items!: GetAccessObjectForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAccessObjectForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAccessObjectForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAccessObjectForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAccessObjectForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAccessObjectForViewDto {
    totalCount: number | undefined;
    items: GetAccessObjectForViewDto[] | undefined;
}

export class GetAccessObjectForViewDto implements IGetAccessObjectForViewDto {
    accessObject!: AccessObjectDto | undefined;

    constructor(data?: IGetAccessObjectForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessObject = data["accessObject"] ? AccessObjectDto.fromJS(data["accessObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAccessObjectForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccessObjectForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessObject"] = this.accessObject ? this.accessObject.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAccessObjectForViewDto {
    accessObject: AccessObjectDto | undefined;
}

export class AccessObjectDto implements IAccessObjectDto {
    id!: number | undefined;

    constructor(data?: IAccessObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AccessObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccessObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IAccessObjectDto {
    id: number | undefined;
}

export class GetAccessObjectForEditOutput implements IGetAccessObjectForEditOutput {
    accessObject!: CreateOrEditAccessObjectDto | undefined;

    constructor(data?: IGetAccessObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessObject = data["accessObject"] ? CreateOrEditAccessObjectDto.fromJS(data["accessObject"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAccessObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccessObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessObject"] = this.accessObject ? this.accessObject.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAccessObjectForEditOutput {
    accessObject: CreateOrEditAccessObjectDto | undefined;
}

export class CreateOrEditAccessObjectDto implements ICreateOrEditAccessObjectDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditAccessObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAccessObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAccessObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAccessObjectDto {
    id: number | undefined;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState | undefined;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export enum TenantAvailabilityState {
    Available = 1,
    InActive = 2,
    NotFound = 3,
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number | undefined;
    resetCode!: string | undefined;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data; 
    }
}

export interface IResetPasswordInput {
    userId: number | undefined;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean | undefined;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number | undefined;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }
}

export interface IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number | undefined;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number | undefined;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: moment.Moment | undefined;
    executionDuration!: number | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    itShouldDelete!: boolean | undefined;
    isAWS!: boolean | undefined;
    fileToken!: string;
    downloadedFileName!: string | undefined;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.itShouldDelete = data["itShouldDelete"];
            this.isAWS = data["isAWS"];
            this.fileToken = data["fileToken"];
            this.downloadedFileName = data["downloadedFileName"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["itShouldDelete"] = this.itShouldDelete;
        data["isAWS"] = this.isAWS;
        data["fileToken"] = this.fileToken;
        data["downloadedFileName"] = this.downloadedFileName;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    itShouldDelete: boolean | undefined;
    isAWS: boolean | undefined;
    fileToken: string;
    downloadedFileName: string | undefined;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number | undefined;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: moment.Moment | undefined;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType | undefined;
    readonly changeTypeName!: string | undefined;
    entityChangeSetId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            (<any>this).changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;
}

export enum EntityChangeType {
    Created = 0,
    Updated = 1,
    Deleted = 2,
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number | undefined;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetAutoSuppressForViewDto implements IPagedResultDtoOfGetAutoSuppressForViewDto {
    totalCount!: number | undefined;
    items!: GetAutoSuppressForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAutoSuppressForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAutoSuppressForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAutoSuppressForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAutoSuppressForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAutoSuppressForViewDto {
    totalCount: number | undefined;
    items: GetAutoSuppressForViewDto[] | undefined;
}

export class GetAutoSuppressForViewDto implements IGetAutoSuppressForViewDto {
    autoSuppress!: AutoSuppressDto | undefined;
    databasecDatabaseName!: string | undefined;

    constructor(data?: IGetAutoSuppressForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.autoSuppress = data["autoSuppress"] ? AutoSuppressDto.fromJS(data["autoSuppress"]) : <any>undefined;
            this.databasecDatabaseName = data["databasecDatabaseName"];
        }
    }

    static fromJS(data: any): GetAutoSuppressForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAutoSuppressForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoSuppress"] = this.autoSuppress ? this.autoSuppress.toJSON() : <any>undefined;
        data["databasecDatabaseName"] = this.databasecDatabaseName;
        return data; 
    }
}

export interface IGetAutoSuppressForViewDto {
    autoSuppress: AutoSuppressDto | undefined;
    databasecDatabaseName: string | undefined;
}

export class AutoSuppressDto implements IAutoSuppressDto {
    databaseId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IAutoSuppressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseId = data["databaseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AutoSuppressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AutoSuppressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseId"] = this.databaseId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAutoSuppressDto {
    databaseId: number | undefined;
    id: string | undefined;
}

export class GetAutoSuppressForEditOutput implements IGetAutoSuppressForEditOutput {
    autoSuppress!: CreateOrEditAutoSuppressDto | undefined;
    databasecDatabaseName!: string | undefined;

    constructor(data?: IGetAutoSuppressForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.autoSuppress = data["autoSuppress"] ? CreateOrEditAutoSuppressDto.fromJS(data["autoSuppress"]) : <any>undefined;
            this.databasecDatabaseName = data["databasecDatabaseName"];
        }
    }

    static fromJS(data: any): GetAutoSuppressForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAutoSuppressForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoSuppress"] = this.autoSuppress ? this.autoSuppress.toJSON() : <any>undefined;
        data["databasecDatabaseName"] = this.databasecDatabaseName;
        return data; 
    }
}

export interface IGetAutoSuppressForEditOutput {
    autoSuppress: CreateOrEditAutoSuppressDto | undefined;
    databasecDatabaseName: string | undefined;
}

export class CreateOrEditAutoSuppressDto implements ICreateOrEditAutoSuppressDto {
    databaseId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditAutoSuppressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseId = data["databaseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAutoSuppressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAutoSuppressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseId"] = this.databaseId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAutoSuppressDto {
    databaseId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfAutoSuppressDatabaseLookupTableDto implements IPagedResultDtoOfAutoSuppressDatabaseLookupTableDto {
    totalCount!: number | undefined;
    items!: AutoSuppressDatabaseLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAutoSuppressDatabaseLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AutoSuppressDatabaseLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAutoSuppressDatabaseLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAutoSuppressDatabaseLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAutoSuppressDatabaseLookupTableDto {
    totalCount: number | undefined;
    items: AutoSuppressDatabaseLookupTableDto[] | undefined;
}

export class AutoSuppressDatabaseLookupTableDto implements IAutoSuppressDatabaseLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAutoSuppressDatabaseLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AutoSuppressDatabaseLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AutoSuppressDatabaseLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAutoSuppressDatabaseLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfBatchQueueDto implements IPagedResultDtoOfBatchQueueDto {
    totalCount!: number | undefined;
    items!: BatchQueueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBatchQueueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BatchQueueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBatchQueueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBatchQueueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBatchQueueDto {
    totalCount: number | undefined;
    items: BatchQueueDto[] | undefined;
}

export class BatchQueueDto implements IBatchQueueDto {
    id!: number | undefined;
    iStatusId!: number | undefined;
    fieldName!: string | undefined;
    parmData!: string | undefined;
    cScheduleBy!: string | undefined;
    dScheduled!: moment.Moment | undefined;
    buildDescription!: string | undefined;
    processTypeDescription!: string | undefined;
    processTypeId!: number | undefined;
    dataBaseName!: string | undefined;
    statusDescription!: string | undefined;
    result!: string | undefined;
    duration!: string | undefined;

    constructor(data?: IBatchQueueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.iStatusId = data["iStatusId"];
            this.fieldName = data["fieldName"];
            this.parmData = data["parmData"];
            this.cScheduleBy = data["cScheduleBy"];
            this.dScheduled = data["dScheduled"] ? moment(data["dScheduled"].toString()) : <any>undefined;
            this.buildDescription = data["buildDescription"];
            this.processTypeDescription = data["processTypeDescription"];
            this.processTypeId = data["processTypeId"];
            this.dataBaseName = data["dataBaseName"];
            this.statusDescription = data["statusDescription"];
            this.result = data["result"];
            this.duration = data["duration"];
        }
    }

    static fromJS(data: any): BatchQueueDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatchQueueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["iStatusId"] = this.iStatusId;
        data["fieldName"] = this.fieldName;
        data["parmData"] = this.parmData;
        data["cScheduleBy"] = this.cScheduleBy;
        data["dScheduled"] = this.dScheduled ? this.dScheduled.toISOString() : <any>undefined;
        data["buildDescription"] = this.buildDescription;
        data["processTypeDescription"] = this.processTypeDescription;
        data["processTypeId"] = this.processTypeId;
        data["dataBaseName"] = this.dataBaseName;
        data["statusDescription"] = this.statusDescription;
        data["result"] = this.result;
        data["duration"] = this.duration;
        return data; 
    }
}

export interface IBatchQueueDto {
    id: number | undefined;
    iStatusId: number | undefined;
    fieldName: string | undefined;
    parmData: string | undefined;
    cScheduleBy: string | undefined;
    dScheduled: moment.Moment | undefined;
    buildDescription: string | undefined;
    processTypeDescription: string | undefined;
    processTypeId: number | undefined;
    dataBaseName: string | undefined;
    statusDescription: string | undefined;
    result: string | undefined;
    duration: string | undefined;
}

export class CreateOrEditBatchQueueDto implements ICreateOrEditBatchQueueDto {
    iStatusId!: number | undefined;
    processTypeDescription!: string | undefined;
    processTypeId!: number | undefined;
    result!: string | undefined;
    dEndDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBatchQueueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.iStatusId = data["iStatusId"];
            this.processTypeDescription = data["processTypeDescription"];
            this.processTypeId = data["processTypeId"];
            this.result = data["result"];
            this.dEndDate = data["dEndDate"] ? moment(data["dEndDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBatchQueueDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBatchQueueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iStatusId"] = this.iStatusId;
        data["processTypeDescription"] = this.processTypeDescription;
        data["processTypeId"] = this.processTypeId;
        data["result"] = this.result;
        data["dEndDate"] = this.dEndDate ? this.dEndDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBatchQueueDto {
    iStatusId: number | undefined;
    processTypeDescription: string | undefined;
    processTypeId: number | undefined;
    result: string | undefined;
    dEndDate: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfBrokersDto implements IPagedResultDtoOfBrokersDto {
    totalCount!: number | undefined;
    items!: BrokersDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBrokersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BrokersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBrokersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBrokersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBrokersDto {
    totalCount: number | undefined;
    items: BrokersDto[] | undefined;
}

export class BrokersDto implements IBrokersDto {
    databaseID!: number | undefined;
    cCode!: string | undefined;
    cCompany!: string | undefined;
    cAddress1!: string | undefined;
    cAddress2!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cZip!: string | undefined;
    cPhone!: string | undefined;
    cFax!: string | undefined;
    cNotes!: string | undefined;
    iIsActive!: boolean | undefined;
    cAddress!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    contactsCount!: number | undefined;
    contactsList!: CreateOrEditContactDto[] | undefined;
    id!: number | undefined;

    constructor(data?: IBrokersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseID = data["databaseID"];
            this.cCode = data["cCode"];
            this.cCompany = data["cCompany"];
            this.cAddress1 = data["cAddress1"];
            this.cAddress2 = data["cAddress2"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cZip = data["cZip"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            this.cNotes = data["cNotes"];
            this.iIsActive = data["iIsActive"];
            this.cAddress = data["cAddress"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.contactsCount = data["contactsCount"];
            if (Array.isArray(data["contactsList"])) {
                this.contactsList = [] as any;
                for (let item of data["contactsList"])
                    this.contactsList!.push(CreateOrEditContactDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BrokersDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrokersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseID"] = this.databaseID;
        data["cCode"] = this.cCode;
        data["cCompany"] = this.cCompany;
        data["cAddress1"] = this.cAddress1;
        data["cAddress2"] = this.cAddress2;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cZip"] = this.cZip;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        data["cNotes"] = this.cNotes;
        data["iIsActive"] = this.iIsActive;
        data["cAddress"] = this.cAddress;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["contactsCount"] = this.contactsCount;
        if (Array.isArray(this.contactsList)) {
            data["contactsList"] = [];
            for (let item of this.contactsList)
                data["contactsList"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IBrokersDto {
    databaseID: number | undefined;
    cCode: string | undefined;
    cCompany: string | undefined;
    cAddress1: string | undefined;
    cAddress2: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cZip: string | undefined;
    cPhone: string | undefined;
    cFax: string | undefined;
    cNotes: string | undefined;
    iIsActive: boolean | undefined;
    cAddress: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    contactsCount: number | undefined;
    contactsList: CreateOrEditContactDto[] | undefined;
    id: number | undefined;
}

export class CreateOrEditContactDto implements ICreateOrEditContactDto {
    contactID!: number | undefined;
    cCompany!: string | undefined;
    cFirstName!: string | undefined;
    cLastName!: string | undefined;
    cTitle!: string | undefined;
    cAddress1!: string | undefined;
    cAddress2!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cZIP!: string | undefined;
    cPhone1!: string | undefined;
    cPhone2!: string | undefined;
    cFax!: string | undefined;
    cEmailAddress!: string | undefined;
    iIsActive!: boolean | undefined;
    cType!: string | undefined;
    cCreatedBy!: string | undefined;
    cModifiedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    dModifiedDate!: moment.Moment | undefined;
    contactType!: ContactType | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactID = data["contactID"];
            this.cCompany = data["cCompany"];
            this.cFirstName = data["cFirstName"];
            this.cLastName = data["cLastName"];
            this.cTitle = data["cTitle"];
            this.cAddress1 = data["cAddress1"];
            this.cAddress2 = data["cAddress2"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cZIP = data["cZIP"];
            this.cPhone1 = data["cPhone1"];
            this.cPhone2 = data["cPhone2"];
            this.cFax = data["cFax"];
            this.cEmailAddress = data["cEmailAddress"];
            this.iIsActive = data["iIsActive"];
            this.cType = data["cType"];
            this.cCreatedBy = data["cCreatedBy"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.contactType = data["contactType"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactID"] = this.contactID;
        data["cCompany"] = this.cCompany;
        data["cFirstName"] = this.cFirstName;
        data["cLastName"] = this.cLastName;
        data["cTitle"] = this.cTitle;
        data["cAddress1"] = this.cAddress1;
        data["cAddress2"] = this.cAddress2;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cZIP"] = this.cZIP;
        data["cPhone1"] = this.cPhone1;
        data["cPhone2"] = this.cPhone2;
        data["cFax"] = this.cFax;
        data["cEmailAddress"] = this.cEmailAddress;
        data["iIsActive"] = this.iIsActive;
        data["cType"] = this.cType;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["contactType"] = this.contactType;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditContactDto {
    contactID: number | undefined;
    cCompany: string | undefined;
    cFirstName: string | undefined;
    cLastName: string | undefined;
    cTitle: string | undefined;
    cAddress1: string | undefined;
    cAddress2: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cZIP: string | undefined;
    cPhone1: string | undefined;
    cPhone2: string | undefined;
    cFax: string | undefined;
    cEmailAddress: string | undefined;
    iIsActive: boolean | undefined;
    cType: string | undefined;
    cCreatedBy: string | undefined;
    cModifiedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    dModifiedDate: moment.Moment | undefined;
    contactType: ContactType | undefined;
    id: number | undefined;
}

export enum ContactType {
    Mailer = 1,
    Owner = 2,
    Manager = 3,
    ShipTo = 4,
    Broker = 5,
    Decoy = 6,
}

export class CreateOrEditBrokerDto implements ICreateOrEditBrokerDto {
    databaseID!: number | undefined;
    cCode!: string | undefined;
    cCompany!: string | undefined;
    cAddress1!: string | undefined;
    cAddress2!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cZip!: string | undefined;
    cPhone!: string | undefined;
    cFax!: string | undefined;
    cNotes!: string | undefined;
    iIsActive!: boolean | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBrokerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseID = data["databaseID"];
            this.cCode = data["cCode"];
            this.cCompany = data["cCompany"];
            this.cAddress1 = data["cAddress1"];
            this.cAddress2 = data["cAddress2"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cZip = data["cZip"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            this.cNotes = data["cNotes"];
            this.iIsActive = data["iIsActive"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBrokerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBrokerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseID"] = this.databaseID;
        data["cCode"] = this.cCode;
        data["cCompany"] = this.cCompany;
        data["cAddress1"] = this.cAddress1;
        data["cAddress2"] = this.cAddress2;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cZip"] = this.cZip;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        data["cNotes"] = this.cNotes;
        data["iIsActive"] = this.iIsActive;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBrokerDto {
    databaseID: number | undefined;
    cCode: string | undefined;
    cCompany: string | undefined;
    cAddress1: string | undefined;
    cAddress2: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cZip: string | undefined;
    cPhone: string | undefined;
    cFax: string | undefined;
    cNotes: string | undefined;
    iIsActive: boolean | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    id: number | undefined;
}

export class GetAllBrokersInput implements IGetAllBrokersInput {
    filter!: string | undefined;
    iIsActiveFilter!: number | undefined;
    selectedDatabase!: number | undefined;
    contactLastNameFilterText!: string | undefined;
    contactEmailFilterText!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IGetAllBrokersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.iIsActiveFilter = data["iIsActiveFilter"];
            this.selectedDatabase = data["selectedDatabase"];
            this.contactLastNameFilterText = data["contactLastNameFilterText"];
            this.contactEmailFilterText = data["contactEmailFilterText"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAllBrokersInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllBrokersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["iIsActiveFilter"] = this.iIsActiveFilter;
        data["selectedDatabase"] = this.selectedDatabase;
        data["contactLastNameFilterText"] = this.contactLastNameFilterText;
        data["contactEmailFilterText"] = this.contactEmailFilterText;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IGetAllBrokersInput {
    filter: string | undefined;
    iIsActiveFilter: number | undefined;
    selectedDatabase: number | undefined;
    contactLastNameFilterText: string | undefined;
    contactEmailFilterText: string | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class PagedResultDtoOfGetBuildLolForViewDto implements IPagedResultDtoOfGetBuildLolForViewDto {
    totalCount!: number | undefined;
    items!: GetBuildLolForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBuildLolForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBuildLolForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBuildLolForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBuildLolForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetBuildLolForViewDto {
    totalCount: number | undefined;
    items: GetBuildLolForViewDto[] | undefined;
}

export class GetBuildLolForViewDto implements IGetBuildLolForViewDto {
    buildLol!: BuildLolDto | undefined;
    buildLK_BuildStatus!: string | undefined;

    constructor(data?: IGetBuildLolForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.buildLol = data["buildLol"] ? BuildLolDto.fromJS(data["buildLol"]) : <any>undefined;
            this.buildLK_BuildStatus = data["buildLK_BuildStatus"];
        }
    }

    static fromJS(data: any): GetBuildLolForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBuildLolForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buildLol"] = this.buildLol ? this.buildLol.toJSON() : <any>undefined;
        data["buildLK_BuildStatus"] = this.buildLK_BuildStatus;
        return data; 
    }
}

export interface IGetBuildLolForViewDto {
    buildLol: BuildLolDto | undefined;
    buildLK_BuildStatus: string | undefined;
}

export class BuildLolDto implements IBuildLolDto {
    masterLolID!: number | undefined;
    lK_Action!: string | undefined;
    lK_ActionMonth1!: string | undefined;
    lK_ActionMonth2!: string | undefined;
    lK_ActionNextMonth!: string | undefined;
    lK_QuantityType!: string | undefined;
    lK_FileType!: string | undefined;
    iSkipFirstRow!: boolean | undefined;
    iIsActive!: boolean | undefined;
    iUsage!: number | undefined;
    nTurns!: number | undefined;
    cDecisionReasoning!: string | undefined;
    cSlugDate!: string | undefined;
    cBatchDateType!: string | undefined;
    lK_SlugDateType!: string | undefined;
    iQuantityPrevious!: number | undefined;
    iQuantityRequested!: number | undefined;
    iQuantityReceivedDP!: number | undefined;
    iQuantityReceived!: number | undefined;
    iQuantityConverted!: number | undefined;
    dDateReceived!: moment.Moment | undefined;
    iQuantityTotal!: number | undefined;
    cBatch_LastFROM!: string | undefined;
    cBatch_LastTO!: string | undefined;
    cBatch_FROM!: string | undefined;
    cBatch_TO!: string | undefined;
    order_No!: string | undefined;
    order_ClientPO!: string | undefined;
    orderSelection!: string | undefined;
    order_Fields!: string | undefined;
    order_Comments!: string | undefined;
    order_Notes1!: string | undefined;
    order_Notes2!: string | undefined;
    lK_EmailTemplate!: string | undefined;
    ddateOrderSent!: moment.Moment | undefined;
    cNote!: string | undefined;
    iCASApprovalTo!: number | undefined;
    cSourceFilenameReadyToLoad!: string | undefined;
    cSystemFilenameReadyToLoad!: string | undefined;
    lK_LoadFileType!: string | undefined;
    lK_LoadFileRowTerminator!: string | undefined;
    cOnePassFileName!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    cSQL!: string | undefined;
    cSQLDescription!: string | undefined;
    iLoadQty!: number | undefined;
    lK_Encoding!: string | undefined;
    iIsMultiline!: boolean | undefined;
    buildId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IBuildLolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.masterLolID = data["masterLolID"];
            this.lK_Action = data["lK_Action"];
            this.lK_ActionMonth1 = data["lK_ActionMonth1"];
            this.lK_ActionMonth2 = data["lK_ActionMonth2"];
            this.lK_ActionNextMonth = data["lK_ActionNextMonth"];
            this.lK_QuantityType = data["lK_QuantityType"];
            this.lK_FileType = data["lK_FileType"];
            this.iSkipFirstRow = data["iSkipFirstRow"];
            this.iIsActive = data["iIsActive"];
            this.iUsage = data["iUsage"];
            this.nTurns = data["nTurns"];
            this.cDecisionReasoning = data["cDecisionReasoning"];
            this.cSlugDate = data["cSlugDate"];
            this.cBatchDateType = data["cBatchDateType"];
            this.lK_SlugDateType = data["lK_SlugDateType"];
            this.iQuantityPrevious = data["iQuantityPrevious"];
            this.iQuantityRequested = data["iQuantityRequested"];
            this.iQuantityReceivedDP = data["iQuantityReceivedDP"];
            this.iQuantityReceived = data["iQuantityReceived"];
            this.iQuantityConverted = data["iQuantityConverted"];
            this.dDateReceived = data["dDateReceived"] ? moment(data["dDateReceived"].toString()) : <any>undefined;
            this.iQuantityTotal = data["iQuantityTotal"];
            this.cBatch_LastFROM = data["cBatch_LastFROM"];
            this.cBatch_LastTO = data["cBatch_LastTO"];
            this.cBatch_FROM = data["cBatch_FROM"];
            this.cBatch_TO = data["cBatch_TO"];
            this.order_No = data["order_No"];
            this.order_ClientPO = data["order_ClientPO"];
            this.orderSelection = data["orderSelection"];
            this.order_Fields = data["order_Fields"];
            this.order_Comments = data["order_Comments"];
            this.order_Notes1 = data["order_Notes1"];
            this.order_Notes2 = data["order_Notes2"];
            this.lK_EmailTemplate = data["lK_EmailTemplate"];
            this.ddateOrderSent = data["ddateOrderSent"] ? moment(data["ddateOrderSent"].toString()) : <any>undefined;
            this.cNote = data["cNote"];
            this.iCASApprovalTo = data["iCASApprovalTo"];
            this.cSourceFilenameReadyToLoad = data["cSourceFilenameReadyToLoad"];
            this.cSystemFilenameReadyToLoad = data["cSystemFilenameReadyToLoad"];
            this.lK_LoadFileType = data["lK_LoadFileType"];
            this.lK_LoadFileRowTerminator = data["lK_LoadFileRowTerminator"];
            this.cOnePassFileName = data["cOnePassFileName"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.cSQL = data["cSQL"];
            this.cSQLDescription = data["cSQLDescription"];
            this.iLoadQty = data["iLoadQty"];
            this.lK_Encoding = data["lK_Encoding"];
            this.iIsMultiline = data["iIsMultiline"];
            this.buildId = data["buildId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BuildLolDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildLolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["masterLolID"] = this.masterLolID;
        data["lK_Action"] = this.lK_Action;
        data["lK_ActionMonth1"] = this.lK_ActionMonth1;
        data["lK_ActionMonth2"] = this.lK_ActionMonth2;
        data["lK_ActionNextMonth"] = this.lK_ActionNextMonth;
        data["lK_QuantityType"] = this.lK_QuantityType;
        data["lK_FileType"] = this.lK_FileType;
        data["iSkipFirstRow"] = this.iSkipFirstRow;
        data["iIsActive"] = this.iIsActive;
        data["iUsage"] = this.iUsage;
        data["nTurns"] = this.nTurns;
        data["cDecisionReasoning"] = this.cDecisionReasoning;
        data["cSlugDate"] = this.cSlugDate;
        data["cBatchDateType"] = this.cBatchDateType;
        data["lK_SlugDateType"] = this.lK_SlugDateType;
        data["iQuantityPrevious"] = this.iQuantityPrevious;
        data["iQuantityRequested"] = this.iQuantityRequested;
        data["iQuantityReceivedDP"] = this.iQuantityReceivedDP;
        data["iQuantityReceived"] = this.iQuantityReceived;
        data["iQuantityConverted"] = this.iQuantityConverted;
        data["dDateReceived"] = this.dDateReceived ? this.dDateReceived.toISOString() : <any>undefined;
        data["iQuantityTotal"] = this.iQuantityTotal;
        data["cBatch_LastFROM"] = this.cBatch_LastFROM;
        data["cBatch_LastTO"] = this.cBatch_LastTO;
        data["cBatch_FROM"] = this.cBatch_FROM;
        data["cBatch_TO"] = this.cBatch_TO;
        data["order_No"] = this.order_No;
        data["order_ClientPO"] = this.order_ClientPO;
        data["orderSelection"] = this.orderSelection;
        data["order_Fields"] = this.order_Fields;
        data["order_Comments"] = this.order_Comments;
        data["order_Notes1"] = this.order_Notes1;
        data["order_Notes2"] = this.order_Notes2;
        data["lK_EmailTemplate"] = this.lK_EmailTemplate;
        data["ddateOrderSent"] = this.ddateOrderSent ? this.ddateOrderSent.toISOString() : <any>undefined;
        data["cNote"] = this.cNote;
        data["iCASApprovalTo"] = this.iCASApprovalTo;
        data["cSourceFilenameReadyToLoad"] = this.cSourceFilenameReadyToLoad;
        data["cSystemFilenameReadyToLoad"] = this.cSystemFilenameReadyToLoad;
        data["lK_LoadFileType"] = this.lK_LoadFileType;
        data["lK_LoadFileRowTerminator"] = this.lK_LoadFileRowTerminator;
        data["cOnePassFileName"] = this.cOnePassFileName;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["cSQL"] = this.cSQL;
        data["cSQLDescription"] = this.cSQLDescription;
        data["iLoadQty"] = this.iLoadQty;
        data["lK_Encoding"] = this.lK_Encoding;
        data["iIsMultiline"] = this.iIsMultiline;
        data["buildId"] = this.buildId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBuildLolDto {
    masterLolID: number | undefined;
    lK_Action: string | undefined;
    lK_ActionMonth1: string | undefined;
    lK_ActionMonth2: string | undefined;
    lK_ActionNextMonth: string | undefined;
    lK_QuantityType: string | undefined;
    lK_FileType: string | undefined;
    iSkipFirstRow: boolean | undefined;
    iIsActive: boolean | undefined;
    iUsage: number | undefined;
    nTurns: number | undefined;
    cDecisionReasoning: string | undefined;
    cSlugDate: string | undefined;
    cBatchDateType: string | undefined;
    lK_SlugDateType: string | undefined;
    iQuantityPrevious: number | undefined;
    iQuantityRequested: number | undefined;
    iQuantityReceivedDP: number | undefined;
    iQuantityReceived: number | undefined;
    iQuantityConverted: number | undefined;
    dDateReceived: moment.Moment | undefined;
    iQuantityTotal: number | undefined;
    cBatch_LastFROM: string | undefined;
    cBatch_LastTO: string | undefined;
    cBatch_FROM: string | undefined;
    cBatch_TO: string | undefined;
    order_No: string | undefined;
    order_ClientPO: string | undefined;
    orderSelection: string | undefined;
    order_Fields: string | undefined;
    order_Comments: string | undefined;
    order_Notes1: string | undefined;
    order_Notes2: string | undefined;
    lK_EmailTemplate: string | undefined;
    ddateOrderSent: moment.Moment | undefined;
    cNote: string | undefined;
    iCASApprovalTo: number | undefined;
    cSourceFilenameReadyToLoad: string | undefined;
    cSystemFilenameReadyToLoad: string | undefined;
    lK_LoadFileType: string | undefined;
    lK_LoadFileRowTerminator: string | undefined;
    cOnePassFileName: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    cSQL: string | undefined;
    cSQLDescription: string | undefined;
    iLoadQty: number | undefined;
    lK_Encoding: string | undefined;
    iIsMultiline: boolean | undefined;
    buildId: number | undefined;
    id: number | undefined;
}

export class GetBuildLolForEditOutput implements IGetBuildLolForEditOutput {
    buildLol!: CreateOrEditBuildLolDto | undefined;
    buildLK_BuildStatus!: string | undefined;

    constructor(data?: IGetBuildLolForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.buildLol = data["buildLol"] ? CreateOrEditBuildLolDto.fromJS(data["buildLol"]) : <any>undefined;
            this.buildLK_BuildStatus = data["buildLK_BuildStatus"];
        }
    }

    static fromJS(data: any): GetBuildLolForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBuildLolForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buildLol"] = this.buildLol ? this.buildLol.toJSON() : <any>undefined;
        data["buildLK_BuildStatus"] = this.buildLK_BuildStatus;
        return data; 
    }
}

export interface IGetBuildLolForEditOutput {
    buildLol: CreateOrEditBuildLolDto | undefined;
    buildLK_BuildStatus: string | undefined;
}

export class CreateOrEditBuildLolDto implements ICreateOrEditBuildLolDto {
    masterLolID!: number | undefined;
    lK_Action!: string | undefined;
    lK_ActionMonth1!: string | undefined;
    lK_ActionMonth2!: string | undefined;
    lK_ActionNextMonth!: string | undefined;
    lK_QuantityType!: string | undefined;
    lK_FileType!: string | undefined;
    iSkipFirstRow!: boolean | undefined;
    iIsActive!: boolean | undefined;
    iUsage!: number | undefined;
    nTurns!: number | undefined;
    cDecisionReasoning!: string | undefined;
    cSlugDate!: string | undefined;
    cBatchDateType!: string | undefined;
    lK_SlugDateType!: string | undefined;
    iQuantityPrevious!: number | undefined;
    iQuantityRequested!: number | undefined;
    iQuantityReceivedDP!: number | undefined;
    iQuantityReceived!: number | undefined;
    iQuantityConverted!: number | undefined;
    dDateReceived!: moment.Moment | undefined;
    iQuantityTotal!: number | undefined;
    cBatch_LastFROM!: string | undefined;
    cBatch_LastTO!: string | undefined;
    cBatch_FROM!: string | undefined;
    cBatch_TO!: string | undefined;
    order_No!: string | undefined;
    order_ClientPO!: string | undefined;
    orderSelection!: string | undefined;
    order_Fields!: string | undefined;
    order_Comments!: string | undefined;
    order_Notes1!: string | undefined;
    order_Notes2!: string | undefined;
    lK_EmailTemplate!: string | undefined;
    ddateOrderSent!: moment.Moment | undefined;
    cNote!: string | undefined;
    iCASApprovalTo!: number | undefined;
    cSourceFilenameReadyToLoad!: string | undefined;
    cSystemFilenameReadyToLoad!: string | undefined;
    lK_LoadFileType!: string | undefined;
    lK_LoadFileRowTerminator!: string | undefined;
    cOnePassFileName!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    cSQL!: string | undefined;
    cSQLDescription!: string | undefined;
    iLoadQty!: number | undefined;
    lK_Encoding!: string | undefined;
    iIsMultiline!: boolean | undefined;
    buildId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBuildLolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.masterLolID = data["masterLolID"];
            this.lK_Action = data["lK_Action"];
            this.lK_ActionMonth1 = data["lK_ActionMonth1"];
            this.lK_ActionMonth2 = data["lK_ActionMonth2"];
            this.lK_ActionNextMonth = data["lK_ActionNextMonth"];
            this.lK_QuantityType = data["lK_QuantityType"];
            this.lK_FileType = data["lK_FileType"];
            this.iSkipFirstRow = data["iSkipFirstRow"];
            this.iIsActive = data["iIsActive"];
            this.iUsage = data["iUsage"];
            this.nTurns = data["nTurns"];
            this.cDecisionReasoning = data["cDecisionReasoning"];
            this.cSlugDate = data["cSlugDate"];
            this.cBatchDateType = data["cBatchDateType"];
            this.lK_SlugDateType = data["lK_SlugDateType"];
            this.iQuantityPrevious = data["iQuantityPrevious"];
            this.iQuantityRequested = data["iQuantityRequested"];
            this.iQuantityReceivedDP = data["iQuantityReceivedDP"];
            this.iQuantityReceived = data["iQuantityReceived"];
            this.iQuantityConverted = data["iQuantityConverted"];
            this.dDateReceived = data["dDateReceived"] ? moment(data["dDateReceived"].toString()) : <any>undefined;
            this.iQuantityTotal = data["iQuantityTotal"];
            this.cBatch_LastFROM = data["cBatch_LastFROM"];
            this.cBatch_LastTO = data["cBatch_LastTO"];
            this.cBatch_FROM = data["cBatch_FROM"];
            this.cBatch_TO = data["cBatch_TO"];
            this.order_No = data["order_No"];
            this.order_ClientPO = data["order_ClientPO"];
            this.orderSelection = data["orderSelection"];
            this.order_Fields = data["order_Fields"];
            this.order_Comments = data["order_Comments"];
            this.order_Notes1 = data["order_Notes1"];
            this.order_Notes2 = data["order_Notes2"];
            this.lK_EmailTemplate = data["lK_EmailTemplate"];
            this.ddateOrderSent = data["ddateOrderSent"] ? moment(data["ddateOrderSent"].toString()) : <any>undefined;
            this.cNote = data["cNote"];
            this.iCASApprovalTo = data["iCASApprovalTo"];
            this.cSourceFilenameReadyToLoad = data["cSourceFilenameReadyToLoad"];
            this.cSystemFilenameReadyToLoad = data["cSystemFilenameReadyToLoad"];
            this.lK_LoadFileType = data["lK_LoadFileType"];
            this.lK_LoadFileRowTerminator = data["lK_LoadFileRowTerminator"];
            this.cOnePassFileName = data["cOnePassFileName"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.cSQL = data["cSQL"];
            this.cSQLDescription = data["cSQLDescription"];
            this.iLoadQty = data["iLoadQty"];
            this.lK_Encoding = data["lK_Encoding"];
            this.iIsMultiline = data["iIsMultiline"];
            this.buildId = data["buildId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBuildLolDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBuildLolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["masterLolID"] = this.masterLolID;
        data["lK_Action"] = this.lK_Action;
        data["lK_ActionMonth1"] = this.lK_ActionMonth1;
        data["lK_ActionMonth2"] = this.lK_ActionMonth2;
        data["lK_ActionNextMonth"] = this.lK_ActionNextMonth;
        data["lK_QuantityType"] = this.lK_QuantityType;
        data["lK_FileType"] = this.lK_FileType;
        data["iSkipFirstRow"] = this.iSkipFirstRow;
        data["iIsActive"] = this.iIsActive;
        data["iUsage"] = this.iUsage;
        data["nTurns"] = this.nTurns;
        data["cDecisionReasoning"] = this.cDecisionReasoning;
        data["cSlugDate"] = this.cSlugDate;
        data["cBatchDateType"] = this.cBatchDateType;
        data["lK_SlugDateType"] = this.lK_SlugDateType;
        data["iQuantityPrevious"] = this.iQuantityPrevious;
        data["iQuantityRequested"] = this.iQuantityRequested;
        data["iQuantityReceivedDP"] = this.iQuantityReceivedDP;
        data["iQuantityReceived"] = this.iQuantityReceived;
        data["iQuantityConverted"] = this.iQuantityConverted;
        data["dDateReceived"] = this.dDateReceived ? this.dDateReceived.toISOString() : <any>undefined;
        data["iQuantityTotal"] = this.iQuantityTotal;
        data["cBatch_LastFROM"] = this.cBatch_LastFROM;
        data["cBatch_LastTO"] = this.cBatch_LastTO;
        data["cBatch_FROM"] = this.cBatch_FROM;
        data["cBatch_TO"] = this.cBatch_TO;
        data["order_No"] = this.order_No;
        data["order_ClientPO"] = this.order_ClientPO;
        data["orderSelection"] = this.orderSelection;
        data["order_Fields"] = this.order_Fields;
        data["order_Comments"] = this.order_Comments;
        data["order_Notes1"] = this.order_Notes1;
        data["order_Notes2"] = this.order_Notes2;
        data["lK_EmailTemplate"] = this.lK_EmailTemplate;
        data["ddateOrderSent"] = this.ddateOrderSent ? this.ddateOrderSent.toISOString() : <any>undefined;
        data["cNote"] = this.cNote;
        data["iCASApprovalTo"] = this.iCASApprovalTo;
        data["cSourceFilenameReadyToLoad"] = this.cSourceFilenameReadyToLoad;
        data["cSystemFilenameReadyToLoad"] = this.cSystemFilenameReadyToLoad;
        data["lK_LoadFileType"] = this.lK_LoadFileType;
        data["lK_LoadFileRowTerminator"] = this.lK_LoadFileRowTerminator;
        data["cOnePassFileName"] = this.cOnePassFileName;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["cSQL"] = this.cSQL;
        data["cSQLDescription"] = this.cSQLDescription;
        data["iLoadQty"] = this.iLoadQty;
        data["lK_Encoding"] = this.lK_Encoding;
        data["iIsMultiline"] = this.iIsMultiline;
        data["buildId"] = this.buildId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBuildLolDto {
    masterLolID: number | undefined;
    lK_Action: string | undefined;
    lK_ActionMonth1: string | undefined;
    lK_ActionMonth2: string | undefined;
    lK_ActionNextMonth: string | undefined;
    lK_QuantityType: string | undefined;
    lK_FileType: string | undefined;
    iSkipFirstRow: boolean | undefined;
    iIsActive: boolean | undefined;
    iUsage: number | undefined;
    nTurns: number | undefined;
    cDecisionReasoning: string | undefined;
    cSlugDate: string | undefined;
    cBatchDateType: string | undefined;
    lK_SlugDateType: string | undefined;
    iQuantityPrevious: number | undefined;
    iQuantityRequested: number | undefined;
    iQuantityReceivedDP: number | undefined;
    iQuantityReceived: number | undefined;
    iQuantityConverted: number | undefined;
    dDateReceived: moment.Moment | undefined;
    iQuantityTotal: number | undefined;
    cBatch_LastFROM: string | undefined;
    cBatch_LastTO: string | undefined;
    cBatch_FROM: string | undefined;
    cBatch_TO: string | undefined;
    order_No: string | undefined;
    order_ClientPO: string | undefined;
    orderSelection: string | undefined;
    order_Fields: string | undefined;
    order_Comments: string | undefined;
    order_Notes1: string | undefined;
    order_Notes2: string | undefined;
    lK_EmailTemplate: string | undefined;
    ddateOrderSent: moment.Moment | undefined;
    cNote: string | undefined;
    iCASApprovalTo: number | undefined;
    cSourceFilenameReadyToLoad: string | undefined;
    cSystemFilenameReadyToLoad: string | undefined;
    lK_LoadFileType: string | undefined;
    lK_LoadFileRowTerminator: string | undefined;
    cOnePassFileName: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    cSQL: string | undefined;
    cSQLDescription: string | undefined;
    iLoadQty: number | undefined;
    lK_Encoding: string | undefined;
    iIsMultiline: boolean | undefined;
    buildId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfBuildLolBuildLookupTableDto implements IPagedResultDtoOfBuildLolBuildLookupTableDto {
    totalCount!: number | undefined;
    items!: BuildLolBuildLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBuildLolBuildLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BuildLolBuildLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBuildLolBuildLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBuildLolBuildLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBuildLolBuildLookupTableDto {
    totalCount: number | undefined;
    items: BuildLolBuildLookupTableDto[] | undefined;
}

export class BuildLolBuildLookupTableDto implements IBuildLolBuildLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBuildLolBuildLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BuildLolBuildLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildLolBuildLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBuildLolBuildLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetBuildForViewDto implements IPagedResultDtoOfGetBuildForViewDto {
    totalCount!: number | undefined;
    items!: GetBuildForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBuildForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBuildForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBuildForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBuildForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetBuildForViewDto {
    totalCount: number | undefined;
    items: GetBuildForViewDto[] | undefined;
}

export class GetBuildForViewDto implements IGetBuildForViewDto {
    build!: BuildDto | undefined;
    databasecDatabaseName!: string | undefined;

    constructor(data?: IGetBuildForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.build = data["build"] ? BuildDto.fromJS(data["build"]) : <any>undefined;
            this.databasecDatabaseName = data["databasecDatabaseName"];
        }
    }

    static fromJS(data: any): GetBuildForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBuildForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["build"] = this.build ? this.build.toJSON() : <any>undefined;
        data["databasecDatabaseName"] = this.databasecDatabaseName;
        return data; 
    }
}

export interface IGetBuildForViewDto {
    build: BuildDto | undefined;
    databasecDatabaseName: string | undefined;
}

export class BuildDto implements IBuildDto {
    lK_BuildStatus!: string | undefined;
    iPreviousBuildID!: number | undefined;
    cBuild!: string | undefined;
    cDescription!: string | undefined;
    dMailDate!: moment.Moment | undefined;
    iRecordCount!: number | undefined;
    iIsReadyToUse!: boolean | undefined;
    iIsOnDisk!: boolean | undefined;
    cMailDateFROM!: string | undefined;
    cMailDateTO!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    lK_BuildPriority!: number | undefined;
    dScheduledDateTime!: moment.Moment | undefined;
    iStopRequested!: boolean | undefined;
    iIsOneStep!: boolean | undefined;
    databaseId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IBuildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lK_BuildStatus = data["lK_BuildStatus"];
            this.iPreviousBuildID = data["iPreviousBuildID"];
            this.cBuild = data["cBuild"];
            this.cDescription = data["cDescription"];
            this.dMailDate = data["dMailDate"] ? moment(data["dMailDate"].toString()) : <any>undefined;
            this.iRecordCount = data["iRecordCount"];
            this.iIsReadyToUse = data["iIsReadyToUse"];
            this.iIsOnDisk = data["iIsOnDisk"];
            this.cMailDateFROM = data["cMailDateFROM"];
            this.cMailDateTO = data["cMailDateTO"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.lK_BuildPriority = data["lK_BuildPriority"];
            this.dScheduledDateTime = data["dScheduledDateTime"] ? moment(data["dScheduledDateTime"].toString()) : <any>undefined;
            this.iStopRequested = data["iStopRequested"];
            this.iIsOneStep = data["iIsOneStep"];
            this.databaseId = data["databaseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BuildDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lK_BuildStatus"] = this.lK_BuildStatus;
        data["iPreviousBuildID"] = this.iPreviousBuildID;
        data["cBuild"] = this.cBuild;
        data["cDescription"] = this.cDescription;
        data["dMailDate"] = this.dMailDate ? this.dMailDate.toISOString() : <any>undefined;
        data["iRecordCount"] = this.iRecordCount;
        data["iIsReadyToUse"] = this.iIsReadyToUse;
        data["iIsOnDisk"] = this.iIsOnDisk;
        data["cMailDateFROM"] = this.cMailDateFROM;
        data["cMailDateTO"] = this.cMailDateTO;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["lK_BuildPriority"] = this.lK_BuildPriority;
        data["dScheduledDateTime"] = this.dScheduledDateTime ? this.dScheduledDateTime.toISOString() : <any>undefined;
        data["iStopRequested"] = this.iStopRequested;
        data["iIsOneStep"] = this.iIsOneStep;
        data["databaseId"] = this.databaseId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBuildDto {
    lK_BuildStatus: string | undefined;
    iPreviousBuildID: number | undefined;
    cBuild: string | undefined;
    cDescription: string | undefined;
    dMailDate: moment.Moment | undefined;
    iRecordCount: number | undefined;
    iIsReadyToUse: boolean | undefined;
    iIsOnDisk: boolean | undefined;
    cMailDateFROM: string | undefined;
    cMailDateTO: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    lK_BuildPriority: number | undefined;
    dScheduledDateTime: moment.Moment | undefined;
    iStopRequested: boolean | undefined;
    iIsOneStep: boolean | undefined;
    databaseId: number | undefined;
    id: number | undefined;
}

export class GetBuildForEditOutput implements IGetBuildForEditOutput {
    build!: CreateOrEditBuildDto | undefined;
    databasecDatabaseName!: string | undefined;

    constructor(data?: IGetBuildForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.build = data["build"] ? CreateOrEditBuildDto.fromJS(data["build"]) : <any>undefined;
            this.databasecDatabaseName = data["databasecDatabaseName"];
        }
    }

    static fromJS(data: any): GetBuildForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBuildForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["build"] = this.build ? this.build.toJSON() : <any>undefined;
        data["databasecDatabaseName"] = this.databasecDatabaseName;
        return data; 
    }
}

export interface IGetBuildForEditOutput {
    build: CreateOrEditBuildDto | undefined;
    databasecDatabaseName: string | undefined;
}

export class CreateOrEditBuildDto implements ICreateOrEditBuildDto {
    lK_BuildStatus!: string | undefined;
    iPreviousBuildID!: number | undefined;
    cBuild!: string;
    cDescription!: string;
    dMailDate!: moment.Moment | undefined;
    iRecordCount!: number | undefined;
    iIsReadyToUse!: boolean | undefined;
    iIsOnDisk!: boolean | undefined;
    cMailDateFROM!: string | undefined;
    cMailDateTO!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    lK_BuildPriority!: number | undefined;
    dScheduledDateTime!: moment.Moment | undefined;
    iStopRequested!: boolean | undefined;
    iIsOneStep!: boolean | undefined;
    databaseId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBuildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lK_BuildStatus = data["lK_BuildStatus"];
            this.iPreviousBuildID = data["iPreviousBuildID"];
            this.cBuild = data["cBuild"];
            this.cDescription = data["cDescription"];
            this.dMailDate = data["dMailDate"] ? moment(data["dMailDate"].toString()) : <any>undefined;
            this.iRecordCount = data["iRecordCount"];
            this.iIsReadyToUse = data["iIsReadyToUse"];
            this.iIsOnDisk = data["iIsOnDisk"];
            this.cMailDateFROM = data["cMailDateFROM"];
            this.cMailDateTO = data["cMailDateTO"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.lK_BuildPriority = data["lK_BuildPriority"];
            this.dScheduledDateTime = data["dScheduledDateTime"] ? moment(data["dScheduledDateTime"].toString()) : <any>undefined;
            this.iStopRequested = data["iStopRequested"];
            this.iIsOneStep = data["iIsOneStep"];
            this.databaseId = data["databaseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBuildDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBuildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lK_BuildStatus"] = this.lK_BuildStatus;
        data["iPreviousBuildID"] = this.iPreviousBuildID;
        data["cBuild"] = this.cBuild;
        data["cDescription"] = this.cDescription;
        data["dMailDate"] = this.dMailDate ? this.dMailDate.toISOString() : <any>undefined;
        data["iRecordCount"] = this.iRecordCount;
        data["iIsReadyToUse"] = this.iIsReadyToUse;
        data["iIsOnDisk"] = this.iIsOnDisk;
        data["cMailDateFROM"] = this.cMailDateFROM;
        data["cMailDateTO"] = this.cMailDateTO;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["lK_BuildPriority"] = this.lK_BuildPriority;
        data["dScheduledDateTime"] = this.dScheduledDateTime ? this.dScheduledDateTime.toISOString() : <any>undefined;
        data["iStopRequested"] = this.iStopRequested;
        data["iIsOneStep"] = this.iIsOneStep;
        data["databaseId"] = this.databaseId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBuildDto {
    lK_BuildStatus: string | undefined;
    iPreviousBuildID: number | undefined;
    cBuild: string;
    cDescription: string;
    dMailDate: moment.Moment | undefined;
    iRecordCount: number | undefined;
    iIsReadyToUse: boolean | undefined;
    iIsOnDisk: boolean | undefined;
    cMailDateFROM: string | undefined;
    cMailDateTO: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    lK_BuildPriority: number | undefined;
    dScheduledDateTime: moment.Moment | undefined;
    iStopRequested: boolean | undefined;
    iIsOneStep: boolean | undefined;
    databaseId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfBuildDatabaseLookupTableDto implements IPagedResultDtoOfBuildDatabaseLookupTableDto {
    totalCount!: number | undefined;
    items!: BuildDatabaseLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBuildDatabaseLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BuildDatabaseLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBuildDatabaseLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBuildDatabaseLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBuildDatabaseLookupTableDto {
    totalCount: number | undefined;
    items: BuildDatabaseLookupTableDto[] | undefined;
}

export class BuildDatabaseLookupTableDto implements IBuildDatabaseLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBuildDatabaseLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BuildDatabaseLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildDatabaseLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBuildDatabaseLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class GetAllBuildsForDatabaseDto implements IGetAllBuildsForDatabaseDto {
    buildDropDown!: DropdownOutputDto[] | undefined;
    defaultSelection!: number | undefined;

    constructor(data?: IGetAllBuildsForDatabaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["buildDropDown"])) {
                this.buildDropDown = [] as any;
                for (let item of data["buildDropDown"])
                    this.buildDropDown!.push(DropdownOutputDto.fromJS(item));
            }
            this.defaultSelection = data["defaultSelection"];
        }
    }

    static fromJS(data: any): GetAllBuildsForDatabaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllBuildsForDatabaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.buildDropDown)) {
            data["buildDropDown"] = [];
            for (let item of this.buildDropDown)
                data["buildDropDown"].push(item.toJSON());
        }
        data["defaultSelection"] = this.defaultSelection;
        return data; 
    }
}

export interface IGetAllBuildsForDatabaseDto {
    buildDropDown: DropdownOutputDto[] | undefined;
    defaultSelection: number | undefined;
}

export class DropdownOutputDto implements IDropdownOutputDto {
    value!: any | undefined;
    label!: string | undefined;

    constructor(data?: IDropdownOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.label = data["label"];
        }
    }

    static fromJS(data: any): DropdownOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["label"] = this.label;
        return data; 
    }
}

export interface IDropdownOutputDto {
    value: any | undefined;
    label: string | undefined;
}

export class GetBuildTableLayoutForViewDto implements IGetBuildTableLayoutForViewDto {
    id!: number | undefined;
    cTableName!: string | undefined;
    cFieldName!: string | undefined;
    cDescription!: string | undefined;
    cFieldDescription!: string | undefined;
    cValue!: string | undefined;

    constructor(data?: IGetBuildTableLayoutForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cTableName = data["cTableName"];
            this.cFieldName = data["cFieldName"];
            this.cDescription = data["cDescription"];
            this.cFieldDescription = data["cFieldDescription"];
            this.cValue = data["cValue"];
        }
    }

    static fromJS(data: any): GetBuildTableLayoutForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBuildTableLayoutForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cTableName"] = this.cTableName;
        data["cFieldName"] = this.cFieldName;
        data["cDescription"] = this.cDescription;
        data["cFieldDescription"] = this.cFieldDescription;
        data["cValue"] = this.cValue;
        return data; 
    }
}

export interface IGetBuildTableLayoutForViewDto {
    id: number | undefined;
    cTableName: string | undefined;
    cFieldName: string | undefined;
    cDescription: string | undefined;
    cFieldDescription: string | undefined;
    cValue: string | undefined;
}

export enum AdvanceSelectionScreen {
    Industry = 0,
    CountyCity = 1,
    GeoRadius = 2,
    Occupation = 3,
    GeoMapping = 4,
}

export class AdvanceSelectionFields implements IAdvanceSelectionFields {
    sicCode!: Field | undefined;
    minorIndustryGroup!: Field | undefined;
    majorIndustryGroup!: Field | undefined;
    franchiseBySIC!: Field | undefined;
    industrySpecificBySIC!: Field | undefined;
    primarySICFlag!: Field | undefined;
    stateSelect!: Field | undefined;
    stateCountySelect!: Field | undefined;
    neighborhoodSelect!: Field | undefined;
    stateCitySelect!: Field | undefined;
    geoRadius!: Field | undefined;
    zipRadius!: Field | undefined;
    industrySelection!: Field | undefined;
    occupationSelection!: Field | undefined;
    specialtySelection!: Field | undefined;
    geoMapping!: Field | undefined;

    constructor(data?: IAdvanceSelectionFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sicCode = data["sicCode"] ? Field.fromJS(data["sicCode"]) : <any>undefined;
            this.minorIndustryGroup = data["minorIndustryGroup"] ? Field.fromJS(data["minorIndustryGroup"]) : <any>undefined;
            this.majorIndustryGroup = data["majorIndustryGroup"] ? Field.fromJS(data["majorIndustryGroup"]) : <any>undefined;
            this.franchiseBySIC = data["franchiseBySIC"] ? Field.fromJS(data["franchiseBySIC"]) : <any>undefined;
            this.industrySpecificBySIC = data["industrySpecificBySIC"] ? Field.fromJS(data["industrySpecificBySIC"]) : <any>undefined;
            this.primarySICFlag = data["primarySICFlag"] ? Field.fromJS(data["primarySICFlag"]) : <any>undefined;
            this.stateSelect = data["stateSelect"] ? Field.fromJS(data["stateSelect"]) : <any>undefined;
            this.stateCountySelect = data["stateCountySelect"] ? Field.fromJS(data["stateCountySelect"]) : <any>undefined;
            this.neighborhoodSelect = data["neighborhoodSelect"] ? Field.fromJS(data["neighborhoodSelect"]) : <any>undefined;
            this.stateCitySelect = data["stateCitySelect"] ? Field.fromJS(data["stateCitySelect"]) : <any>undefined;
            this.geoRadius = data["geoRadius"] ? Field.fromJS(data["geoRadius"]) : <any>undefined;
            this.zipRadius = data["zipRadius"] ? Field.fromJS(data["zipRadius"]) : <any>undefined;
            this.industrySelection = data["industrySelection"] ? Field.fromJS(data["industrySelection"]) : <any>undefined;
            this.occupationSelection = data["occupationSelection"] ? Field.fromJS(data["occupationSelection"]) : <any>undefined;
            this.specialtySelection = data["specialtySelection"] ? Field.fromJS(data["specialtySelection"]) : <any>undefined;
            this.geoMapping = data["geoMapping"] ? Field.fromJS(data["geoMapping"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdvanceSelectionFields {
        data = typeof data === 'object' ? data : {};
        let result = new AdvanceSelectionFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sicCode"] = this.sicCode ? this.sicCode.toJSON() : <any>undefined;
        data["minorIndustryGroup"] = this.minorIndustryGroup ? this.minorIndustryGroup.toJSON() : <any>undefined;
        data["majorIndustryGroup"] = this.majorIndustryGroup ? this.majorIndustryGroup.toJSON() : <any>undefined;
        data["franchiseBySIC"] = this.franchiseBySIC ? this.franchiseBySIC.toJSON() : <any>undefined;
        data["industrySpecificBySIC"] = this.industrySpecificBySIC ? this.industrySpecificBySIC.toJSON() : <any>undefined;
        data["primarySICFlag"] = this.primarySICFlag ? this.primarySICFlag.toJSON() : <any>undefined;
        data["stateSelect"] = this.stateSelect ? this.stateSelect.toJSON() : <any>undefined;
        data["stateCountySelect"] = this.stateCountySelect ? this.stateCountySelect.toJSON() : <any>undefined;
        data["neighborhoodSelect"] = this.neighborhoodSelect ? this.neighborhoodSelect.toJSON() : <any>undefined;
        data["stateCitySelect"] = this.stateCitySelect ? this.stateCitySelect.toJSON() : <any>undefined;
        data["geoRadius"] = this.geoRadius ? this.geoRadius.toJSON() : <any>undefined;
        data["zipRadius"] = this.zipRadius ? this.zipRadius.toJSON() : <any>undefined;
        data["industrySelection"] = this.industrySelection ? this.industrySelection.toJSON() : <any>undefined;
        data["occupationSelection"] = this.occupationSelection ? this.occupationSelection.toJSON() : <any>undefined;
        data["specialtySelection"] = this.specialtySelection ? this.specialtySelection.toJSON() : <any>undefined;
        data["geoMapping"] = this.geoMapping ? this.geoMapping.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAdvanceSelectionFields {
    sicCode: Field | undefined;
    minorIndustryGroup: Field | undefined;
    majorIndustryGroup: Field | undefined;
    franchiseBySIC: Field | undefined;
    industrySpecificBySIC: Field | undefined;
    primarySICFlag: Field | undefined;
    stateSelect: Field | undefined;
    stateCountySelect: Field | undefined;
    neighborhoodSelect: Field | undefined;
    stateCitySelect: Field | undefined;
    geoRadius: Field | undefined;
    zipRadius: Field | undefined;
    industrySelection: Field | undefined;
    occupationSelection: Field | undefined;
    specialtySelection: Field | undefined;
    geoMapping: Field | undefined;
}

export class Field implements IField {
    id!: number | undefined;
    cQuestionFieldName!: string | undefined;
    cConfigFieldName!: string | undefined;
    cQuestionDescription!: string | undefined;
    cTableName!: string | undefined;
    cValueMode!: string | undefined;
    values!: DropdownOutputDto[] | undefined;

    constructor(data?: IField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cQuestionFieldName = data["cQuestionFieldName"];
            this.cConfigFieldName = data["cConfigFieldName"];
            this.cQuestionDescription = data["cQuestionDescription"];
            this.cTableName = data["cTableName"];
            this.cValueMode = data["cValueMode"];
            if (Array.isArray(data["values"])) {
                this.values = [] as any;
                for (let item of data["values"])
                    this.values!.push(DropdownOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Field {
        data = typeof data === 'object' ? data : {};
        let result = new Field();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cQuestionFieldName"] = this.cQuestionFieldName;
        data["cConfigFieldName"] = this.cConfigFieldName;
        data["cQuestionDescription"] = this.cQuestionDescription;
        data["cTableName"] = this.cTableName;
        data["cValueMode"] = this.cValueMode;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IField {
    id: number | undefined;
    cQuestionFieldName: string | undefined;
    cConfigFieldName: string | undefined;
    cQuestionDescription: string | undefined;
    cTableName: string | undefined;
    cValueMode: string | undefined;
    values: DropdownOutputDto[] | undefined;
}

export class PagedResultDtoOfGetBuildTableForViewDto implements IPagedResultDtoOfGetBuildTableForViewDto {
    totalCount!: number | undefined;
    items!: GetBuildTableForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBuildTableForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBuildTableForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBuildTableForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBuildTableForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetBuildTableForViewDto {
    totalCount: number | undefined;
    items: GetBuildTableForViewDto[] | undefined;
}

export class GetBuildTableForViewDto implements IGetBuildTableForViewDto {
    buildTable!: BuildTableDto | undefined;
    buildcBuild!: string | undefined;

    constructor(data?: IGetBuildTableForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.buildTable = data["buildTable"] ? BuildTableDto.fromJS(data["buildTable"]) : <any>undefined;
            this.buildcBuild = data["buildcBuild"];
        }
    }

    static fromJS(data: any): GetBuildTableForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBuildTableForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buildTable"] = this.buildTable ? this.buildTable.toJSON() : <any>undefined;
        data["buildcBuild"] = this.buildcBuild;
        return data; 
    }
}

export interface IGetBuildTableForViewDto {
    buildTable: BuildTableDto | undefined;
    buildcBuild: string | undefined;
}

export class BuildTableDto implements IBuildTableDto {
    cTableName!: string | undefined;
    lK_TableType!: string | undefined;
    lK_JoinType!: string | undefined;
    cJoinOn!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: string | undefined;
    cModifiedBy!: string | undefined;
    ctabledescription!: string | undefined;
    buildId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IBuildTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cTableName = data["cTableName"];
            this.lK_TableType = data["lK_TableType"];
            this.lK_JoinType = data["lK_JoinType"];
            this.cJoinOn = data["cJoinOn"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"];
            this.cModifiedBy = data["cModifiedBy"];
            this.ctabledescription = data["ctabledescription"];
            this.buildId = data["buildId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BuildTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cTableName"] = this.cTableName;
        data["lK_TableType"] = this.lK_TableType;
        data["lK_JoinType"] = this.lK_JoinType;
        data["cJoinOn"] = this.cJoinOn;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate;
        data["cModifiedBy"] = this.cModifiedBy;
        data["ctabledescription"] = this.ctabledescription;
        data["buildId"] = this.buildId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBuildTableDto {
    cTableName: string | undefined;
    lK_TableType: string | undefined;
    lK_JoinType: string | undefined;
    cJoinOn: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: string | undefined;
    cModifiedBy: string | undefined;
    ctabledescription: string | undefined;
    buildId: number | undefined;
    id: number | undefined;
}

export class GetBuildTableForEditOutput implements IGetBuildTableForEditOutput {
    buildTable!: CreateOrEditBuildTableDto | undefined;
    buildcBuild!: string | undefined;

    constructor(data?: IGetBuildTableForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.buildTable = data["buildTable"] ? CreateOrEditBuildTableDto.fromJS(data["buildTable"]) : <any>undefined;
            this.buildcBuild = data["buildcBuild"];
        }
    }

    static fromJS(data: any): GetBuildTableForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBuildTableForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buildTable"] = this.buildTable ? this.buildTable.toJSON() : <any>undefined;
        data["buildcBuild"] = this.buildcBuild;
        return data; 
    }
}

export interface IGetBuildTableForEditOutput {
    buildTable: CreateOrEditBuildTableDto | undefined;
    buildcBuild: string | undefined;
}

export class CreateOrEditBuildTableDto implements ICreateOrEditBuildTableDto {
    cTableName!: string;
    lK_TableType!: string;
    lK_JoinType!: string;
    cJoinOn!: string;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string;
    dModifiedDate!: string | undefined;
    cModifiedBy!: string | undefined;
    ctabledescription!: string;
    buildId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBuildTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cTableName = data["cTableName"];
            this.lK_TableType = data["lK_TableType"];
            this.lK_JoinType = data["lK_JoinType"];
            this.cJoinOn = data["cJoinOn"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"];
            this.cModifiedBy = data["cModifiedBy"];
            this.ctabledescription = data["ctabledescription"];
            this.buildId = data["buildId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBuildTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBuildTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cTableName"] = this.cTableName;
        data["lK_TableType"] = this.lK_TableType;
        data["lK_JoinType"] = this.lK_JoinType;
        data["cJoinOn"] = this.cJoinOn;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate;
        data["cModifiedBy"] = this.cModifiedBy;
        data["ctabledescription"] = this.ctabledescription;
        data["buildId"] = this.buildId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBuildTableDto {
    cTableName: string;
    lK_TableType: string;
    lK_JoinType: string;
    cJoinOn: string;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string;
    dModifiedDate: string | undefined;
    cModifiedBy: string | undefined;
    ctabledescription: string;
    buildId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfBuildTableBuildLookupTableDto implements IPagedResultDtoOfBuildTableBuildLookupTableDto {
    totalCount!: number | undefined;
    items!: BuildTableBuildLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBuildTableBuildLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BuildTableBuildLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBuildTableBuildLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBuildTableBuildLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBuildTableBuildLookupTableDto {
    totalCount: number | undefined;
    items: BuildTableBuildLookupTableDto[] | undefined;
}

export class BuildTableBuildLookupTableDto implements IBuildTableBuildLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBuildTableBuildLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BuildTableBuildLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildTableBuildLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBuildTableBuildLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class PagedResultDtoOfGetCampaignAttachmentForViewDto implements IPagedResultDtoOfGetCampaignAttachmentForViewDto {
    totalCount!: number | undefined;
    items!: GetCampaignAttachmentForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCampaignAttachmentForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCampaignAttachmentForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCampaignAttachmentForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCampaignAttachmentForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCampaignAttachmentForViewDto {
    totalCount: number | undefined;
    items: GetCampaignAttachmentForViewDto[] | undefined;
}

export class GetCampaignAttachmentForViewDto implements IGetCampaignAttachmentForViewDto {
    campaignAttachment!: CampaignAttachmentDto | undefined;
    campaigncDescription!: string | undefined;

    constructor(data?: IGetCampaignAttachmentForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignAttachment = data["campaignAttachment"] ? CampaignAttachmentDto.fromJS(data["campaignAttachment"]) : <any>undefined;
            this.campaigncDescription = data["campaigncDescription"];
        }
    }

    static fromJS(data: any): GetCampaignAttachmentForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignAttachmentForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignAttachment"] = this.campaignAttachment ? this.campaignAttachment.toJSON() : <any>undefined;
        data["campaigncDescription"] = this.campaigncDescription;
        return data; 
    }
}

export interface IGetCampaignAttachmentForViewDto {
    campaignAttachment: CampaignAttachmentDto | undefined;
    campaigncDescription: string | undefined;
}

export class CampaignAttachmentDto implements ICampaignAttachmentDto {
    action!: ActionType | undefined;
    orderId!: string | undefined;
    formType!: string | undefined;
    code!: string | undefined;
    id!: number | undefined;
    cFileName!: string | undefined;
    realFileName!: string | undefined;
    isDisabled!: boolean | undefined;

    constructor(data?: ICampaignAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action = data["action"];
            this.orderId = data["orderId"];
            this.formType = data["formType"];
            this.code = data["code"];
            this.id = data["id"];
            this.cFileName = data["cFileName"];
            this.realFileName = data["realFileName"];
            this.isDisabled = data["isDisabled"];
        }
    }

    static fromJS(data: any): CampaignAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["orderId"] = this.orderId;
        data["formType"] = this.formType;
        data["code"] = this.code;
        data["id"] = this.id;
        data["cFileName"] = this.cFileName;
        data["realFileName"] = this.realFileName;
        data["isDisabled"] = this.isDisabled;
        return data; 
    }
}

export interface ICampaignAttachmentDto {
    action: ActionType | undefined;
    orderId: string | undefined;
    formType: string | undefined;
    code: string | undefined;
    id: number | undefined;
    cFileName: string | undefined;
    realFileName: string | undefined;
    isDisabled: boolean | undefined;
}

export enum ActionType {
    None = 0,
    Add = 1,
    Edit = 2,
    Delete = 3,
}

export class GetCampaignAttachmentForEditOutput implements IGetCampaignAttachmentForEditOutput {
    campaignAttachment!: CreateOrEditCampaignAttachmentDto | undefined;
    campaigncDescription!: string | undefined;

    constructor(data?: IGetCampaignAttachmentForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignAttachment = data["campaignAttachment"] ? CreateOrEditCampaignAttachmentDto.fromJS(data["campaignAttachment"]) : <any>undefined;
            this.campaigncDescription = data["campaigncDescription"];
        }
    }

    static fromJS(data: any): GetCampaignAttachmentForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignAttachmentForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignAttachment"] = this.campaignAttachment ? this.campaignAttachment.toJSON() : <any>undefined;
        data["campaigncDescription"] = this.campaigncDescription;
        return data; 
    }
}

export interface IGetCampaignAttachmentForEditOutput {
    campaignAttachment: CreateOrEditCampaignAttachmentDto | undefined;
    campaigncDescription: string | undefined;
}

export class CreateOrEditCampaignAttachmentDto implements ICreateOrEditCampaignAttachmentDto {
    orderId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCampaignAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCampaignAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCampaignAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCampaignAttachmentDto {
    orderId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfCampaignAttachmentCampaignLookupTableDto implements IPagedResultDtoOfCampaignAttachmentCampaignLookupTableDto {
    totalCount!: number | undefined;
    items!: CampaignAttachmentCampaignLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCampaignAttachmentCampaignLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CampaignAttachmentCampaignLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCampaignAttachmentCampaignLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCampaignAttachmentCampaignLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCampaignAttachmentCampaignLookupTableDto {
    totalCount: number | undefined;
    items: CampaignAttachmentCampaignLookupTableDto[] | undefined;
}

export class CampaignAttachmentCampaignLookupTableDto implements ICampaignAttachmentCampaignLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICampaignAttachmentCampaignLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CampaignAttachmentCampaignLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignAttachmentCampaignLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICampaignAttachmentCampaignLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetCampaignCASApprovalForViewDto implements IPagedResultDtoOfGetCampaignCASApprovalForViewDto {
    totalCount!: number | undefined;
    items!: GetCampaignCASApprovalForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCampaignCASApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCampaignCASApprovalForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCampaignCASApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCampaignCASApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCampaignCASApprovalForViewDto {
    totalCount: number | undefined;
    items: GetCampaignCASApprovalForViewDto[] | undefined;
}

export class GetCampaignCASApprovalForViewDto implements IGetCampaignCASApprovalForViewDto {
    campaignCASApproval!: CampaignCASApprovalDto | undefined;
    campaigncDatabaseName!: string | undefined;

    constructor(data?: IGetCampaignCASApprovalForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignCASApproval = data["campaignCASApproval"] ? CampaignCASApprovalDto.fromJS(data["campaignCASApproval"]) : <any>undefined;
            this.campaigncDatabaseName = data["campaigncDatabaseName"];
        }
    }

    static fromJS(data: any): GetCampaignCASApprovalForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignCASApprovalForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignCASApproval"] = this.campaignCASApproval ? this.campaignCASApproval.toJSON() : <any>undefined;
        data["campaigncDatabaseName"] = this.campaigncDatabaseName;
        return data; 
    }
}

export interface IGetCampaignCASApprovalForViewDto {
    campaignCASApproval: CampaignCASApprovalDto | undefined;
    campaigncDatabaseName: string | undefined;
}

export class CampaignCASApprovalDto implements ICampaignCASApprovalDto {
    masterLOLID!: number | undefined;
    cStatus!: string | undefined;
    nBasePrice!: number | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    orderId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICampaignCASApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.masterLOLID = data["masterLOLID"];
            this.cStatus = data["cStatus"];
            this.nBasePrice = data["nBasePrice"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.orderId = data["orderId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CampaignCASApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignCASApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["masterLOLID"] = this.masterLOLID;
        data["cStatus"] = this.cStatus;
        data["nBasePrice"] = this.nBasePrice;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["orderId"] = this.orderId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICampaignCASApprovalDto {
    masterLOLID: number | undefined;
    cStatus: string | undefined;
    nBasePrice: number | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    orderId: number | undefined;
    id: number | undefined;
}

export class GetCampaignCASApprovalForEditOutput implements IGetCampaignCASApprovalForEditOutput {
    campaignCASApproval!: CreateOrEditCampaignCASApprovalDto | undefined;
    campaigncDatabaseName!: string | undefined;

    constructor(data?: IGetCampaignCASApprovalForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignCASApproval = data["campaignCASApproval"] ? CreateOrEditCampaignCASApprovalDto.fromJS(data["campaignCASApproval"]) : <any>undefined;
            this.campaigncDatabaseName = data["campaigncDatabaseName"];
        }
    }

    static fromJS(data: any): GetCampaignCASApprovalForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignCASApprovalForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignCASApproval"] = this.campaignCASApproval ? this.campaignCASApproval.toJSON() : <any>undefined;
        data["campaigncDatabaseName"] = this.campaigncDatabaseName;
        return data; 
    }
}

export interface IGetCampaignCASApprovalForEditOutput {
    campaignCASApproval: CreateOrEditCampaignCASApprovalDto | undefined;
    campaigncDatabaseName: string | undefined;
}

export class CreateOrEditCampaignCASApprovalDto implements ICreateOrEditCampaignCASApprovalDto {
    orderId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCampaignCASApprovalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCampaignCASApprovalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCampaignCASApprovalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCampaignCASApprovalDto {
    orderId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfCampaignCASApprovalCampaignLookupTableDto implements IPagedResultDtoOfCampaignCASApprovalCampaignLookupTableDto {
    totalCount!: number | undefined;
    items!: CampaignCASApprovalCampaignLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCampaignCASApprovalCampaignLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CampaignCASApprovalCampaignLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCampaignCASApprovalCampaignLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCampaignCASApprovalCampaignLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCampaignCASApprovalCampaignLookupTableDto {
    totalCount: number | undefined;
    items: CampaignCASApprovalCampaignLookupTableDto[] | undefined;
}

export class CampaignCASApprovalCampaignLookupTableDto implements ICampaignCASApprovalCampaignLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICampaignCASApprovalCampaignLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CampaignCASApprovalCampaignLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignCASApprovalCampaignLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICampaignCASApprovalCampaignLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class CampaignFavouriteDtoForView implements ICampaignFavouriteDtoForView {
    campaignId!: number | undefined;
    campaignDescription!: string | undefined;
    databaseName!: string | undefined;

    constructor(data?: ICampaignFavouriteDtoForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignId = data["campaignId"];
            this.campaignDescription = data["campaignDescription"];
            this.databaseName = data["databaseName"];
        }
    }

    static fromJS(data: any): CampaignFavouriteDtoForView {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignFavouriteDtoForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["campaignDescription"] = this.campaignDescription;
        data["databaseName"] = this.databaseName;
        return data; 
    }
}

export interface ICampaignFavouriteDtoForView {
    campaignId: number | undefined;
    campaignDescription: string | undefined;
    databaseName: string | undefined;
}

export class PagedResultDtoOfGetCampaignFTPForViewDto implements IPagedResultDtoOfGetCampaignFTPForViewDto {
    totalCount!: number | undefined;
    items!: GetCampaignFTPForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCampaignFTPForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCampaignFTPForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCampaignFTPForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCampaignFTPForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCampaignFTPForViewDto {
    totalCount: number | undefined;
    items: GetCampaignFTPForViewDto[] | undefined;
}

export class GetCampaignFTPForViewDto implements IGetCampaignFTPForViewDto {
    campaignFTP!: CampaignFTPDto | undefined;

    constructor(data?: IGetCampaignFTPForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignFTP = data["campaignFTP"] ? CampaignFTPDto.fromJS(data["campaignFTP"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCampaignFTPForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignFTPForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignFTP"] = this.campaignFTP ? this.campaignFTP.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCampaignFTPForViewDto {
    campaignFTP: CampaignFTPDto | undefined;
}

export class CampaignFTPDto implements ICampaignFTPDto {
    id!: number | undefined;

    constructor(data?: ICampaignFTPDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CampaignFTPDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignFTPDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICampaignFTPDto {
    id: number | undefined;
}

export class GetCampaignFTPForEditOutput implements IGetCampaignFTPForEditOutput {
    campaignFTP!: CreateOrEditCampaignFTPDto | undefined;

    constructor(data?: IGetCampaignFTPForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignFTP = data["campaignFTP"] ? CreateOrEditCampaignFTPDto.fromJS(data["campaignFTP"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCampaignFTPForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignFTPForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignFTP"] = this.campaignFTP ? this.campaignFTP.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCampaignFTPForEditOutput {
    campaignFTP: CreateOrEditCampaignFTPDto | undefined;
}

export class CreateOrEditCampaignFTPDto implements ICreateOrEditCampaignFTPDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditCampaignFTPDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCampaignFTPDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCampaignFTPDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCampaignFTPDto {
    id: number | undefined;
}

export class PagedResultDtoOfGetCampaignMultiColumnReportForViewDto implements IPagedResultDtoOfGetCampaignMultiColumnReportForViewDto {
    totalCount!: number | undefined;
    items!: GetCampaignMultiColumnReportForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCampaignMultiColumnReportForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCampaignMultiColumnReportForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCampaignMultiColumnReportForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCampaignMultiColumnReportForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCampaignMultiColumnReportForViewDto {
    totalCount: number | undefined;
    items: GetCampaignMultiColumnReportForViewDto[] | undefined;
}

export class GetCampaignMultiColumnReportForViewDto implements IGetCampaignMultiColumnReportForViewDto {
    campaignMultiColumnReport!: CampaignMultiColumnReportDto | undefined;
    campaigncDescription!: string | undefined;

    constructor(data?: IGetCampaignMultiColumnReportForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignMultiColumnReport = data["campaignMultiColumnReport"] ? CampaignMultiColumnReportDto.fromJS(data["campaignMultiColumnReport"]) : <any>undefined;
            this.campaigncDescription = data["campaigncDescription"];
        }
    }

    static fromJS(data: any): GetCampaignMultiColumnReportForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignMultiColumnReportForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignMultiColumnReport"] = this.campaignMultiColumnReport ? this.campaignMultiColumnReport.toJSON() : <any>undefined;
        data["campaigncDescription"] = this.campaigncDescription;
        return data; 
    }
}

export interface IGetCampaignMultiColumnReportForViewDto {
    campaignMultiColumnReport: CampaignMultiColumnReportDto | undefined;
    campaigncDescription: string | undefined;
}

export class CampaignMultiColumnReportDto implements ICampaignMultiColumnReportDto {
    orderId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICampaignMultiColumnReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CampaignMultiColumnReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignMultiColumnReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICampaignMultiColumnReportDto {
    orderId: number | undefined;
    id: number | undefined;
}

export class GetCampaignMultiColumnReportForEditOutput implements IGetCampaignMultiColumnReportForEditOutput {
    campaignMultiColumnReport!: CreateOrEditCampaignMultiColumnReportDto | undefined;
    campaigncDescription!: string | undefined;

    constructor(data?: IGetCampaignMultiColumnReportForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignMultiColumnReport = data["campaignMultiColumnReport"] ? CreateOrEditCampaignMultiColumnReportDto.fromJS(data["campaignMultiColumnReport"]) : <any>undefined;
            this.campaigncDescription = data["campaigncDescription"];
        }
    }

    static fromJS(data: any): GetCampaignMultiColumnReportForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignMultiColumnReportForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignMultiColumnReport"] = this.campaignMultiColumnReport ? this.campaignMultiColumnReport.toJSON() : <any>undefined;
        data["campaigncDescription"] = this.campaigncDescription;
        return data; 
    }
}

export interface IGetCampaignMultiColumnReportForEditOutput {
    campaignMultiColumnReport: CreateOrEditCampaignMultiColumnReportDto | undefined;
    campaigncDescription: string | undefined;
}

export class CreateOrEditCampaignMultiColumnReportDto implements ICreateOrEditCampaignMultiColumnReportDto {
    orderId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCampaignMultiColumnReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCampaignMultiColumnReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCampaignMultiColumnReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCampaignMultiColumnReportDto {
    orderId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfCampaignMultiColumnReportCampaignLookupTableDto implements IPagedResultDtoOfCampaignMultiColumnReportCampaignLookupTableDto {
    totalCount!: number | undefined;
    items!: CampaignMultiColumnReportCampaignLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCampaignMultiColumnReportCampaignLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CampaignMultiColumnReportCampaignLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCampaignMultiColumnReportCampaignLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCampaignMultiColumnReportCampaignLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCampaignMultiColumnReportCampaignLookupTableDto {
    totalCount: number | undefined;
    items: CampaignMultiColumnReportCampaignLookupTableDto[] | undefined;
}

export class CampaignMultiColumnReportCampaignLookupTableDto implements ICampaignMultiColumnReportCampaignLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICampaignMultiColumnReportCampaignLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CampaignMultiColumnReportCampaignLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignMultiColumnReportCampaignLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICampaignMultiColumnReportCampaignLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetCampaignsListForView implements IPagedResultDtoOfGetCampaignsListForView {
    totalCount!: number | undefined;
    items!: GetCampaignsListForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCampaignsListForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCampaignsListForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCampaignsListForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCampaignsListForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCampaignsListForView {
    totalCount: number | undefined;
    items: GetCampaignsListForView[] | undefined;
}

export class GetCampaignsListForView implements IGetCampaignsListForView {
    buildID!: number | undefined;
    buildDescription!: string | undefined;
    orderCreatedDate!: string | undefined;
    status!: number | undefined;
    campaignId!: number | undefined;
    iAvailableQty!: number | undefined;
    campaignDescription!: string | undefined;
    providedQty!: number | undefined;
    mailerId!: number | undefined;
    offerID!: number | undefined;
    offerName!: string | undefined;
    createdBy!: string | undefined;
    mailer!: string | undefined;
    databaseName!: string | undefined;
    databaseID!: number | undefined;
    divisionId!: number | undefined;
    segmentID!: number | undefined;
    splitType!: number | undefined;
    statusDescription!: string | undefined;
    customerDescription!: string | undefined;
    build!: number | undefined;
    isLocked!: boolean | undefined;
    cExportLayout!: string | undefined;
    poOrderNumber!: string | undefined;

    constructor(data?: IGetCampaignsListForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.buildID = data["buildID"];
            this.buildDescription = data["buildDescription"];
            this.orderCreatedDate = data["orderCreatedDate"];
            this.status = data["status"];
            this.campaignId = data["campaignId"];
            this.iAvailableQty = data["iAvailableQty"];
            this.campaignDescription = data["campaignDescription"];
            this.providedQty = data["providedQty"];
            this.mailerId = data["mailerId"];
            this.offerID = data["offerID"];
            this.offerName = data["offerName"];
            this.createdBy = data["createdBy"];
            this.mailer = data["mailer"];
            this.databaseName = data["databaseName"];
            this.databaseID = data["databaseID"];
            this.divisionId = data["divisionId"];
            this.segmentID = data["segmentID"];
            this.splitType = data["splitType"];
            this.statusDescription = data["statusDescription"];
            this.customerDescription = data["customerDescription"];
            this.build = data["build"];
            this.isLocked = data["isLocked"];
            this.cExportLayout = data["cExportLayout"];
            this.poOrderNumber = data["poOrderNumber"];
        }
    }

    static fromJS(data: any): GetCampaignsListForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignsListForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buildID"] = this.buildID;
        data["buildDescription"] = this.buildDescription;
        data["orderCreatedDate"] = this.orderCreatedDate;
        data["status"] = this.status;
        data["campaignId"] = this.campaignId;
        data["iAvailableQty"] = this.iAvailableQty;
        data["campaignDescription"] = this.campaignDescription;
        data["providedQty"] = this.providedQty;
        data["mailerId"] = this.mailerId;
        data["offerID"] = this.offerID;
        data["offerName"] = this.offerName;
        data["createdBy"] = this.createdBy;
        data["mailer"] = this.mailer;
        data["databaseName"] = this.databaseName;
        data["databaseID"] = this.databaseID;
        data["divisionId"] = this.divisionId;
        data["segmentID"] = this.segmentID;
        data["splitType"] = this.splitType;
        data["statusDescription"] = this.statusDescription;
        data["customerDescription"] = this.customerDescription;
        data["build"] = this.build;
        data["isLocked"] = this.isLocked;
        data["cExportLayout"] = this.cExportLayout;
        data["poOrderNumber"] = this.poOrderNumber;
        return data; 
    }
}

export interface IGetCampaignsListForView {
    buildID: number | undefined;
    buildDescription: string | undefined;
    orderCreatedDate: string | undefined;
    status: number | undefined;
    campaignId: number | undefined;
    iAvailableQty: number | undefined;
    campaignDescription: string | undefined;
    providedQty: number | undefined;
    mailerId: number | undefined;
    offerID: number | undefined;
    offerName: string | undefined;
    createdBy: string | undefined;
    mailer: string | undefined;
    databaseName: string | undefined;
    databaseID: number | undefined;
    divisionId: number | undefined;
    segmentID: number | undefined;
    splitType: number | undefined;
    statusDescription: string | undefined;
    customerDescription: string | undefined;
    build: number | undefined;
    isLocked: boolean | undefined;
    cExportLayout: string | undefined;
    poOrderNumber: string | undefined;
}

export class CampaignActionInputDto implements ICampaignActionInputDto {
    campaignId!: number | undefined;
    databaseId!: number | undefined;
    campaignStatus!: number | undefined;
    buildId!: number | undefined;
    currentBuild!: number | undefined;
    isExecute!: boolean | undefined;
    cNotes!: string | undefined;

    constructor(data?: ICampaignActionInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignId = data["campaignId"];
            this.databaseId = data["databaseId"];
            this.campaignStatus = data["campaignStatus"];
            this.buildId = data["buildId"];
            this.currentBuild = data["currentBuild"];
            this.isExecute = data["isExecute"];
            this.cNotes = data["cNotes"];
        }
    }

    static fromJS(data: any): CampaignActionInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignActionInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["databaseId"] = this.databaseId;
        data["campaignStatus"] = this.campaignStatus;
        data["buildId"] = this.buildId;
        data["currentBuild"] = this.currentBuild;
        data["isExecute"] = this.isExecute;
        data["cNotes"] = this.cNotes;
        return data; 
    }
}

export interface ICampaignActionInputDto {
    campaignId: number | undefined;
    databaseId: number | undefined;
    campaignStatus: number | undefined;
    buildId: number | undefined;
    currentBuild: number | undefined;
    isExecute: boolean | undefined;
    cNotes: string | undefined;
}

export class CampaignActionOutputDto implements ICampaignActionOutputDto {
    message!: string | undefined;
    success!: boolean | undefined;

    constructor(data?: ICampaignActionOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
            this.success = data["success"];
        }
    }

    static fromJS(data: any): CampaignActionOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignActionOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["success"] = this.success;
        return data; 
    }
}

export interface ICampaignActionOutputDto {
    message: string | undefined;
    success: boolean | undefined;
}

export class DecoyDto implements IDecoyDto {
    mailerID!: number | undefined;
    cDecoyType!: string | undefined;
    cFirstName!: string | undefined;
    cLastName!: string | undefined;
    cName!: string | undefined;
    cAddress1!: string | undefined;
    cAddress2!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cZip!: string | undefined;
    cZip4!: string | undefined;
    cCompany!: string | undefined;
    cTitle!: string | undefined;
    cEmail!: string | undefined;
    cPhone!: string | undefined;
    cFax!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    cKeyCode1!: string | undefined;
    cDecoyGroup!: string | undefined;
    databaseId!: number | undefined;
    cAddress!: string | undefined;
    isDecoyGroupType!: boolean | undefined;
    action!: ActionType | undefined;
    id!: number | undefined;

    constructor(data?: IDecoyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mailerID = data["mailerID"];
            this.cDecoyType = data["cDecoyType"];
            this.cFirstName = data["cFirstName"];
            this.cLastName = data["cLastName"];
            this.cName = data["cName"];
            this.cAddress1 = data["cAddress1"];
            this.cAddress2 = data["cAddress2"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cZip = data["cZip"];
            this.cZip4 = data["cZip4"];
            this.cCompany = data["cCompany"];
            this.cTitle = data["cTitle"];
            this.cEmail = data["cEmail"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.cKeyCode1 = data["cKeyCode1"];
            this.cDecoyGroup = data["cDecoyGroup"];
            this.databaseId = data["databaseId"];
            this.cAddress = data["cAddress"];
            this.isDecoyGroupType = data["isDecoyGroupType"];
            this.action = data["action"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DecoyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DecoyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailerID"] = this.mailerID;
        data["cDecoyType"] = this.cDecoyType;
        data["cFirstName"] = this.cFirstName;
        data["cLastName"] = this.cLastName;
        data["cName"] = this.cName;
        data["cAddress1"] = this.cAddress1;
        data["cAddress2"] = this.cAddress2;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cZip"] = this.cZip;
        data["cZip4"] = this.cZip4;
        data["cCompany"] = this.cCompany;
        data["cTitle"] = this.cTitle;
        data["cEmail"] = this.cEmail;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["cKeyCode1"] = this.cKeyCode1;
        data["cDecoyGroup"] = this.cDecoyGroup;
        data["databaseId"] = this.databaseId;
        data["cAddress"] = this.cAddress;
        data["isDecoyGroupType"] = this.isDecoyGroupType;
        data["action"] = this.action;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDecoyDto {
    mailerID: number | undefined;
    cDecoyType: string | undefined;
    cFirstName: string | undefined;
    cLastName: string | undefined;
    cName: string | undefined;
    cAddress1: string | undefined;
    cAddress2: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cZip: string | undefined;
    cZip4: string | undefined;
    cCompany: string | undefined;
    cTitle: string | undefined;
    cEmail: string | undefined;
    cPhone: string | undefined;
    cFax: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    cKeyCode1: string | undefined;
    cDecoyGroup: string | undefined;
    databaseId: number | undefined;
    cAddress: string | undefined;
    isDecoyGroupType: boolean | undefined;
    action: ActionType | undefined;
    id: number | undefined;
}

export class SegmentLevelMaxPerDto implements ISegmentLevelMaxPerDto {
    segmentLevelAction!: ActionType | undefined;
    cGroup!: string | undefined;
    cMaxPerField!: string | undefined;
    cMaxPerFieldDescription!: string | undefined;
    iMaxPerQuantity!: number | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    orderId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISegmentLevelMaxPerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.segmentLevelAction = data["segmentLevelAction"];
            this.cGroup = data["cGroup"];
            this.cMaxPerField = data["cMaxPerField"];
            this.cMaxPerFieldDescription = data["cMaxPerFieldDescription"];
            this.iMaxPerQuantity = data["iMaxPerQuantity"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.orderId = data["orderId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SegmentLevelMaxPerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SegmentLevelMaxPerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["segmentLevelAction"] = this.segmentLevelAction;
        data["cGroup"] = this.cGroup;
        data["cMaxPerField"] = this.cMaxPerField;
        data["cMaxPerFieldDescription"] = this.cMaxPerFieldDescription;
        data["iMaxPerQuantity"] = this.iMaxPerQuantity;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["orderId"] = this.orderId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISegmentLevelMaxPerDto {
    segmentLevelAction: ActionType | undefined;
    cGroup: string | undefined;
    cMaxPerField: string | undefined;
    cMaxPerFieldDescription: string | undefined;
    iMaxPerQuantity: number | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    orderId: number | undefined;
    id: number | undefined;
}

export class CampaignOESSDto implements ICampaignOESSDto {
    orderId!: number | undefined;
    databaseId!: number | undefined;
    campaignDescription!: string | undefined;
    lK_BillingUOM!: string | undefined;
    cSalesRepID!: string | undefined;
    iBillingQty!: number | undefined;
    nUnitPrice!: string | undefined;
    nDiscountPercentage!: string | undefined;
    nEffectiveUnitPrice!: string | undefined;
    nShippingCharge!: string | undefined;
    iTotalPrice!: string | undefined;
    cCompany!: string | undefined;
    cFirstName!: string | undefined;
    cLastName!: string | undefined;
    cPhone!: string | undefined;
    cOESSInvoiceNumber!: string | undefined;
    cOESSAccountNumber!: string | undefined;
    cOracleAccountNumber!: string | undefined;
    iOESSInvoiceTotal!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    oessOrderID!: string | undefined;
    oessStatus!: string | undefined;
    salesRep!: DropdownOutputDto[] | undefined;
    uom!: DropdownOutputDto[] | undefined;
    id!: number | undefined;

    constructor(data?: ICampaignOESSDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.databaseId = data["databaseId"];
            this.campaignDescription = data["campaignDescription"];
            this.lK_BillingUOM = data["lK_BillingUOM"];
            this.cSalesRepID = data["cSalesRepID"];
            this.iBillingQty = data["iBillingQty"];
            this.nUnitPrice = data["nUnitPrice"];
            this.nDiscountPercentage = data["nDiscountPercentage"];
            this.nEffectiveUnitPrice = data["nEffectiveUnitPrice"];
            this.nShippingCharge = data["nShippingCharge"];
            this.iTotalPrice = data["iTotalPrice"];
            this.cCompany = data["cCompany"];
            this.cFirstName = data["cFirstName"];
            this.cLastName = data["cLastName"];
            this.cPhone = data["cPhone"];
            this.cOESSInvoiceNumber = data["cOESSInvoiceNumber"];
            this.cOESSAccountNumber = data["cOESSAccountNumber"];
            this.cOracleAccountNumber = data["cOracleAccountNumber"];
            this.iOESSInvoiceTotal = data["iOESSInvoiceTotal"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.oessOrderID = data["oessOrderID"];
            this.oessStatus = data["oessStatus"];
            if (Array.isArray(data["salesRep"])) {
                this.salesRep = [] as any;
                for (let item of data["salesRep"])
                    this.salesRep!.push(DropdownOutputDto.fromJS(item));
            }
            if (Array.isArray(data["uom"])) {
                this.uom = [] as any;
                for (let item of data["uom"])
                    this.uom!.push(DropdownOutputDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CampaignOESSDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignOESSDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["databaseId"] = this.databaseId;
        data["campaignDescription"] = this.campaignDescription;
        data["lK_BillingUOM"] = this.lK_BillingUOM;
        data["cSalesRepID"] = this.cSalesRepID;
        data["iBillingQty"] = this.iBillingQty;
        data["nUnitPrice"] = this.nUnitPrice;
        data["nDiscountPercentage"] = this.nDiscountPercentage;
        data["nEffectiveUnitPrice"] = this.nEffectiveUnitPrice;
        data["nShippingCharge"] = this.nShippingCharge;
        data["iTotalPrice"] = this.iTotalPrice;
        data["cCompany"] = this.cCompany;
        data["cFirstName"] = this.cFirstName;
        data["cLastName"] = this.cLastName;
        data["cPhone"] = this.cPhone;
        data["cOESSInvoiceNumber"] = this.cOESSInvoiceNumber;
        data["cOESSAccountNumber"] = this.cOESSAccountNumber;
        data["cOracleAccountNumber"] = this.cOracleAccountNumber;
        data["iOESSInvoiceTotal"] = this.iOESSInvoiceTotal;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["oessOrderID"] = this.oessOrderID;
        data["oessStatus"] = this.oessStatus;
        if (Array.isArray(this.salesRep)) {
            data["salesRep"] = [];
            for (let item of this.salesRep)
                data["salesRep"].push(item.toJSON());
        }
        if (Array.isArray(this.uom)) {
            data["uom"] = [];
            for (let item of this.uom)
                data["uom"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface ICampaignOESSDto {
    orderId: number | undefined;
    databaseId: number | undefined;
    campaignDescription: string | undefined;
    lK_BillingUOM: string | undefined;
    cSalesRepID: string | undefined;
    iBillingQty: number | undefined;
    nUnitPrice: string | undefined;
    nDiscountPercentage: string | undefined;
    nEffectiveUnitPrice: string | undefined;
    nShippingCharge: string | undefined;
    iTotalPrice: string | undefined;
    cCompany: string | undefined;
    cFirstName: string | undefined;
    cLastName: string | undefined;
    cPhone: string | undefined;
    cOESSInvoiceNumber: string | undefined;
    cOESSAccountNumber: string | undefined;
    cOracleAccountNumber: string | undefined;
    iOESSInvoiceTotal: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    oessOrderID: string | undefined;
    oessStatus: string | undefined;
    salesRep: DropdownOutputDto[] | undefined;
    uom: DropdownOutputDto[] | undefined;
    id: number | undefined;
}

export class GetCampaignsOutputDto implements IGetCampaignsOutputDto {
    id!: number | undefined;
    label!: string | undefined;
    ftpSite!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    ftpPassword!: string | undefined;
    type!: string | undefined;
    layout!: string | undefined;
    isHeaderRow!: boolean | undefined;
    isDataFileOnly!: boolean | undefined;
    isUnzipped!: boolean | undefined;
    sort!: string | undefined;
    pgpKey!: string | undefined;
    shipTo!: string | undefined;
    email!: string | undefined;
    layoutId!: string | undefined;
    iHasKeyCode!: number | undefined;
    totalOutputQuantity!: number | undefined;
    media!: string | undefined;
    fileLabel!: string | undefined;
    fileNotes!: string | undefined;
    splitType!: number | undefined;
    splitIntoNParts!: number | undefined;
    typeList!: DropdownOutputDto[] | undefined;
    layoutlist!: DropdownOutputDto[] | undefined;
    sortList!: DropdownOutputDto[] | undefined;
    pgpKeyList!: DropdownOutputDto[] | undefined;
    shipToList!: DropdownOutputDto[] | undefined;
    mediaList!: DropdownOutputDto[] | undefined;
    layoutDescription!: string | undefined;
    shipCCEmail!: string | undefined;
    shipSubject!: string | undefined;
    shipNotes!: string | undefined;
    shippedDate!: string | undefined;

    constructor(data?: IGetCampaignsOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.label = data["label"];
            this.ftpSite = data["ftpSite"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.ftpPassword = data["ftpPassword"];
            this.type = data["type"];
            this.layout = data["layout"];
            this.isHeaderRow = data["isHeaderRow"];
            this.isDataFileOnly = data["isDataFileOnly"];
            this.isUnzipped = data["isUnzipped"];
            this.sort = data["sort"];
            this.pgpKey = data["pgpKey"];
            this.shipTo = data["shipTo"];
            this.email = data["email"];
            this.layoutId = data["layoutId"];
            this.iHasKeyCode = data["iHasKeyCode"];
            this.totalOutputQuantity = data["totalOutputQuantity"];
            this.media = data["media"];
            this.fileLabel = data["fileLabel"];
            this.fileNotes = data["fileNotes"];
            this.splitType = data["splitType"];
            this.splitIntoNParts = data["splitIntoNParts"];
            if (Array.isArray(data["typeList"])) {
                this.typeList = [] as any;
                for (let item of data["typeList"])
                    this.typeList!.push(DropdownOutputDto.fromJS(item));
            }
            if (Array.isArray(data["layoutlist"])) {
                this.layoutlist = [] as any;
                for (let item of data["layoutlist"])
                    this.layoutlist!.push(DropdownOutputDto.fromJS(item));
            }
            if (Array.isArray(data["sortList"])) {
                this.sortList = [] as any;
                for (let item of data["sortList"])
                    this.sortList!.push(DropdownOutputDto.fromJS(item));
            }
            if (Array.isArray(data["pgpKeyList"])) {
                this.pgpKeyList = [] as any;
                for (let item of data["pgpKeyList"])
                    this.pgpKeyList!.push(DropdownOutputDto.fromJS(item));
            }
            if (Array.isArray(data["shipToList"])) {
                this.shipToList = [] as any;
                for (let item of data["shipToList"])
                    this.shipToList!.push(DropdownOutputDto.fromJS(item));
            }
            if (Array.isArray(data["mediaList"])) {
                this.mediaList = [] as any;
                for (let item of data["mediaList"])
                    this.mediaList!.push(DropdownOutputDto.fromJS(item));
            }
            this.layoutDescription = data["layoutDescription"];
            this.shipCCEmail = data["shipCCEmail"];
            this.shipSubject = data["shipSubject"];
            this.shipNotes = data["shipNotes"];
            this.shippedDate = data["shippedDate"];
        }
    }

    static fromJS(data: any): GetCampaignsOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignsOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["label"] = this.label;
        data["ftpSite"] = this.ftpSite;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["ftpPassword"] = this.ftpPassword;
        data["type"] = this.type;
        data["layout"] = this.layout;
        data["isHeaderRow"] = this.isHeaderRow;
        data["isDataFileOnly"] = this.isDataFileOnly;
        data["isUnzipped"] = this.isUnzipped;
        data["sort"] = this.sort;
        data["pgpKey"] = this.pgpKey;
        data["shipTo"] = this.shipTo;
        data["email"] = this.email;
        data["layoutId"] = this.layoutId;
        data["iHasKeyCode"] = this.iHasKeyCode;
        data["totalOutputQuantity"] = this.totalOutputQuantity;
        data["media"] = this.media;
        data["fileLabel"] = this.fileLabel;
        data["fileNotes"] = this.fileNotes;
        data["splitType"] = this.splitType;
        data["splitIntoNParts"] = this.splitIntoNParts;
        if (Array.isArray(this.typeList)) {
            data["typeList"] = [];
            for (let item of this.typeList)
                data["typeList"].push(item.toJSON());
        }
        if (Array.isArray(this.layoutlist)) {
            data["layoutlist"] = [];
            for (let item of this.layoutlist)
                data["layoutlist"].push(item.toJSON());
        }
        if (Array.isArray(this.sortList)) {
            data["sortList"] = [];
            for (let item of this.sortList)
                data["sortList"].push(item.toJSON());
        }
        if (Array.isArray(this.pgpKeyList)) {
            data["pgpKeyList"] = [];
            for (let item of this.pgpKeyList)
                data["pgpKeyList"].push(item.toJSON());
        }
        if (Array.isArray(this.shipToList)) {
            data["shipToList"] = [];
            for (let item of this.shipToList)
                data["shipToList"].push(item.toJSON());
        }
        if (Array.isArray(this.mediaList)) {
            data["mediaList"] = [];
            for (let item of this.mediaList)
                data["mediaList"].push(item.toJSON());
        }
        data["layoutDescription"] = this.layoutDescription;
        data["shipCCEmail"] = this.shipCCEmail;
        data["shipSubject"] = this.shipSubject;
        data["shipNotes"] = this.shipNotes;
        data["shippedDate"] = this.shippedDate;
        return data; 
    }
}

export interface IGetCampaignsOutputDto {
    id: number | undefined;
    label: string | undefined;
    ftpSite: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    ftpPassword: string | undefined;
    type: string | undefined;
    layout: string | undefined;
    isHeaderRow: boolean | undefined;
    isDataFileOnly: boolean | undefined;
    isUnzipped: boolean | undefined;
    sort: string | undefined;
    pgpKey: string | undefined;
    shipTo: string | undefined;
    email: string | undefined;
    layoutId: string | undefined;
    iHasKeyCode: number | undefined;
    totalOutputQuantity: number | undefined;
    media: string | undefined;
    fileLabel: string | undefined;
    fileNotes: string | undefined;
    splitType: number | undefined;
    splitIntoNParts: number | undefined;
    typeList: DropdownOutputDto[] | undefined;
    layoutlist: DropdownOutputDto[] | undefined;
    sortList: DropdownOutputDto[] | undefined;
    pgpKeyList: DropdownOutputDto[] | undefined;
    shipToList: DropdownOutputDto[] | undefined;
    mediaList: DropdownOutputDto[] | undefined;
    layoutDescription: string | undefined;
    shipCCEmail: string | undefined;
    shipSubject: string | undefined;
    shipNotes: string | undefined;
    shippedDate: string | undefined;
}

export class Campaign implements ICampaign {
    buildID!: number | undefined;
    mailerID!: number | undefined;
    offerID!: number | undefined;
    cOrderType!: string;
    userID!: number | undefined;
    iIsOrder!: boolean | undefined;
    cDescription!: string;
    iProvidedCount!: number | undefined;
    iIsRandomExecution!: boolean | undefined;
    iIsNetUse!: boolean | undefined;
    dDateLastRun!: moment.Moment | undefined;
    cSortFields!: string;
    cOrderNo!: string;
    cLVAOrderNo!: string | undefined;
    cNextMarkOrderNo!: string;
    cBrokerPONo!: string | undefined;
    cNotes!: string | undefined;
    iDecoyQty!: number | undefined;
    iDecoyKeyMethod!: number | undefined;
    cDecoyKey!: string;
    cDecoysByKeycode!: boolean | undefined;
    cSpecialProcess!: string | undefined;
    cShiptoType!: string;
    cShipTOEmail!: string | undefined;
    cShipCCEmail!: string | undefined;
    cShipSUBJECT!: string;
    dShipDateShipped!: moment.Moment | undefined;
    lK_ExportFileFormatID!: string | undefined;
    iIsAddHeader!: boolean | undefined;
    iIsUncompressed!: boolean | undefined;
    lK_PGPKeyFile!: string | undefined;
    cDatabaseName!: string | undefined;
    iSplitType!: number | undefined;
    iSplitIntoNParts!: number | undefined;
    cExportLayout!: string | undefined;
    iIsNoUsage!: boolean | undefined;
    iHouseFilePriority!: boolean | undefined;
    cOutputCase!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    cOfferName!: string;
    divisionMailerID!: number | undefined;
    divisionBrokerID!: number | undefined;
    cDecoyKey1!: string | undefined;
    iAvailableQty!: number | undefined;
    dMailDate!: moment.Moment | undefined;
    iMailDatePlus!: number | undefined;
    iMailDateMinus!: number | undefined;
    iMinQuantityOrderLevelMaxPer!: number | undefined;
    iMaxQuantityOrderLevelMaxPer!: number | undefined;
    cMaxPerFieldOrderLevel!: string;
    cChannelType!: string | undefined;
    cFileLabel!: string;
    cSANNumber!: string | undefined;
    iIsExportDataFileOnly!: boolean | undefined;
    lK_Media!: string | undefined;
    lK_AccountCode!: string | undefined;
    cBillingCompany!: string | undefined;
    cBillingPhone!: string | undefined;
    iExportLayoutID!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICampaign) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.buildID = data["buildID"];
            this.mailerID = data["mailerID"];
            this.offerID = data["offerID"];
            this.cOrderType = data["cOrderType"];
            this.userID = data["userID"];
            this.iIsOrder = data["iIsOrder"];
            this.cDescription = data["cDescription"];
            this.iProvidedCount = data["iProvidedCount"];
            this.iIsRandomExecution = data["iIsRandomExecution"];
            this.iIsNetUse = data["iIsNetUse"];
            this.dDateLastRun = data["dDateLastRun"] ? moment(data["dDateLastRun"].toString()) : <any>undefined;
            this.cSortFields = data["cSortFields"];
            this.cOrderNo = data["cOrderNo"];
            this.cLVAOrderNo = data["cLVAOrderNo"];
            this.cNextMarkOrderNo = data["cNextMarkOrderNo"];
            this.cBrokerPONo = data["cBrokerPONo"];
            this.cNotes = data["cNotes"];
            this.iDecoyQty = data["iDecoyQty"];
            this.iDecoyKeyMethod = data["iDecoyKeyMethod"];
            this.cDecoyKey = data["cDecoyKey"];
            this.cDecoysByKeycode = data["cDecoysByKeycode"];
            this.cSpecialProcess = data["cSpecialProcess"];
            this.cShiptoType = data["cShiptoType"];
            this.cShipTOEmail = data["cShipTOEmail"];
            this.cShipCCEmail = data["cShipCCEmail"];
            this.cShipSUBJECT = data["cShipSUBJECT"];
            this.dShipDateShipped = data["dShipDateShipped"] ? moment(data["dShipDateShipped"].toString()) : <any>undefined;
            this.lK_ExportFileFormatID = data["lK_ExportFileFormatID"];
            this.iIsAddHeader = data["iIsAddHeader"];
            this.iIsUncompressed = data["iIsUncompressed"];
            this.lK_PGPKeyFile = data["lK_PGPKeyFile"];
            this.cDatabaseName = data["cDatabaseName"];
            this.iSplitType = data["iSplitType"];
            this.iSplitIntoNParts = data["iSplitIntoNParts"];
            this.cExportLayout = data["cExportLayout"];
            this.iIsNoUsage = data["iIsNoUsage"];
            this.iHouseFilePriority = data["iHouseFilePriority"];
            this.cOutputCase = data["cOutputCase"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.cOfferName = data["cOfferName"];
            this.divisionMailerID = data["divisionMailerID"];
            this.divisionBrokerID = data["divisionBrokerID"];
            this.cDecoyKey1 = data["cDecoyKey1"];
            this.iAvailableQty = data["iAvailableQty"];
            this.dMailDate = data["dMailDate"] ? moment(data["dMailDate"].toString()) : <any>undefined;
            this.iMailDatePlus = data["iMailDatePlus"];
            this.iMailDateMinus = data["iMailDateMinus"];
            this.iMinQuantityOrderLevelMaxPer = data["iMinQuantityOrderLevelMaxPer"];
            this.iMaxQuantityOrderLevelMaxPer = data["iMaxQuantityOrderLevelMaxPer"];
            this.cMaxPerFieldOrderLevel = data["cMaxPerFieldOrderLevel"];
            this.cChannelType = data["cChannelType"];
            this.cFileLabel = data["cFileLabel"];
            this.cSANNumber = data["cSANNumber"];
            this.iIsExportDataFileOnly = data["iIsExportDataFileOnly"];
            this.lK_Media = data["lK_Media"];
            this.lK_AccountCode = data["lK_AccountCode"];
            this.cBillingCompany = data["cBillingCompany"];
            this.cBillingPhone = data["cBillingPhone"];
            this.iExportLayoutID = data["iExportLayoutID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Campaign {
        data = typeof data === 'object' ? data : {};
        let result = new Campaign();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buildID"] = this.buildID;
        data["mailerID"] = this.mailerID;
        data["offerID"] = this.offerID;
        data["cOrderType"] = this.cOrderType;
        data["userID"] = this.userID;
        data["iIsOrder"] = this.iIsOrder;
        data["cDescription"] = this.cDescription;
        data["iProvidedCount"] = this.iProvidedCount;
        data["iIsRandomExecution"] = this.iIsRandomExecution;
        data["iIsNetUse"] = this.iIsNetUse;
        data["dDateLastRun"] = this.dDateLastRun ? this.dDateLastRun.toISOString() : <any>undefined;
        data["cSortFields"] = this.cSortFields;
        data["cOrderNo"] = this.cOrderNo;
        data["cLVAOrderNo"] = this.cLVAOrderNo;
        data["cNextMarkOrderNo"] = this.cNextMarkOrderNo;
        data["cBrokerPONo"] = this.cBrokerPONo;
        data["cNotes"] = this.cNotes;
        data["iDecoyQty"] = this.iDecoyQty;
        data["iDecoyKeyMethod"] = this.iDecoyKeyMethod;
        data["cDecoyKey"] = this.cDecoyKey;
        data["cDecoysByKeycode"] = this.cDecoysByKeycode;
        data["cSpecialProcess"] = this.cSpecialProcess;
        data["cShiptoType"] = this.cShiptoType;
        data["cShipTOEmail"] = this.cShipTOEmail;
        data["cShipCCEmail"] = this.cShipCCEmail;
        data["cShipSUBJECT"] = this.cShipSUBJECT;
        data["dShipDateShipped"] = this.dShipDateShipped ? this.dShipDateShipped.toISOString() : <any>undefined;
        data["lK_ExportFileFormatID"] = this.lK_ExportFileFormatID;
        data["iIsAddHeader"] = this.iIsAddHeader;
        data["iIsUncompressed"] = this.iIsUncompressed;
        data["lK_PGPKeyFile"] = this.lK_PGPKeyFile;
        data["cDatabaseName"] = this.cDatabaseName;
        data["iSplitType"] = this.iSplitType;
        data["iSplitIntoNParts"] = this.iSplitIntoNParts;
        data["cExportLayout"] = this.cExportLayout;
        data["iIsNoUsage"] = this.iIsNoUsage;
        data["iHouseFilePriority"] = this.iHouseFilePriority;
        data["cOutputCase"] = this.cOutputCase;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["cOfferName"] = this.cOfferName;
        data["divisionMailerID"] = this.divisionMailerID;
        data["divisionBrokerID"] = this.divisionBrokerID;
        data["cDecoyKey1"] = this.cDecoyKey1;
        data["iAvailableQty"] = this.iAvailableQty;
        data["dMailDate"] = this.dMailDate ? this.dMailDate.toISOString() : <any>undefined;
        data["iMailDatePlus"] = this.iMailDatePlus;
        data["iMailDateMinus"] = this.iMailDateMinus;
        data["iMinQuantityOrderLevelMaxPer"] = this.iMinQuantityOrderLevelMaxPer;
        data["iMaxQuantityOrderLevelMaxPer"] = this.iMaxQuantityOrderLevelMaxPer;
        data["cMaxPerFieldOrderLevel"] = this.cMaxPerFieldOrderLevel;
        data["cChannelType"] = this.cChannelType;
        data["cFileLabel"] = this.cFileLabel;
        data["cSANNumber"] = this.cSANNumber;
        data["iIsExportDataFileOnly"] = this.iIsExportDataFileOnly;
        data["lK_Media"] = this.lK_Media;
        data["lK_AccountCode"] = this.lK_AccountCode;
        data["cBillingCompany"] = this.cBillingCompany;
        data["cBillingPhone"] = this.cBillingPhone;
        data["iExportLayoutID"] = this.iExportLayoutID;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICampaign {
    buildID: number | undefined;
    mailerID: number | undefined;
    offerID: number | undefined;
    cOrderType: string;
    userID: number | undefined;
    iIsOrder: boolean | undefined;
    cDescription: string;
    iProvidedCount: number | undefined;
    iIsRandomExecution: boolean | undefined;
    iIsNetUse: boolean | undefined;
    dDateLastRun: moment.Moment | undefined;
    cSortFields: string;
    cOrderNo: string;
    cLVAOrderNo: string | undefined;
    cNextMarkOrderNo: string;
    cBrokerPONo: string | undefined;
    cNotes: string | undefined;
    iDecoyQty: number | undefined;
    iDecoyKeyMethod: number | undefined;
    cDecoyKey: string;
    cDecoysByKeycode: boolean | undefined;
    cSpecialProcess: string | undefined;
    cShiptoType: string;
    cShipTOEmail: string | undefined;
    cShipCCEmail: string | undefined;
    cShipSUBJECT: string;
    dShipDateShipped: moment.Moment | undefined;
    lK_ExportFileFormatID: string | undefined;
    iIsAddHeader: boolean | undefined;
    iIsUncompressed: boolean | undefined;
    lK_PGPKeyFile: string | undefined;
    cDatabaseName: string | undefined;
    iSplitType: number | undefined;
    iSplitIntoNParts: number | undefined;
    cExportLayout: string | undefined;
    iIsNoUsage: boolean | undefined;
    iHouseFilePriority: boolean | undefined;
    cOutputCase: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    cOfferName: string;
    divisionMailerID: number | undefined;
    divisionBrokerID: number | undefined;
    cDecoyKey1: string | undefined;
    iAvailableQty: number | undefined;
    dMailDate: moment.Moment | undefined;
    iMailDatePlus: number | undefined;
    iMailDateMinus: number | undefined;
    iMinQuantityOrderLevelMaxPer: number | undefined;
    iMaxQuantityOrderLevelMaxPer: number | undefined;
    cMaxPerFieldOrderLevel: string;
    cChannelType: string | undefined;
    cFileLabel: string;
    cSANNumber: string | undefined;
    iIsExportDataFileOnly: boolean | undefined;
    lK_Media: string | undefined;
    lK_AccountCode: string | undefined;
    cBillingCompany: string | undefined;
    cBillingPhone: string | undefined;
    iExportLayoutID: number | undefined;
    id: number | undefined;
}

export class CampaignExportPartDto implements ICampaignExportPartDto {
    cPartNo!: string[] | undefined;
    segmentID!: number | undefined;
    iQuantity!: string[] | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    orderId!: number | undefined;
    segmentDescription!: string | undefined;
    outputQuantity!: number | undefined;
    providedQuantity!: number | undefined;
    iDedupeOrderSpecified!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICampaignExportPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["cPartNo"])) {
                this.cPartNo = [] as any;
                for (let item of data["cPartNo"])
                    this.cPartNo!.push(item);
            }
            this.segmentID = data["segmentID"];
            if (Array.isArray(data["iQuantity"])) {
                this.iQuantity = [] as any;
                for (let item of data["iQuantity"])
                    this.iQuantity!.push(item);
            }
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.orderId = data["orderId"];
            this.segmentDescription = data["segmentDescription"];
            this.outputQuantity = data["outputQuantity"];
            this.providedQuantity = data["providedQuantity"];
            this.iDedupeOrderSpecified = data["iDedupeOrderSpecified"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CampaignExportPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignExportPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cPartNo)) {
            data["cPartNo"] = [];
            for (let item of this.cPartNo)
                data["cPartNo"].push(item);
        }
        data["segmentID"] = this.segmentID;
        if (Array.isArray(this.iQuantity)) {
            data["iQuantity"] = [];
            for (let item of this.iQuantity)
                data["iQuantity"].push(item);
        }
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["orderId"] = this.orderId;
        data["segmentDescription"] = this.segmentDescription;
        data["outputQuantity"] = this.outputQuantity;
        data["providedQuantity"] = this.providedQuantity;
        data["iDedupeOrderSpecified"] = this.iDedupeOrderSpecified;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICampaignExportPartDto {
    cPartNo: string[] | undefined;
    segmentID: number | undefined;
    iQuantity: string[] | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    orderId: number | undefined;
    segmentDescription: string | undefined;
    outputQuantity: number | undefined;
    providedQuantity: number | undefined;
    iDedupeOrderSpecified: number | undefined;
    id: number | undefined;
}

export class GetCampaignMultidimensionalReportForViewDto implements IGetCampaignMultidimensionalReportForViewDto {
    action!: ActionType | undefined;
    cFieldName!: string | undefined;
    cFields!: string[] | undefined;
    cFieldDescription!: string | undefined;
    cType!: string | undefined;
    id!: number | undefined;
    isMulti!: string | undefined;
    iMultiBySegment!: boolean | undefined;
    cTypeName!: string | undefined;
    cSegmentNumbers!: string | undefined;
    extBuildId!: number | undefined;
    cFieldType!: string | undefined;
    cTableName!: string | undefined;

    constructor(data?: IGetCampaignMultidimensionalReportForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action = data["action"];
            this.cFieldName = data["cFieldName"];
            if (Array.isArray(data["cFields"])) {
                this.cFields = [] as any;
                for (let item of data["cFields"])
                    this.cFields!.push(item);
            }
            this.cFieldDescription = data["cFieldDescription"];
            this.cType = data["cType"];
            this.id = data["id"];
            this.isMulti = data["isMulti"];
            this.iMultiBySegment = data["iMultiBySegment"];
            this.cTypeName = data["cTypeName"];
            this.cSegmentNumbers = data["cSegmentNumbers"];
            this.extBuildId = data["extBuildId"];
            this.cFieldType = data["cFieldType"];
            this.cTableName = data["cTableName"];
        }
    }

    static fromJS(data: any): GetCampaignMultidimensionalReportForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignMultidimensionalReportForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["cFieldName"] = this.cFieldName;
        if (Array.isArray(this.cFields)) {
            data["cFields"] = [];
            for (let item of this.cFields)
                data["cFields"].push(item);
        }
        data["cFieldDescription"] = this.cFieldDescription;
        data["cType"] = this.cType;
        data["id"] = this.id;
        data["isMulti"] = this.isMulti;
        data["iMultiBySegment"] = this.iMultiBySegment;
        data["cTypeName"] = this.cTypeName;
        data["cSegmentNumbers"] = this.cSegmentNumbers;
        data["extBuildId"] = this.extBuildId;
        data["cFieldType"] = this.cFieldType;
        data["cTableName"] = this.cTableName;
        return data; 
    }
}

export interface IGetCampaignMultidimensionalReportForViewDto {
    action: ActionType | undefined;
    cFieldName: string | undefined;
    cFields: string[] | undefined;
    cFieldDescription: string | undefined;
    cType: string | undefined;
    id: number | undefined;
    isMulti: string | undefined;
    iMultiBySegment: boolean | undefined;
    cTypeName: string | undefined;
    cSegmentNumbers: string | undefined;
    extBuildId: number | undefined;
    cFieldType: string | undefined;
    cTableName: string | undefined;
}

export class CreateOrEditCampaignDto implements ICreateOrEditCampaignDto {
    currentStatus!: number | undefined;
    generalData!: CampaignGeneralDto | undefined;
    listOfXTabRecords!: GetCampaignXTabReportsListForView[] | undefined;
    listOfMultidimensionalRecords!: GetCampaignMultidimensionalReportForViewDto[] | undefined;
    campaignOutputDto!: EditCampaignsOutputDto | undefined;
    getOutputData!: GetCampaignsOutputDto | undefined;
    reportsData!: GetXtabReportsDataDto | undefined;
    documentsData!: CampaignAttachmentDto[] | undefined;
    multiReportsData!: GetMultidimensionalReportsDataDto | undefined;
    billingData!: CampaignBillingDto | undefined;
    maxPerData!: GetCampaignMaxPerForViewDto | undefined;
    decoyData!: GetDecoyForViewDto | undefined;
    isFavouriteCampaign!: boolean | undefined;
    divisionMailerId!: number | undefined;
    divisionBrokerId!: number | undefined;
    oessData!: CampaignOESSDto | undefined;
    isStatusChangeRequired!: boolean | undefined;
    isChannelTypeVisible!: boolean | undefined;
    documentFileSize!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCampaignDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentStatus = data["currentStatus"];
            this.generalData = data["generalData"] ? CampaignGeneralDto.fromJS(data["generalData"]) : <any>undefined;
            if (Array.isArray(data["listOfXTabRecords"])) {
                this.listOfXTabRecords = [] as any;
                for (let item of data["listOfXTabRecords"])
                    this.listOfXTabRecords!.push(GetCampaignXTabReportsListForView.fromJS(item));
            }
            if (Array.isArray(data["listOfMultidimensionalRecords"])) {
                this.listOfMultidimensionalRecords = [] as any;
                for (let item of data["listOfMultidimensionalRecords"])
                    this.listOfMultidimensionalRecords!.push(GetCampaignMultidimensionalReportForViewDto.fromJS(item));
            }
            this.campaignOutputDto = data["campaignOutputDto"] ? EditCampaignsOutputDto.fromJS(data["campaignOutputDto"]) : <any>undefined;
            this.getOutputData = data["getOutputData"] ? GetCampaignsOutputDto.fromJS(data["getOutputData"]) : <any>undefined;
            this.reportsData = data["reportsData"] ? GetXtabReportsDataDto.fromJS(data["reportsData"]) : <any>undefined;
            if (Array.isArray(data["documentsData"])) {
                this.documentsData = [] as any;
                for (let item of data["documentsData"])
                    this.documentsData!.push(CampaignAttachmentDto.fromJS(item));
            }
            this.multiReportsData = data["multiReportsData"] ? GetMultidimensionalReportsDataDto.fromJS(data["multiReportsData"]) : <any>undefined;
            this.billingData = data["billingData"] ? CampaignBillingDto.fromJS(data["billingData"]) : <any>undefined;
            this.maxPerData = data["maxPerData"] ? GetCampaignMaxPerForViewDto.fromJS(data["maxPerData"]) : <any>undefined;
            this.decoyData = data["decoyData"] ? GetDecoyForViewDto.fromJS(data["decoyData"]) : <any>undefined;
            this.isFavouriteCampaign = data["isFavouriteCampaign"];
            this.divisionMailerId = data["divisionMailerId"];
            this.divisionBrokerId = data["divisionBrokerId"];
            this.oessData = data["oessData"] ? CampaignOESSDto.fromJS(data["oessData"]) : <any>undefined;
            this.isStatusChangeRequired = data["isStatusChangeRequired"];
            this.isChannelTypeVisible = data["isChannelTypeVisible"];
            this.documentFileSize = data["documentFileSize"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCampaignDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCampaignDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentStatus"] = this.currentStatus;
        data["generalData"] = this.generalData ? this.generalData.toJSON() : <any>undefined;
        if (Array.isArray(this.listOfXTabRecords)) {
            data["listOfXTabRecords"] = [];
            for (let item of this.listOfXTabRecords)
                data["listOfXTabRecords"].push(item.toJSON());
        }
        if (Array.isArray(this.listOfMultidimensionalRecords)) {
            data["listOfMultidimensionalRecords"] = [];
            for (let item of this.listOfMultidimensionalRecords)
                data["listOfMultidimensionalRecords"].push(item.toJSON());
        }
        data["campaignOutputDto"] = this.campaignOutputDto ? this.campaignOutputDto.toJSON() : <any>undefined;
        data["getOutputData"] = this.getOutputData ? this.getOutputData.toJSON() : <any>undefined;
        data["reportsData"] = this.reportsData ? this.reportsData.toJSON() : <any>undefined;
        if (Array.isArray(this.documentsData)) {
            data["documentsData"] = [];
            for (let item of this.documentsData)
                data["documentsData"].push(item.toJSON());
        }
        data["multiReportsData"] = this.multiReportsData ? this.multiReportsData.toJSON() : <any>undefined;
        data["billingData"] = this.billingData ? this.billingData.toJSON() : <any>undefined;
        data["maxPerData"] = this.maxPerData ? this.maxPerData.toJSON() : <any>undefined;
        data["decoyData"] = this.decoyData ? this.decoyData.toJSON() : <any>undefined;
        data["isFavouriteCampaign"] = this.isFavouriteCampaign;
        data["divisionMailerId"] = this.divisionMailerId;
        data["divisionBrokerId"] = this.divisionBrokerId;
        data["oessData"] = this.oessData ? this.oessData.toJSON() : <any>undefined;
        data["isStatusChangeRequired"] = this.isStatusChangeRequired;
        data["isChannelTypeVisible"] = this.isChannelTypeVisible;
        data["documentFileSize"] = this.documentFileSize;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCampaignDto {
    currentStatus: number | undefined;
    generalData: CampaignGeneralDto | undefined;
    listOfXTabRecords: GetCampaignXTabReportsListForView[] | undefined;
    listOfMultidimensionalRecords: GetCampaignMultidimensionalReportForViewDto[] | undefined;
    campaignOutputDto: EditCampaignsOutputDto | undefined;
    getOutputData: GetCampaignsOutputDto | undefined;
    reportsData: GetXtabReportsDataDto | undefined;
    documentsData: CampaignAttachmentDto[] | undefined;
    multiReportsData: GetMultidimensionalReportsDataDto | undefined;
    billingData: CampaignBillingDto | undefined;
    maxPerData: GetCampaignMaxPerForViewDto | undefined;
    decoyData: GetDecoyForViewDto | undefined;
    isFavouriteCampaign: boolean | undefined;
    divisionMailerId: number | undefined;
    divisionBrokerId: number | undefined;
    oessData: CampaignOESSDto | undefined;
    isStatusChangeRequired: boolean | undefined;
    isChannelTypeVisible: boolean | undefined;
    documentFileSize: number | undefined;
    id: number | undefined;
}

export class CampaignGeneralDto implements ICampaignGeneralDto {
    cDescription!: string;
    cOfferName!: string | undefined;
    cOrderType!: string | undefined;
    databaseID!: number | undefined;
    buildID!: number | undefined;
    offerID!: number | undefined;
    mailer!: DropdownOutputDto | undefined;
    broker!: DropdownOutputDto | undefined;
    mailerDescription!: string | undefined;
    brokerDescription!: string | undefined;
    cChannelType!: string | undefined;
    hasUserMailer!: boolean | undefined;
    divisionalDatabase!: boolean | undefined;
    divisionID!: number | undefined;

    constructor(data?: ICampaignGeneralDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cDescription = data["cDescription"];
            this.cOfferName = data["cOfferName"];
            this.cOrderType = data["cOrderType"];
            this.databaseID = data["databaseID"];
            this.buildID = data["buildID"];
            this.offerID = data["offerID"];
            this.mailer = data["mailer"] ? DropdownOutputDto.fromJS(data["mailer"]) : <any>undefined;
            this.broker = data["broker"] ? DropdownOutputDto.fromJS(data["broker"]) : <any>undefined;
            this.mailerDescription = data["mailerDescription"];
            this.brokerDescription = data["brokerDescription"];
            this.cChannelType = data["cChannelType"];
            this.hasUserMailer = data["hasUserMailer"];
            this.divisionalDatabase = data["divisionalDatabase"];
            this.divisionID = data["divisionID"];
        }
    }

    static fromJS(data: any): CampaignGeneralDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignGeneralDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cDescription"] = this.cDescription;
        data["cOfferName"] = this.cOfferName;
        data["cOrderType"] = this.cOrderType;
        data["databaseID"] = this.databaseID;
        data["buildID"] = this.buildID;
        data["offerID"] = this.offerID;
        data["mailer"] = this.mailer ? this.mailer.toJSON() : <any>undefined;
        data["broker"] = this.broker ? this.broker.toJSON() : <any>undefined;
        data["mailerDescription"] = this.mailerDescription;
        data["brokerDescription"] = this.brokerDescription;
        data["cChannelType"] = this.cChannelType;
        data["hasUserMailer"] = this.hasUserMailer;
        data["divisionalDatabase"] = this.divisionalDatabase;
        data["divisionID"] = this.divisionID;
        return data; 
    }
}

export interface ICampaignGeneralDto {
    cDescription: string;
    cOfferName: string | undefined;
    cOrderType: string | undefined;
    databaseID: number | undefined;
    buildID: number | undefined;
    offerID: number | undefined;
    mailer: DropdownOutputDto | undefined;
    broker: DropdownOutputDto | undefined;
    mailerDescription: string | undefined;
    brokerDescription: string | undefined;
    cChannelType: string | undefined;
    hasUserMailer: boolean | undefined;
    divisionalDatabase: boolean | undefined;
    divisionID: number | undefined;
}

export class GetCampaignXTabReportsListForView implements IGetCampaignXTabReportsListForView {
    action!: ActionType | undefined;
    cXField!: string | undefined;
    cYField!: string | undefined;
    isXTab!: string | undefined;
    cType!: string | undefined;
    id!: number | undefined;
    cXDesc!: string | undefined;
    cYDesc!: string | undefined;
    iXTabBySegment!: boolean | undefined;
    cTypeName!: string | undefined;
    cSegmentNumbers!: string | undefined;

    constructor(data?: IGetCampaignXTabReportsListForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action = data["action"];
            this.cXField = data["cXField"];
            this.cYField = data["cYField"];
            this.isXTab = data["isXTab"];
            this.cType = data["cType"];
            this.id = data["id"];
            this.cXDesc = data["cXDesc"];
            this.cYDesc = data["cYDesc"];
            this.iXTabBySegment = data["iXTabBySegment"];
            this.cTypeName = data["cTypeName"];
            this.cSegmentNumbers = data["cSegmentNumbers"];
        }
    }

    static fromJS(data: any): GetCampaignXTabReportsListForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignXTabReportsListForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["cXField"] = this.cXField;
        data["cYField"] = this.cYField;
        data["isXTab"] = this.isXTab;
        data["cType"] = this.cType;
        data["id"] = this.id;
        data["cXDesc"] = this.cXDesc;
        data["cYDesc"] = this.cYDesc;
        data["iXTabBySegment"] = this.iXTabBySegment;
        data["cTypeName"] = this.cTypeName;
        data["cSegmentNumbers"] = this.cSegmentNumbers;
        return data; 
    }
}

export interface IGetCampaignXTabReportsListForView {
    action: ActionType | undefined;
    cXField: string | undefined;
    cYField: string | undefined;
    isXTab: string | undefined;
    cType: string | undefined;
    id: number | undefined;
    cXDesc: string | undefined;
    cYDesc: string | undefined;
    iXTabBySegment: boolean | undefined;
    cTypeName: string | undefined;
    cSegmentNumbers: string | undefined;
}

export class EditCampaignsOutputDto implements IEditCampaignsOutputDto {
    companyId!: number | undefined;
    type!: string | undefined;
    layoutDescription!: string | undefined;
    layout!: string | undefined;
    isHeaderRow!: boolean | undefined;
    isDataFileOnly!: boolean | undefined;
    isUnzipped!: boolean | undefined;
    sort!: string | undefined;
    pgpKey!: string | undefined;
    shipTo!: string | undefined;
    email!: string | undefined;
    ftpSite!: string | undefined;
    userName!: string | undefined;
    layoutId!: number | undefined;
    shipCCEmail!: string | undefined;
    shipSubject!: string | undefined;
    shipNotes!: string | undefined;
    shippedDate!: string | undefined;
    media!: string | undefined;
    fileLabel!: string | undefined;
    fileNotes!: string | undefined;
    splitType!: number | undefined;
    splitIntoNParts!: number | undefined;
    editCampaignExportPart!: EditCampaignExportPartDto[] | undefined;

    constructor(data?: IEditCampaignsOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyId = data["companyId"];
            this.type = data["type"];
            this.layoutDescription = data["layoutDescription"];
            this.layout = data["layout"];
            this.isHeaderRow = data["isHeaderRow"];
            this.isDataFileOnly = data["isDataFileOnly"];
            this.isUnzipped = data["isUnzipped"];
            this.sort = data["sort"];
            this.pgpKey = data["pgpKey"];
            this.shipTo = data["shipTo"];
            this.email = data["email"];
            this.ftpSite = data["ftpSite"];
            this.userName = data["userName"];
            this.layoutId = data["layoutId"];
            this.shipCCEmail = data["shipCCEmail"];
            this.shipSubject = data["shipSubject"];
            this.shipNotes = data["shipNotes"];
            this.shippedDate = data["shippedDate"];
            this.media = data["media"];
            this.fileLabel = data["fileLabel"];
            this.fileNotes = data["fileNotes"];
            this.splitType = data["splitType"];
            this.splitIntoNParts = data["splitIntoNParts"];
            if (Array.isArray(data["editCampaignExportPart"])) {
                this.editCampaignExportPart = [] as any;
                for (let item of data["editCampaignExportPart"])
                    this.editCampaignExportPart!.push(EditCampaignExportPartDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditCampaignsOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditCampaignsOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["type"] = this.type;
        data["layoutDescription"] = this.layoutDescription;
        data["layout"] = this.layout;
        data["isHeaderRow"] = this.isHeaderRow;
        data["isDataFileOnly"] = this.isDataFileOnly;
        data["isUnzipped"] = this.isUnzipped;
        data["sort"] = this.sort;
        data["pgpKey"] = this.pgpKey;
        data["shipTo"] = this.shipTo;
        data["email"] = this.email;
        data["ftpSite"] = this.ftpSite;
        data["userName"] = this.userName;
        data["layoutId"] = this.layoutId;
        data["shipCCEmail"] = this.shipCCEmail;
        data["shipSubject"] = this.shipSubject;
        data["shipNotes"] = this.shipNotes;
        data["shippedDate"] = this.shippedDate;
        data["media"] = this.media;
        data["fileLabel"] = this.fileLabel;
        data["fileNotes"] = this.fileNotes;
        data["splitType"] = this.splitType;
        data["splitIntoNParts"] = this.splitIntoNParts;
        if (Array.isArray(this.editCampaignExportPart)) {
            data["editCampaignExportPart"] = [];
            for (let item of this.editCampaignExportPart)
                data["editCampaignExportPart"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditCampaignsOutputDto {
    companyId: number | undefined;
    type: string | undefined;
    layoutDescription: string | undefined;
    layout: string | undefined;
    isHeaderRow: boolean | undefined;
    isDataFileOnly: boolean | undefined;
    isUnzipped: boolean | undefined;
    sort: string | undefined;
    pgpKey: string | undefined;
    shipTo: string | undefined;
    email: string | undefined;
    ftpSite: string | undefined;
    userName: string | undefined;
    layoutId: number | undefined;
    shipCCEmail: string | undefined;
    shipSubject: string | undefined;
    shipNotes: string | undefined;
    shippedDate: string | undefined;
    media: string | undefined;
    fileLabel: string | undefined;
    fileNotes: string | undefined;
    splitType: number | undefined;
    splitIntoNParts: number | undefined;
    editCampaignExportPart: EditCampaignExportPartDto[] | undefined;
}

export class GetXtabReportsDataDto implements IGetXtabReportsDataDto {
    xFieldDropdown!: DropdownOutputDto[] | undefined;
    yFieldDropdown!: DropdownOutputDto[] | undefined;
    xtabRecords!: GetCampaignXTabReportsListForView[] | undefined;

    constructor(data?: IGetXtabReportsDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["xFieldDropdown"])) {
                this.xFieldDropdown = [] as any;
                for (let item of data["xFieldDropdown"])
                    this.xFieldDropdown!.push(DropdownOutputDto.fromJS(item));
            }
            if (Array.isArray(data["yFieldDropdown"])) {
                this.yFieldDropdown = [] as any;
                for (let item of data["yFieldDropdown"])
                    this.yFieldDropdown!.push(DropdownOutputDto.fromJS(item));
            }
            if (Array.isArray(data["xtabRecords"])) {
                this.xtabRecords = [] as any;
                for (let item of data["xtabRecords"])
                    this.xtabRecords!.push(GetCampaignXTabReportsListForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetXtabReportsDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetXtabReportsDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.xFieldDropdown)) {
            data["xFieldDropdown"] = [];
            for (let item of this.xFieldDropdown)
                data["xFieldDropdown"].push(item.toJSON());
        }
        if (Array.isArray(this.yFieldDropdown)) {
            data["yFieldDropdown"] = [];
            for (let item of this.yFieldDropdown)
                data["yFieldDropdown"].push(item.toJSON());
        }
        if (Array.isArray(this.xtabRecords)) {
            data["xtabRecords"] = [];
            for (let item of this.xtabRecords)
                data["xtabRecords"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetXtabReportsDataDto {
    xFieldDropdown: DropdownOutputDto[] | undefined;
    yFieldDropdown: DropdownOutputDto[] | undefined;
    xtabRecords: GetCampaignXTabReportsListForView[] | undefined;
}

export class GetMultidimensionalReportsDataDto implements IGetMultidimensionalReportsDataDto {
    fieldsDropdown!: DropdownOutputDto[] | undefined;
    multidimensionalRecords!: GetCampaignMultidimensionalReportForViewDto[] | undefined;

    constructor(data?: IGetMultidimensionalReportsDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["fieldsDropdown"])) {
                this.fieldsDropdown = [] as any;
                for (let item of data["fieldsDropdown"])
                    this.fieldsDropdown!.push(DropdownOutputDto.fromJS(item));
            }
            if (Array.isArray(data["multidimensionalRecords"])) {
                this.multidimensionalRecords = [] as any;
                for (let item of data["multidimensionalRecords"])
                    this.multidimensionalRecords!.push(GetCampaignMultidimensionalReportForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMultidimensionalReportsDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMultidimensionalReportsDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fieldsDropdown)) {
            data["fieldsDropdown"] = [];
            for (let item of this.fieldsDropdown)
                data["fieldsDropdown"].push(item.toJSON());
        }
        if (Array.isArray(this.multidimensionalRecords)) {
            data["multidimensionalRecords"] = [];
            for (let item of this.multidimensionalRecords)
                data["multidimensionalRecords"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMultidimensionalReportsDataDto {
    fieldsDropdown: DropdownOutputDto[] | undefined;
    multidimensionalRecords: GetCampaignMultidimensionalReportForViewDto[] | undefined;
}

export class CampaignBillingDto implements ICampaignBillingDto {
    lvaOrderNo!: string | undefined;
    isNoUsage!: boolean | undefined;
    isNetUse!: boolean | undefined;
    nextMarkOrderNo!: string | undefined;
    brokerPONo!: string | undefined;
    sanNumber!: string | undefined;

    constructor(data?: ICampaignBillingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lvaOrderNo = data["lvaOrderNo"];
            this.isNoUsage = data["isNoUsage"];
            this.isNetUse = data["isNetUse"];
            this.nextMarkOrderNo = data["nextMarkOrderNo"];
            this.brokerPONo = data["brokerPONo"];
            this.sanNumber = data["sanNumber"];
        }
    }

    static fromJS(data: any): CampaignBillingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignBillingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lvaOrderNo"] = this.lvaOrderNo;
        data["isNoUsage"] = this.isNoUsage;
        data["isNetUse"] = this.isNetUse;
        data["nextMarkOrderNo"] = this.nextMarkOrderNo;
        data["brokerPONo"] = this.brokerPONo;
        data["sanNumber"] = this.sanNumber;
        return data; 
    }
}

export interface ICampaignBillingDto {
    lvaOrderNo: string | undefined;
    isNoUsage: boolean | undefined;
    isNetUse: boolean | undefined;
    nextMarkOrderNo: string | undefined;
    brokerPONo: string | undefined;
    sanNumber: string | undefined;
}

export class GetCampaignMaxPerForViewDto implements IGetCampaignMaxPerForViewDto {
    getSegmentLevelMaxPerData!: SegmentLevelMaxPerDto[] | undefined;
    getMaxPerFieldDropdownData!: DropdownOutputDto[] | undefined;
    getCampaignLevelMaxPerData!: CampaignLevelMaxPerDto | undefined;
    campaignId!: number | undefined;

    constructor(data?: IGetCampaignMaxPerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["getSegmentLevelMaxPerData"])) {
                this.getSegmentLevelMaxPerData = [] as any;
                for (let item of data["getSegmentLevelMaxPerData"])
                    this.getSegmentLevelMaxPerData!.push(SegmentLevelMaxPerDto.fromJS(item));
            }
            if (Array.isArray(data["getMaxPerFieldDropdownData"])) {
                this.getMaxPerFieldDropdownData = [] as any;
                for (let item of data["getMaxPerFieldDropdownData"])
                    this.getMaxPerFieldDropdownData!.push(DropdownOutputDto.fromJS(item));
            }
            this.getCampaignLevelMaxPerData = data["getCampaignLevelMaxPerData"] ? CampaignLevelMaxPerDto.fromJS(data["getCampaignLevelMaxPerData"]) : <any>undefined;
            this.campaignId = data["campaignId"];
        }
    }

    static fromJS(data: any): GetCampaignMaxPerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignMaxPerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.getSegmentLevelMaxPerData)) {
            data["getSegmentLevelMaxPerData"] = [];
            for (let item of this.getSegmentLevelMaxPerData)
                data["getSegmentLevelMaxPerData"].push(item.toJSON());
        }
        if (Array.isArray(this.getMaxPerFieldDropdownData)) {
            data["getMaxPerFieldDropdownData"] = [];
            for (let item of this.getMaxPerFieldDropdownData)
                data["getMaxPerFieldDropdownData"].push(item.toJSON());
        }
        data["getCampaignLevelMaxPerData"] = this.getCampaignLevelMaxPerData ? this.getCampaignLevelMaxPerData.toJSON() : <any>undefined;
        data["campaignId"] = this.campaignId;
        return data; 
    }
}

export interface IGetCampaignMaxPerForViewDto {
    getSegmentLevelMaxPerData: SegmentLevelMaxPerDto[] | undefined;
    getMaxPerFieldDropdownData: DropdownOutputDto[] | undefined;
    getCampaignLevelMaxPerData: CampaignLevelMaxPerDto | undefined;
    campaignId: number | undefined;
}

export class GetDecoyForViewDto implements IGetDecoyForViewDto {
    decoy!: DecoyDto | undefined;
    listOfDecoys!: DecoyDto[] | undefined;
    isDecoyKeyMethod!: number | undefined;
    decoyByKeyCode!: boolean | undefined;
    decoyKey!: string | undefined;
    decoyKey1!: string | undefined;
    listOfDecoyGroup!: DropdownOutputDto[] | undefined;
    databasecDatabaseName!: string | undefined;
    listOfGroupsForEdit!: DropdownOutputDto[] | undefined;

    constructor(data?: IGetDecoyForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.decoy = data["decoy"] ? DecoyDto.fromJS(data["decoy"]) : <any>undefined;
            if (Array.isArray(data["listOfDecoys"])) {
                this.listOfDecoys = [] as any;
                for (let item of data["listOfDecoys"])
                    this.listOfDecoys!.push(DecoyDto.fromJS(item));
            }
            this.isDecoyKeyMethod = data["isDecoyKeyMethod"];
            this.decoyByKeyCode = data["decoyByKeyCode"];
            this.decoyKey = data["decoyKey"];
            this.decoyKey1 = data["decoyKey1"];
            if (Array.isArray(data["listOfDecoyGroup"])) {
                this.listOfDecoyGroup = [] as any;
                for (let item of data["listOfDecoyGroup"])
                    this.listOfDecoyGroup!.push(DropdownOutputDto.fromJS(item));
            }
            this.databasecDatabaseName = data["databasecDatabaseName"];
            if (Array.isArray(data["listOfGroupsForEdit"])) {
                this.listOfGroupsForEdit = [] as any;
                for (let item of data["listOfGroupsForEdit"])
                    this.listOfGroupsForEdit!.push(DropdownOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDecoyForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDecoyForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["decoy"] = this.decoy ? this.decoy.toJSON() : <any>undefined;
        if (Array.isArray(this.listOfDecoys)) {
            data["listOfDecoys"] = [];
            for (let item of this.listOfDecoys)
                data["listOfDecoys"].push(item.toJSON());
        }
        data["isDecoyKeyMethod"] = this.isDecoyKeyMethod;
        data["decoyByKeyCode"] = this.decoyByKeyCode;
        data["decoyKey"] = this.decoyKey;
        data["decoyKey1"] = this.decoyKey1;
        if (Array.isArray(this.listOfDecoyGroup)) {
            data["listOfDecoyGroup"] = [];
            for (let item of this.listOfDecoyGroup)
                data["listOfDecoyGroup"].push(item.toJSON());
        }
        data["databasecDatabaseName"] = this.databasecDatabaseName;
        if (Array.isArray(this.listOfGroupsForEdit)) {
            data["listOfGroupsForEdit"] = [];
            for (let item of this.listOfGroupsForEdit)
                data["listOfGroupsForEdit"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetDecoyForViewDto {
    decoy: DecoyDto | undefined;
    listOfDecoys: DecoyDto[] | undefined;
    isDecoyKeyMethod: number | undefined;
    decoyByKeyCode: boolean | undefined;
    decoyKey: string | undefined;
    decoyKey1: string | undefined;
    listOfDecoyGroup: DropdownOutputDto[] | undefined;
    databasecDatabaseName: string | undefined;
    listOfGroupsForEdit: DropdownOutputDto[] | undefined;
}

export class EditCampaignExportPartDto implements IEditCampaignExportPartDto {
    cPartNo!: string[] | undefined;
    segmentID!: number | undefined;
    iQuantity!: string[] | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    orderId!: number | undefined;
    segmentDescription!: string | undefined;
    outputQuantity!: number | undefined;
    providedQuantity!: number | undefined;
    iDedupeOrderSpecified!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEditCampaignExportPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["cPartNo"])) {
                this.cPartNo = [] as any;
                for (let item of data["cPartNo"])
                    this.cPartNo!.push(item);
            }
            this.segmentID = data["segmentID"];
            if (Array.isArray(data["iQuantity"])) {
                this.iQuantity = [] as any;
                for (let item of data["iQuantity"])
                    this.iQuantity!.push(item);
            }
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.orderId = data["orderId"];
            this.segmentDescription = data["segmentDescription"];
            this.outputQuantity = data["outputQuantity"];
            this.providedQuantity = data["providedQuantity"];
            this.iDedupeOrderSpecified = data["iDedupeOrderSpecified"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditCampaignExportPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditCampaignExportPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cPartNo)) {
            data["cPartNo"] = [];
            for (let item of this.cPartNo)
                data["cPartNo"].push(item);
        }
        data["segmentID"] = this.segmentID;
        if (Array.isArray(this.iQuantity)) {
            data["iQuantity"] = [];
            for (let item of this.iQuantity)
                data["iQuantity"].push(item);
        }
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["orderId"] = this.orderId;
        data["segmentDescription"] = this.segmentDescription;
        data["outputQuantity"] = this.outputQuantity;
        data["providedQuantity"] = this.providedQuantity;
        data["iDedupeOrderSpecified"] = this.iDedupeOrderSpecified;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditCampaignExportPartDto {
    cPartNo: string[] | undefined;
    segmentID: number | undefined;
    iQuantity: string[] | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    orderId: number | undefined;
    segmentDescription: string | undefined;
    outputQuantity: number | undefined;
    providedQuantity: number | undefined;
    iDedupeOrderSpecified: number | undefined;
    id: number | undefined;
}

export class CampaignLevelMaxPerDto implements ICampaignLevelMaxPerDto {
    cMinimumQuantity!: number | undefined;
    cMaximumQuantity!: number | undefined;
    cMaxPerFieldOrderLevel!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICampaignLevelMaxPerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cMinimumQuantity = data["cMinimumQuantity"];
            this.cMaximumQuantity = data["cMaximumQuantity"];
            this.cMaxPerFieldOrderLevel = data["cMaxPerFieldOrderLevel"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CampaignLevelMaxPerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignLevelMaxPerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cMinimumQuantity"] = this.cMinimumQuantity;
        data["cMaximumQuantity"] = this.cMaximumQuantity;
        data["cMaxPerFieldOrderLevel"] = this.cMaxPerFieldOrderLevel;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICampaignLevelMaxPerDto {
    cMinimumQuantity: number | undefined;
    cMaximumQuantity: number | undefined;
    cMaxPerFieldOrderLevel: string | undefined;
    id: number | undefined;
}

export class CampaignQueueDto implements ICampaignQueueDto {
    id!: number | undefined;
    cdescription!: string | undefined;
    dcreateddate!: string | undefined;
    cCreatedBy!: string | undefined;
    iStatus!: string | undefined;
    statusNumber!: number | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: string | undefined;
    cDivisionName!: string | undefined;
    databaseId!: number | undefined;
    iStopRequested!: string | undefined;
    cDatabaseName!: string | undefined;
    isLocked!: boolean | undefined;

    constructor(data?: ICampaignQueueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cdescription = data["cdescription"];
            this.dcreateddate = data["dcreateddate"];
            this.cCreatedBy = data["cCreatedBy"];
            this.iStatus = data["iStatus"];
            this.statusNumber = data["statusNumber"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"];
            this.cDivisionName = data["cDivisionName"];
            this.databaseId = data["databaseId"];
            this.iStopRequested = data["iStopRequested"];
            this.cDatabaseName = data["cDatabaseName"];
            this.isLocked = data["isLocked"];
        }
    }

    static fromJS(data: any): CampaignQueueDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignQueueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cdescription"] = this.cdescription;
        data["dcreateddate"] = this.dcreateddate;
        data["cCreatedBy"] = this.cCreatedBy;
        data["iStatus"] = this.iStatus;
        data["statusNumber"] = this.statusNumber;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate;
        data["cDivisionName"] = this.cDivisionName;
        data["databaseId"] = this.databaseId;
        data["iStopRequested"] = this.iStopRequested;
        data["cDatabaseName"] = this.cDatabaseName;
        data["isLocked"] = this.isLocked;
        return data; 
    }
}

export interface ICampaignQueueDto {
    id: number | undefined;
    cdescription: string | undefined;
    dcreateddate: string | undefined;
    cCreatedBy: string | undefined;
    iStatus: string | undefined;
    statusNumber: number | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: string | undefined;
    cDivisionName: string | undefined;
    databaseId: number | undefined;
    iStopRequested: string | undefined;
    cDatabaseName: string | undefined;
    isLocked: boolean | undefined;
}

export class CampaignCopyDto implements ICampaignCopyDto {
    campaignId!: number | undefined;
    mailer!: DropdownOutputDto | undefined;
    brokerId!: number | undefined;
    cDescription!: string | undefined;
    cOfferName!: string | undefined;
    databaseId!: number | undefined;
    buildId!: number | undefined;
    offerId!: number | undefined;
    divisionalMailer!: DropdownOutputDto | undefined;
    divisionalBroker!: DropdownOutputDto | undefined;
    divisionalDatabase!: boolean | undefined;
    numberOfCopies!: number | undefined;

    constructor(data?: ICampaignCopyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignId = data["campaignId"];
            this.mailer = data["mailer"] ? DropdownOutputDto.fromJS(data["mailer"]) : <any>undefined;
            this.brokerId = data["brokerId"];
            this.cDescription = data["cDescription"];
            this.cOfferName = data["cOfferName"];
            this.databaseId = data["databaseId"];
            this.buildId = data["buildId"];
            this.offerId = data["offerId"];
            this.divisionalMailer = data["divisionalMailer"] ? DropdownOutputDto.fromJS(data["divisionalMailer"]) : <any>undefined;
            this.divisionalBroker = data["divisionalBroker"] ? DropdownOutputDto.fromJS(data["divisionalBroker"]) : <any>undefined;
            this.divisionalDatabase = data["divisionalDatabase"];
            this.numberOfCopies = data["numberOfCopies"];
        }
    }

    static fromJS(data: any): CampaignCopyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignCopyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["mailer"] = this.mailer ? this.mailer.toJSON() : <any>undefined;
        data["brokerId"] = this.brokerId;
        data["cDescription"] = this.cDescription;
        data["cOfferName"] = this.cOfferName;
        data["databaseId"] = this.databaseId;
        data["buildId"] = this.buildId;
        data["offerId"] = this.offerId;
        data["divisionalMailer"] = this.divisionalMailer ? this.divisionalMailer.toJSON() : <any>undefined;
        data["divisionalBroker"] = this.divisionalBroker ? this.divisionalBroker.toJSON() : <any>undefined;
        data["divisionalDatabase"] = this.divisionalDatabase;
        data["numberOfCopies"] = this.numberOfCopies;
        return data; 
    }
}

export interface ICampaignCopyDto {
    campaignId: number | undefined;
    mailer: DropdownOutputDto | undefined;
    brokerId: number | undefined;
    cDescription: string | undefined;
    cOfferName: string | undefined;
    databaseId: number | undefined;
    buildId: number | undefined;
    offerId: number | undefined;
    divisionalMailer: DropdownOutputDto | undefined;
    divisionalBroker: DropdownOutputDto | undefined;
    divisionalDatabase: boolean | undefined;
    numberOfCopies: number | undefined;
}

export class GetCampaignForCopyOutputDto implements IGetCampaignForCopyOutputDto {
    builds!: DropdownOutputDto[] | undefined;
    offers!: DropdownOutputDto[] | undefined;
    userDatabaseMailerRecordCount!: number | undefined;
    campaignCopyData!: CampaignCopyDto | undefined;

    constructor(data?: IGetCampaignForCopyOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["builds"])) {
                this.builds = [] as any;
                for (let item of data["builds"])
                    this.builds!.push(DropdownOutputDto.fromJS(item));
            }
            if (Array.isArray(data["offers"])) {
                this.offers = [] as any;
                for (let item of data["offers"])
                    this.offers!.push(DropdownOutputDto.fromJS(item));
            }
            this.userDatabaseMailerRecordCount = data["userDatabaseMailerRecordCount"];
            this.campaignCopyData = data["campaignCopyData"] ? CampaignCopyDto.fromJS(data["campaignCopyData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCampaignForCopyOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignForCopyOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.builds)) {
            data["builds"] = [];
            for (let item of this.builds)
                data["builds"].push(item.toJSON());
        }
        if (Array.isArray(this.offers)) {
            data["offers"] = [];
            for (let item of this.offers)
                data["offers"].push(item.toJSON());
        }
        data["userDatabaseMailerRecordCount"] = this.userDatabaseMailerRecordCount;
        data["campaignCopyData"] = this.campaignCopyData ? this.campaignCopyData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCampaignForCopyOutputDto {
    builds: DropdownOutputDto[] | undefined;
    offers: DropdownOutputDto[] | undefined;
    userDatabaseMailerRecordCount: number | undefined;
    campaignCopyData: CampaignCopyDto | undefined;
}

export class GetAllDatabasesDropdownDto implements IGetAllDatabasesDropdownDto {
    databases!: DropdownOutputDto[] | undefined;
    defaultDatabase!: number | undefined;

    constructor(data?: IGetAllDatabasesDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["databases"])) {
                this.databases = [] as any;
                for (let item of data["databases"])
                    this.databases!.push(DropdownOutputDto.fromJS(item));
            }
            this.defaultDatabase = data["defaultDatabase"];
        }
    }

    static fromJS(data: any): GetAllDatabasesDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDatabasesDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.databases)) {
            data["databases"] = [];
            for (let item of this.databases)
                data["databases"].push(item.toJSON());
        }
        data["defaultDatabase"] = this.defaultDatabase;
        return data; 
    }
}

export interface IGetAllDatabasesDropdownDto {
    databases: DropdownOutputDto[] | undefined;
    defaultDatabase: number | undefined;
}

export class GetCampaignDropdownsDto implements IGetCampaignDropdownsDto {
    databases!: GetAllDatabasesDropdownDto | undefined;
    builds!: GetAllBuildDropdownOutputDto | undefined;
    divisionalDatabase!: boolean | undefined;
    defaultMailer!: DropdownOutputDto | undefined;
    defaultBroker!: DropdownOutputDto | undefined;
    offerID!: number | undefined;
    isShowCustomer!: boolean | undefined;

    constructor(data?: IGetCampaignDropdownsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databases = data["databases"] ? GetAllDatabasesDropdownDto.fromJS(data["databases"]) : <any>undefined;
            this.builds = data["builds"] ? GetAllBuildDropdownOutputDto.fromJS(data["builds"]) : <any>undefined;
            this.divisionalDatabase = data["divisionalDatabase"];
            this.defaultMailer = data["defaultMailer"] ? DropdownOutputDto.fromJS(data["defaultMailer"]) : <any>undefined;
            this.defaultBroker = data["defaultBroker"] ? DropdownOutputDto.fromJS(data["defaultBroker"]) : <any>undefined;
            this.offerID = data["offerID"];
            this.isShowCustomer = data["isShowCustomer"];
        }
    }

    static fromJS(data: any): GetCampaignDropdownsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCampaignDropdownsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databases"] = this.databases ? this.databases.toJSON() : <any>undefined;
        data["builds"] = this.builds ? this.builds.toJSON() : <any>undefined;
        data["divisionalDatabase"] = this.divisionalDatabase;
        data["defaultMailer"] = this.defaultMailer ? this.defaultMailer.toJSON() : <any>undefined;
        data["defaultBroker"] = this.defaultBroker ? this.defaultBroker.toJSON() : <any>undefined;
        data["offerID"] = this.offerID;
        data["isShowCustomer"] = this.isShowCustomer;
        return data; 
    }
}

export interface IGetCampaignDropdownsDto {
    databases: GetAllDatabasesDropdownDto | undefined;
    builds: GetAllBuildDropdownOutputDto | undefined;
    divisionalDatabase: boolean | undefined;
    defaultMailer: DropdownOutputDto | undefined;
    defaultBroker: DropdownOutputDto | undefined;
    offerID: number | undefined;
    isShowCustomer: boolean | undefined;
}

export class GetAllBuildDropdownOutputDto implements IGetAllBuildDropdownOutputDto {
    buildDropDown!: DropdownOutputDto[] | undefined;
    defaultSelection!: number | undefined;

    constructor(data?: IGetAllBuildDropdownOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["buildDropDown"])) {
                this.buildDropDown = [] as any;
                for (let item of data["buildDropDown"])
                    this.buildDropDown!.push(DropdownOutputDto.fromJS(item));
            }
            this.defaultSelection = data["defaultSelection"];
        }
    }

    static fromJS(data: any): GetAllBuildDropdownOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllBuildDropdownOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.buildDropDown)) {
            data["buildDropDown"] = [];
            for (let item of this.buildDropDown)
                data["buildDropDown"].push(item.toJSON());
        }
        data["defaultSelection"] = this.defaultSelection;
        return data; 
    }
}

export interface IGetAllBuildDropdownOutputDto {
    buildDropDown: DropdownOutputDto[] | undefined;
    defaultSelection: number | undefined;
}

export class UserDatabaseMailerDto implements IUserDatabaseMailerDto {
    count!: number | undefined;
    input!: GetUserDatabaseMailerForViewDto | undefined;
    databaseId!: number | undefined;
    isDivisionalMailerBroker!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IUserDatabaseMailerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            this.input = data["input"] ? GetUserDatabaseMailerForViewDto.fromJS(data["input"]) : <any>undefined;
            this.databaseId = data["databaseId"];
            this.isDivisionalMailerBroker = data["isDivisionalMailerBroker"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDatabaseMailerDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDatabaseMailerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["input"] = this.input ? this.input.toJSON() : <any>undefined;
        data["databaseId"] = this.databaseId;
        data["isDivisionalMailerBroker"] = this.isDivisionalMailerBroker;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserDatabaseMailerDto {
    count: number | undefined;
    input: GetUserDatabaseMailerForViewDto | undefined;
    databaseId: number | undefined;
    isDivisionalMailerBroker: boolean | undefined;
    id: number | undefined;
}

export class GetUserDatabaseMailerForViewDto implements IGetUserDatabaseMailerForViewDto {
    count!: number | undefined;
    mailerID!: number | undefined;
    cCreatedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    userId!: number | undefined;
    databaseId!: number | undefined;

    constructor(data?: IGetUserDatabaseMailerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            this.mailerID = data["mailerID"];
            this.cCreatedBy = data["cCreatedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.userId = data["userId"];
            this.databaseId = data["databaseId"];
        }
    }

    static fromJS(data: any): GetUserDatabaseMailerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDatabaseMailerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["mailerID"] = this.mailerID;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["databaseId"] = this.databaseId;
        return data; 
    }
}

export interface IGetUserDatabaseMailerForViewDto {
    count: number | undefined;
    mailerID: number | undefined;
    cCreatedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    userId: number | undefined;
    databaseId: number | undefined;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: moment.Moment | undefined;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? moment(data["serverTime"].toString()) : <any>undefined;
            if (Array.isArray(data["friends"])) {
                this.friends = [] as any;
                for (let item of data["friends"])
                    this.friends!.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (Array.isArray(this.friends)) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment | undefined;
    friends: FriendDto[] | undefined;
}

export class FriendDto implements IFriendDto {
    friendUserId!: number | undefined;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number | undefined;
    isOnline!: boolean | undefined;
    state!: FriendshipState | undefined;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }
}

export interface IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendshipState | undefined;
}

export enum FriendshipState {
    Accepted = 1,
    Blocked = 2,
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number | undefined;
    tenantId!: number | undefined;
    targetUserId!: number | undefined;
    targetTenantId!: number | undefined;
    side!: ChatSide | undefined;
    readState!: ChatMessageReadState | undefined;
    receiverReadState!: ChatMessageReadState | undefined;
    message!: string | undefined;
    creationTime!: moment.Moment | undefined;
    sharedMessageId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatSide | undefined;
    readState: ChatMessageReadState | undefined;
    receiverReadState: ChatMessageReadState | undefined;
    message: string | undefined;
    creationTime: moment.Moment | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;
}

export enum ChatSide {
    Sender = 1,
    Receiver = 2,
}

export enum ChatMessageReadState {
    Unread = 1,
    Read = 2,
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number | undefined;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class PagedResultDtoOfContactDto implements IPagedResultDtoOfContactDto {
    totalCount!: number | undefined;
    items!: ContactDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ContactDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfContactDto {
    totalCount: number | undefined;
    items: ContactDto[] | undefined;
}

export class ContactDto implements IContactDto {
    cFirstName!: string | undefined;
    cLastName!: string | undefined;
    cEmailAddress!: string | undefined;
    iIsActive!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cFirstName = data["cFirstName"];
            this.cLastName = data["cLastName"];
            this.cEmailAddress = data["cEmailAddress"];
            this.iIsActive = data["iIsActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cFirstName"] = this.cFirstName;
        data["cLastName"] = this.cLastName;
        data["cEmailAddress"] = this.cEmailAddress;
        data["iIsActive"] = this.iIsActive;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactDto {
    cFirstName: string | undefined;
    cLastName: string | undefined;
    cEmailAddress: string | undefined;
    iIsActive: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDatabaseDto implements IPagedResultDtoOfDatabaseDto {
    totalCount!: number | undefined;
    items!: DatabaseDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDatabaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(DatabaseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDatabaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDatabaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDatabaseDto {
    totalCount: number | undefined;
    items: DatabaseDto[] | undefined;
}

export class DatabaseDto implements IDatabaseDto {
    lK_DatabaseType!: string | undefined;
    cDatabaseName!: string | undefined;
    cListFileUploadedPath!: string | undefined;
    cListReadyToLoadPath!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    lK_AccountingDivisionCode!: string | undefined;
    cAdministratorEmail!: string | undefined;
    divisonName!: string | undefined;
    divisionId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IDatabaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lK_DatabaseType = data["lK_DatabaseType"];
            this.cDatabaseName = data["cDatabaseName"];
            this.cListFileUploadedPath = data["cListFileUploadedPath"];
            this.cListReadyToLoadPath = data["cListReadyToLoadPath"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.lK_AccountingDivisionCode = data["lK_AccountingDivisionCode"];
            this.cAdministratorEmail = data["cAdministratorEmail"];
            this.divisonName = data["divisonName"];
            this.divisionId = data["divisionId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DatabaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new DatabaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lK_DatabaseType"] = this.lK_DatabaseType;
        data["cDatabaseName"] = this.cDatabaseName;
        data["cListFileUploadedPath"] = this.cListFileUploadedPath;
        data["cListReadyToLoadPath"] = this.cListReadyToLoadPath;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["lK_AccountingDivisionCode"] = this.lK_AccountingDivisionCode;
        data["cAdministratorEmail"] = this.cAdministratorEmail;
        data["divisonName"] = this.divisonName;
        data["divisionId"] = this.divisionId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDatabaseDto {
    lK_DatabaseType: string | undefined;
    cDatabaseName: string | undefined;
    cListFileUploadedPath: string | undefined;
    cListReadyToLoadPath: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    lK_AccountingDivisionCode: string | undefined;
    cAdministratorEmail: string | undefined;
    divisonName: string | undefined;
    divisionId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditDatabaseDto implements ICreateOrEditDatabaseDto {
    lK_DatabaseType!: string;
    cDatabaseName!: string;
    cListFileUploadedPath!: string;
    cListReadyToLoadPath!: string;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    lK_AccountingDivisionCode!: string;
    cAdministratorEmail!: string | undefined;
    divisionId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditDatabaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lK_DatabaseType = data["lK_DatabaseType"];
            this.cDatabaseName = data["cDatabaseName"];
            this.cListFileUploadedPath = data["cListFileUploadedPath"];
            this.cListReadyToLoadPath = data["cListReadyToLoadPath"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.lK_AccountingDivisionCode = data["lK_AccountingDivisionCode"];
            this.cAdministratorEmail = data["cAdministratorEmail"];
            this.divisionId = data["divisionId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDatabaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDatabaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lK_DatabaseType"] = this.lK_DatabaseType;
        data["cDatabaseName"] = this.cDatabaseName;
        data["cListFileUploadedPath"] = this.cListFileUploadedPath;
        data["cListReadyToLoadPath"] = this.cListReadyToLoadPath;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["lK_AccountingDivisionCode"] = this.lK_AccountingDivisionCode;
        data["cAdministratorEmail"] = this.cAdministratorEmail;
        data["divisionId"] = this.divisionId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditDatabaseDto {
    lK_DatabaseType: string;
    cDatabaseName: string;
    cListFileUploadedPath: string;
    cListReadyToLoadPath: string;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    lK_AccountingDivisionCode: string;
    cAdministratorEmail: string | undefined;
    divisionId: number | undefined;
    id: number | undefined;
}

export class GetDatabaseDropDownsDto implements IGetDatabaseDropDownsDto {
    divisions!: DropdownOutputDto[] | undefined;
    defaultDivision!: number | undefined;
    databaseTypes!: DropdownOutputDto[] | undefined;
    defaultDatabaseType!: string | undefined;
    divisionCodes!: DropdownOutputDto[] | undefined;
    defaultDivisionCode!: string | undefined;

    constructor(data?: IGetDatabaseDropDownsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["divisions"])) {
                this.divisions = [] as any;
                for (let item of data["divisions"])
                    this.divisions!.push(DropdownOutputDto.fromJS(item));
            }
            this.defaultDivision = data["defaultDivision"];
            if (Array.isArray(data["databaseTypes"])) {
                this.databaseTypes = [] as any;
                for (let item of data["databaseTypes"])
                    this.databaseTypes!.push(DropdownOutputDto.fromJS(item));
            }
            this.defaultDatabaseType = data["defaultDatabaseType"];
            if (Array.isArray(data["divisionCodes"])) {
                this.divisionCodes = [] as any;
                for (let item of data["divisionCodes"])
                    this.divisionCodes!.push(DropdownOutputDto.fromJS(item));
            }
            this.defaultDivisionCode = data["defaultDivisionCode"];
        }
    }

    static fromJS(data: any): GetDatabaseDropDownsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDatabaseDropDownsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.divisions)) {
            data["divisions"] = [];
            for (let item of this.divisions)
                data["divisions"].push(item.toJSON());
        }
        data["defaultDivision"] = this.defaultDivision;
        if (Array.isArray(this.databaseTypes)) {
            data["databaseTypes"] = [];
            for (let item of this.databaseTypes)
                data["databaseTypes"].push(item.toJSON());
        }
        data["defaultDatabaseType"] = this.defaultDatabaseType;
        if (Array.isArray(this.divisionCodes)) {
            data["divisionCodes"] = [];
            for (let item of this.divisionCodes)
                data["divisionCodes"].push(item.toJSON());
        }
        data["defaultDivisionCode"] = this.defaultDivisionCode;
        return data; 
    }
}

export interface IGetDatabaseDropDownsDto {
    divisions: DropdownOutputDto[] | undefined;
    defaultDivision: number | undefined;
    databaseTypes: DropdownOutputDto[] | undefined;
    defaultDatabaseType: string | undefined;
    divisionCodes: DropdownOutputDto[] | undefined;
    defaultDivisionCode: string | undefined;
}

export class GetAllDatabaseForUserDto implements IGetAllDatabaseForUserDto {
    databases!: DropdownOutputDto[] | undefined;
    defaultDatabase!: number | undefined;

    constructor(data?: IGetAllDatabaseForUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["databases"])) {
                this.databases = [] as any;
                for (let item of data["databases"])
                    this.databases!.push(DropdownOutputDto.fromJS(item));
            }
            this.defaultDatabase = data["defaultDatabase"];
        }
    }

    static fromJS(data: any): GetAllDatabaseForUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDatabaseForUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.databases)) {
            data["databases"] = [];
            for (let item of this.databases)
                data["databases"].push(item.toJSON());
        }
        data["defaultDatabase"] = this.defaultDatabase;
        return data; 
    }
}

export interface IGetAllDatabaseForUserDto {
    databases: DropdownOutputDto[] | undefined;
    defaultDatabase: number | undefined;
}

export class PagedResultDtoOfMailerDto implements IPagedResultDtoOfMailerDto {
    totalCount!: number | undefined;
    items!: MailerDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMailerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MailerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMailerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMailerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMailerDto {
    totalCount: number | undefined;
    items: MailerDto[] | undefined;
}

export class MailerDto implements IMailerDto {
    cCode!: string | undefined;
    cCompany!: string | undefined;
    iIsActive!: boolean | undefined;
    cAddress!: string | undefined;
    databaseId!: number | undefined;
    contactsCount!: number | undefined;
    decoysCount!: number | undefined;
    cAddress1!: string | undefined;
    cAddress2!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cZip!: string | undefined;
    cPhone!: string | undefined;
    cFax!: string | undefined;
    broker!: string | undefined;
    contactsList!: CreateOrEditContactDto[] | undefined;
    showOffers!: boolean | undefined;
    showContacts!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IMailerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cCode = data["cCode"];
            this.cCompany = data["cCompany"];
            this.iIsActive = data["iIsActive"];
            this.cAddress = data["cAddress"];
            this.databaseId = data["databaseId"];
            this.contactsCount = data["contactsCount"];
            this.decoysCount = data["decoysCount"];
            this.cAddress1 = data["cAddress1"];
            this.cAddress2 = data["cAddress2"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cZip = data["cZip"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            this.broker = data["broker"];
            if (Array.isArray(data["contactsList"])) {
                this.contactsList = [] as any;
                for (let item of data["contactsList"])
                    this.contactsList!.push(CreateOrEditContactDto.fromJS(item));
            }
            this.showOffers = data["showOffers"];
            this.showContacts = data["showContacts"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MailerDto {
        data = typeof data === 'object' ? data : {};
        let result = new MailerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cCode"] = this.cCode;
        data["cCompany"] = this.cCompany;
        data["iIsActive"] = this.iIsActive;
        data["cAddress"] = this.cAddress;
        data["databaseId"] = this.databaseId;
        data["contactsCount"] = this.contactsCount;
        data["decoysCount"] = this.decoysCount;
        data["cAddress1"] = this.cAddress1;
        data["cAddress2"] = this.cAddress2;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cZip"] = this.cZip;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        data["broker"] = this.broker;
        if (Array.isArray(this.contactsList)) {
            data["contactsList"] = [];
            for (let item of this.contactsList)
                data["contactsList"].push(item.toJSON());
        }
        data["showOffers"] = this.showOffers;
        data["showContacts"] = this.showContacts;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMailerDto {
    cCode: string | undefined;
    cCompany: string | undefined;
    iIsActive: boolean | undefined;
    cAddress: string | undefined;
    databaseId: number | undefined;
    contactsCount: number | undefined;
    decoysCount: number | undefined;
    cAddress1: string | undefined;
    cAddress2: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cZip: string | undefined;
    cPhone: string | undefined;
    cFax: string | undefined;
    broker: string | undefined;
    contactsList: CreateOrEditContactDto[] | undefined;
    showOffers: boolean | undefined;
    showContacts: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDecoyDto implements IPagedResultDtoOfDecoyDto {
    totalCount!: number | undefined;
    items!: DecoyDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDecoyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(DecoyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDecoyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDecoyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDecoyDto {
    totalCount: number | undefined;
    items: DecoyDto[] | undefined;
}

export class CreateOrEditDecoyDto implements ICreateOrEditDecoyDto {
    mailerID!: number | undefined;
    cDecoyType!: string | undefined;
    cFirstName!: string | undefined;
    cLastName!: string | undefined;
    cName!: string | undefined;
    cAddress1!: string | undefined;
    cAddress2!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cZip!: string | undefined;
    cZip4!: string | undefined;
    cCompany!: string | undefined;
    cTitle!: string | undefined;
    cEmail!: string | undefined;
    cPhone!: string | undefined;
    cFax!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    cKeyCode1!: string | undefined;
    cDecoyGroup!: string | undefined;
    databaseId!: number | undefined;
    cAddress!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditDecoyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mailerID = data["mailerID"];
            this.cDecoyType = data["cDecoyType"];
            this.cFirstName = data["cFirstName"];
            this.cLastName = data["cLastName"];
            this.cName = data["cName"];
            this.cAddress1 = data["cAddress1"];
            this.cAddress2 = data["cAddress2"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cZip = data["cZip"];
            this.cZip4 = data["cZip4"];
            this.cCompany = data["cCompany"];
            this.cTitle = data["cTitle"];
            this.cEmail = data["cEmail"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.cKeyCode1 = data["cKeyCode1"];
            this.cDecoyGroup = data["cDecoyGroup"];
            this.databaseId = data["databaseId"];
            this.cAddress = data["cAddress"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDecoyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDecoyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailerID"] = this.mailerID;
        data["cDecoyType"] = this.cDecoyType;
        data["cFirstName"] = this.cFirstName;
        data["cLastName"] = this.cLastName;
        data["cName"] = this.cName;
        data["cAddress1"] = this.cAddress1;
        data["cAddress2"] = this.cAddress2;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cZip"] = this.cZip;
        data["cZip4"] = this.cZip4;
        data["cCompany"] = this.cCompany;
        data["cTitle"] = this.cTitle;
        data["cEmail"] = this.cEmail;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["cKeyCode1"] = this.cKeyCode1;
        data["cDecoyGroup"] = this.cDecoyGroup;
        data["databaseId"] = this.databaseId;
        data["cAddress"] = this.cAddress;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditDecoyDto {
    mailerID: number | undefined;
    cDecoyType: string | undefined;
    cFirstName: string | undefined;
    cLastName: string | undefined;
    cName: string | undefined;
    cAddress1: string | undefined;
    cAddress2: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cZip: string | undefined;
    cZip4: string | undefined;
    cCompany: string | undefined;
    cTitle: string | undefined;
    cEmail: string | undefined;
    cPhone: string | undefined;
    cFax: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    cKeyCode1: string | undefined;
    cDecoyGroup: string | undefined;
    databaseId: number | undefined;
    cAddress: string | undefined;
    id: number | undefined;
}

export class GetAllDecoysInput implements IGetAllDecoysInput {
    filter!: string | undefined;
    selectedDatabase!: number | undefined;
    mailerId!: number | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IGetAllDecoysInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.selectedDatabase = data["selectedDatabase"];
            this.mailerId = data["mailerId"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAllDecoysInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDecoysInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["selectedDatabase"] = this.selectedDatabase;
        data["mailerId"] = this.mailerId;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IGetAllDecoysInput {
    filter: string | undefined;
    selectedDatabase: number | undefined;
    mailerId: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString!: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateString = data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class StringOutput implements IStringOutput {
    output!: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.output = data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class PagedResultDtoOfGetDivisionBrokerForViewDto implements IPagedResultDtoOfGetDivisionBrokerForViewDto {
    totalCount!: number | undefined;
    items!: GetDivisionBrokerForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDivisionBrokerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetDivisionBrokerForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDivisionBrokerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDivisionBrokerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetDivisionBrokerForViewDto {
    totalCount: number | undefined;
    items: GetDivisionBrokerForViewDto[] | undefined;
}

export class GetDivisionBrokerForViewDto implements IGetDivisionBrokerForViewDto {
    divisionBroker!: DivisionBrokerDto | undefined;

    constructor(data?: IGetDivisionBrokerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.divisionBroker = data["divisionBroker"] ? DivisionBrokerDto.fromJS(data["divisionBroker"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDivisionBrokerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDivisionBrokerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["divisionBroker"] = this.divisionBroker ? this.divisionBroker.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetDivisionBrokerForViewDto {
    divisionBroker: DivisionBrokerDto | undefined;
}

export class DivisionBrokerDto implements IDivisionBrokerDto {
    id!: number | undefined;

    constructor(data?: IDivisionBrokerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DivisionBrokerDto {
        data = typeof data === 'object' ? data : {};
        let result = new DivisionBrokerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IDivisionBrokerDto {
    id: number | undefined;
}

export class GetDivisionBrokerForEditOutput implements IGetDivisionBrokerForEditOutput {
    divisionBroker!: CreateOrEditDivisionBrokerDto | undefined;

    constructor(data?: IGetDivisionBrokerForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.divisionBroker = data["divisionBroker"] ? CreateOrEditDivisionBrokerDto.fromJS(data["divisionBroker"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDivisionBrokerForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDivisionBrokerForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["divisionBroker"] = this.divisionBroker ? this.divisionBroker.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetDivisionBrokerForEditOutput {
    divisionBroker: CreateOrEditDivisionBrokerDto | undefined;
}

export class CreateOrEditDivisionBrokerDto implements ICreateOrEditDivisionBrokerDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditDivisionBrokerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDivisionBrokerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDivisionBrokerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditDivisionBrokerDto {
    id: number | undefined;
}

export class PagedResultDtoOfGetDivisionMailerForViewDto implements IPagedResultDtoOfGetDivisionMailerForViewDto {
    totalCount!: number | undefined;
    items!: GetDivisionMailerForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDivisionMailerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetDivisionMailerForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDivisionMailerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDivisionMailerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetDivisionMailerForViewDto {
    totalCount: number | undefined;
    items: GetDivisionMailerForViewDto[] | undefined;
}

export class GetDivisionMailerForViewDto implements IGetDivisionMailerForViewDto {
    divisionName!: string | undefined;
    id!: number | undefined;
    code!: string | undefined;
    company!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    cAddr1!: string | undefined;
    cAddr2!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cPhone!: string | undefined;
    cZip!: string | undefined;
    cFax!: string | undefined;
    email!: string | undefined;
    notes!: string | undefined;
    isActive!: boolean | undefined;

    constructor(data?: IGetDivisionMailerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.divisionName = data["divisionName"];
            this.id = data["id"];
            this.code = data["code"];
            this.company = data["company"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.cAddr1 = data["cAddr1"];
            this.cAddr2 = data["cAddr2"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cPhone = data["cPhone"];
            this.cZip = data["cZip"];
            this.cFax = data["cFax"];
            this.email = data["email"];
            this.notes = data["notes"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): GetDivisionMailerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDivisionMailerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["divisionName"] = this.divisionName;
        data["id"] = this.id;
        data["code"] = this.code;
        data["company"] = this.company;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["cAddr1"] = this.cAddr1;
        data["cAddr2"] = this.cAddr2;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cPhone"] = this.cPhone;
        data["cZip"] = this.cZip;
        data["cFax"] = this.cFax;
        data["email"] = this.email;
        data["notes"] = this.notes;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IGetDivisionMailerForViewDto {
    divisionName: string | undefined;
    id: number | undefined;
    code: string | undefined;
    company: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cAddr1: string | undefined;
    cAddr2: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cPhone: string | undefined;
    cZip: string | undefined;
    cFax: string | undefined;
    email: string | undefined;
    notes: string | undefined;
    isActive: boolean | undefined;
}

export class CreateOrEditDivisionMailerDto implements ICreateOrEditDivisionMailerDto {
    divisionId!: number | undefined;
    cCode!: string | undefined;
    cCompany!: string | undefined;
    cFirstName!: string | undefined;
    cLastName!: string | undefined;
    cAddr1!: string | undefined;
    cAddr2!: string | undefined;
    cAddr3!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cZip!: string | undefined;
    cCountry!: string | undefined;
    cPhone!: string | undefined;
    cFax!: string | undefined;
    cEmail!: string | undefined;
    mNotes!: string | undefined;
    iIsActive!: boolean | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditDivisionMailerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.divisionId = data["divisionId"];
            this.cCode = data["cCode"];
            this.cCompany = data["cCompany"];
            this.cFirstName = data["cFirstName"];
            this.cLastName = data["cLastName"];
            this.cAddr1 = data["cAddr1"];
            this.cAddr2 = data["cAddr2"];
            this.cAddr3 = data["cAddr3"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cZip = data["cZip"];
            this.cCountry = data["cCountry"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            this.cEmail = data["cEmail"];
            this.mNotes = data["mNotes"];
            this.iIsActive = data["iIsActive"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDivisionMailerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDivisionMailerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["divisionId"] = this.divisionId;
        data["cCode"] = this.cCode;
        data["cCompany"] = this.cCompany;
        data["cFirstName"] = this.cFirstName;
        data["cLastName"] = this.cLastName;
        data["cAddr1"] = this.cAddr1;
        data["cAddr2"] = this.cAddr2;
        data["cAddr3"] = this.cAddr3;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cZip"] = this.cZip;
        data["cCountry"] = this.cCountry;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        data["cEmail"] = this.cEmail;
        data["mNotes"] = this.mNotes;
        data["iIsActive"] = this.iIsActive;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditDivisionMailerDto {
    divisionId: number | undefined;
    cCode: string | undefined;
    cCompany: string | undefined;
    cFirstName: string | undefined;
    cLastName: string | undefined;
    cAddr1: string | undefined;
    cAddr2: string | undefined;
    cAddr3: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cZip: string | undefined;
    cCountry: string | undefined;
    cPhone: string | undefined;
    cFax: string | undefined;
    cEmail: string | undefined;
    mNotes: string | undefined;
    iIsActive: boolean | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    id: number | undefined;
}

export class GetAllDivisionMailersInput implements IGetAllDivisionMailersInput {
    filter!: string | undefined;
    isActive!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IGetAllDivisionMailersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.isActive = data["isActive"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAllDivisionMailersInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDivisionMailersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IGetAllDivisionMailersInput {
    filter: string | undefined;
    isActive: string | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class PagedResultDtoOfGetDivisionShipToForViewDto implements IPagedResultDtoOfGetDivisionShipToForViewDto {
    totalCount!: number | undefined;
    items!: GetDivisionShipToForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDivisionShipToForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetDivisionShipToForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDivisionShipToForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDivisionShipToForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetDivisionShipToForViewDto {
    totalCount: number | undefined;
    items: GetDivisionShipToForViewDto[] | undefined;
}

export class GetDivisionShipToForViewDto implements IGetDivisionShipToForViewDto {
    id!: number | undefined;
    cCode!: string | undefined;
    cCompany!: string | undefined;
    cFirstName!: string | undefined;
    cLastName!: string | undefined;
    cCountry!: string | undefined;
    cPhone!: string | undefined;
    cEmail!: string | undefined;
    divisionName!: string | undefined;

    constructor(data?: IGetDivisionShipToForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cCode = data["cCode"];
            this.cCompany = data["cCompany"];
            this.cFirstName = data["cFirstName"];
            this.cLastName = data["cLastName"];
            this.cCountry = data["cCountry"];
            this.cPhone = data["cPhone"];
            this.cEmail = data["cEmail"];
            this.divisionName = data["divisionName"];
        }
    }

    static fromJS(data: any): GetDivisionShipToForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDivisionShipToForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cCode"] = this.cCode;
        data["cCompany"] = this.cCompany;
        data["cFirstName"] = this.cFirstName;
        data["cLastName"] = this.cLastName;
        data["cCountry"] = this.cCountry;
        data["cPhone"] = this.cPhone;
        data["cEmail"] = this.cEmail;
        data["divisionName"] = this.divisionName;
        return data; 
    }
}

export interface IGetDivisionShipToForViewDto {
    id: number | undefined;
    cCode: string | undefined;
    cCompany: string | undefined;
    cFirstName: string | undefined;
    cLastName: string | undefined;
    cCountry: string | undefined;
    cPhone: string | undefined;
    cEmail: string | undefined;
    divisionName: string | undefined;
}

export class CreateOrEditDivisionShipToDto implements ICreateOrEditDivisionShipToDto {
    cCode!: string | undefined;
    cCompany!: string | undefined;
    cFirstName!: string | undefined;
    cLastName!: string | undefined;
    cAddress1!: string | undefined;
    cAddress2!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cZip!: string | undefined;
    cCountry!: string | undefined;
    cPhone!: string | undefined;
    cFax!: string | undefined;
    cEmail!: string | undefined;
    cNotes!: string | undefined;
    cFTPServer!: string | undefined;
    cUserID!: string | undefined;
    cPassword!: string | undefined;
    iIsActive!: boolean | undefined;
    divisionID!: number | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditDivisionShipToDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cCode = data["cCode"];
            this.cCompany = data["cCompany"];
            this.cFirstName = data["cFirstName"];
            this.cLastName = data["cLastName"];
            this.cAddress1 = data["cAddress1"];
            this.cAddress2 = data["cAddress2"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cZip = data["cZip"];
            this.cCountry = data["cCountry"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            this.cEmail = data["cEmail"];
            this.cNotes = data["cNotes"];
            this.cFTPServer = data["cFTPServer"];
            this.cUserID = data["cUserID"];
            this.cPassword = data["cPassword"];
            this.iIsActive = data["iIsActive"];
            this.divisionID = data["divisionID"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDivisionShipToDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDivisionShipToDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cCode"] = this.cCode;
        data["cCompany"] = this.cCompany;
        data["cFirstName"] = this.cFirstName;
        data["cLastName"] = this.cLastName;
        data["cAddress1"] = this.cAddress1;
        data["cAddress2"] = this.cAddress2;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cZip"] = this.cZip;
        data["cCountry"] = this.cCountry;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        data["cEmail"] = this.cEmail;
        data["cNotes"] = this.cNotes;
        data["cFTPServer"] = this.cFTPServer;
        data["cUserID"] = this.cUserID;
        data["cPassword"] = this.cPassword;
        data["iIsActive"] = this.iIsActive;
        data["divisionID"] = this.divisionID;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditDivisionShipToDto {
    cCode: string | undefined;
    cCompany: string | undefined;
    cFirstName: string | undefined;
    cLastName: string | undefined;
    cAddress1: string | undefined;
    cAddress2: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cZip: string | undefined;
    cCountry: string | undefined;
    cPhone: string | undefined;
    cFax: string | undefined;
    cEmail: string | undefined;
    cNotes: string | undefined;
    cFTPServer: string | undefined;
    cUserID: string | undefined;
    cPassword: string | undefined;
    iIsActive: boolean | undefined;
    divisionID: number | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    id: number | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    trialDayCount!: number | undefined;
    expiringEditionDisplayName!: string | undefined;
    id!: number | undefined;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.dailyPrice = data["dailyPrice"];
            this.weeklyPrice = data["weeklyPrice"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.trialDayCount = data["trialDayCount"];
            this.expiringEditionDisplayName = data["expiringEditionDisplayName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto | undefined;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (Array.isArray(data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(data["features"])) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator | undefined;
    itemSource!: LocalizableComboboxItemSourceDto | undefined;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes![key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;
}

export class IValueValidator implements IIValueValidator {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            if (data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition!: EditionCreateDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionCreateDto.fromJS(data["edition"]) : new EditionCreateDto();
            if (Array.isArray(data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];
}

export class EditionCreateDto implements IEditionCreateDto {
    id!: number | undefined;
    displayName!: string;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.dailyPrice = data["dailyPrice"];
            this.weeklyPrice = data["weeklyPrice"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (Array.isArray(data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId!: number | undefined;
    targetEditionId!: number | undefined;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceEditionId = data["sourceEditionId"];
            this.targetEditionId = data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data; 
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number | undefined;
    targetEditionId: number | undefined;
}

export class PagedResultDtoOfGetExportLayoutDetailForViewDto implements IPagedResultDtoOfGetExportLayoutDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetExportLayoutDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetExportLayoutDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetExportLayoutDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetExportLayoutDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetExportLayoutDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetExportLayoutDetailForViewDto {
    totalCount: number | undefined;
    items: GetExportLayoutDetailForViewDto[] | undefined;
}

export class GetExportLayoutDetailForViewDto implements IGetExportLayoutDetailForViewDto {
    exportLayoutDetail!: ExportLayoutDetailDto | undefined;
    exportLayoutcDescription!: string | undefined;

    constructor(data?: IGetExportLayoutDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exportLayoutDetail = data["exportLayoutDetail"] ? ExportLayoutDetailDto.fromJS(data["exportLayoutDetail"]) : <any>undefined;
            this.exportLayoutcDescription = data["exportLayoutcDescription"];
        }
    }

    static fromJS(data: any): GetExportLayoutDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetExportLayoutDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exportLayoutDetail"] = this.exportLayoutDetail ? this.exportLayoutDetail.toJSON() : <any>undefined;
        data["exportLayoutcDescription"] = this.exportLayoutcDescription;
        return data; 
    }
}

export interface IGetExportLayoutDetailForViewDto {
    exportLayoutDetail: ExportLayoutDetailDto | undefined;
    exportLayoutcDescription: string | undefined;
}

export class ExportLayoutDetailDto implements IExportLayoutDetailDto {
    exportLayoutId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IExportLayoutDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exportLayoutId = data["exportLayoutId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ExportLayoutDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportLayoutDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exportLayoutId"] = this.exportLayoutId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IExportLayoutDetailDto {
    exportLayoutId: number | undefined;
    id: number | undefined;
}

export class GetExportLayoutDetailForEditOutput implements IGetExportLayoutDetailForEditOutput {
    exportLayoutDetail!: CreateOrEditExportLayoutDetailDto | undefined;
    exportLayoutcDescription!: string | undefined;

    constructor(data?: IGetExportLayoutDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exportLayoutDetail = data["exportLayoutDetail"] ? CreateOrEditExportLayoutDetailDto.fromJS(data["exportLayoutDetail"]) : <any>undefined;
            this.exportLayoutcDescription = data["exportLayoutcDescription"];
        }
    }

    static fromJS(data: any): GetExportLayoutDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetExportLayoutDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exportLayoutDetail"] = this.exportLayoutDetail ? this.exportLayoutDetail.toJSON() : <any>undefined;
        data["exportLayoutcDescription"] = this.exportLayoutcDescription;
        return data; 
    }
}

export interface IGetExportLayoutDetailForEditOutput {
    exportLayoutDetail: CreateOrEditExportLayoutDetailDto | undefined;
    exportLayoutcDescription: string | undefined;
}

export class CreateOrEditExportLayoutDetailDto implements ICreateOrEditExportLayoutDetailDto {
    exportLayoutId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditExportLayoutDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exportLayoutId = data["exportLayoutId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditExportLayoutDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditExportLayoutDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exportLayoutId"] = this.exportLayoutId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditExportLayoutDetailDto {
    exportLayoutId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfExportLayoutDetailExportLayoutLookupTableDto implements IPagedResultDtoOfExportLayoutDetailExportLayoutLookupTableDto {
    totalCount!: number | undefined;
    items!: ExportLayoutDetailExportLayoutLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfExportLayoutDetailExportLayoutLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ExportLayoutDetailExportLayoutLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExportLayoutDetailExportLayoutLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfExportLayoutDetailExportLayoutLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfExportLayoutDetailExportLayoutLookupTableDto {
    totalCount: number | undefined;
    items: ExportLayoutDetailExportLayoutLookupTableDto[] | undefined;
}

export class ExportLayoutDetailExportLayoutLookupTableDto implements IExportLayoutDetailExportLayoutLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IExportLayoutDetailExportLayoutLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ExportLayoutDetailExportLayoutLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportLayoutDetailExportLayoutLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IExportLayoutDetailExportLayoutLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class GetExportLayoutSelectedFieldsDto implements IGetExportLayoutSelectedFieldsDto {
    id!: number | undefined;
    order!: number | undefined;
    fieldName!: string | undefined;
    outputFieldName!: string | undefined;
    formula!: string | undefined;
    width!: number | undefined;
    tablePrefix!: string | undefined;
    tableDescription!: string | undefined;
    iIsCalculatedField!: boolean | undefined;
    isFixedFields!: boolean | undefined;
    isFormulaEnabled!: boolean | undefined;
    tableId!: number | undefined;
    fieldDescription!: string | undefined;

    constructor(data?: IGetExportLayoutSelectedFieldsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.order = data["order"];
            this.fieldName = data["fieldName"];
            this.outputFieldName = data["outputFieldName"];
            this.formula = data["formula"];
            this.width = data["width"];
            this.tablePrefix = data["tablePrefix"];
            this.tableDescription = data["tableDescription"];
            this.iIsCalculatedField = data["iIsCalculatedField"];
            this.isFixedFields = data["isFixedFields"];
            this.isFormulaEnabled = data["isFormulaEnabled"];
            this.tableId = data["tableId"];
            this.fieldDescription = data["fieldDescription"];
        }
    }

    static fromJS(data: any): GetExportLayoutSelectedFieldsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetExportLayoutSelectedFieldsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["order"] = this.order;
        data["fieldName"] = this.fieldName;
        data["outputFieldName"] = this.outputFieldName;
        data["formula"] = this.formula;
        data["width"] = this.width;
        data["tablePrefix"] = this.tablePrefix;
        data["tableDescription"] = this.tableDescription;
        data["iIsCalculatedField"] = this.iIsCalculatedField;
        data["isFixedFields"] = this.isFixedFields;
        data["isFormulaEnabled"] = this.isFormulaEnabled;
        data["tableId"] = this.tableId;
        data["fieldDescription"] = this.fieldDescription;
        return data; 
    }
}

export interface IGetExportLayoutSelectedFieldsDto {
    id: number | undefined;
    order: number | undefined;
    fieldName: string | undefined;
    outputFieldName: string | undefined;
    formula: string | undefined;
    width: number | undefined;
    tablePrefix: string | undefined;
    tableDescription: string | undefined;
    iIsCalculatedField: boolean | undefined;
    isFixedFields: boolean | undefined;
    isFormulaEnabled: boolean | undefined;
    tableId: number | undefined;
    fieldDescription: string | undefined;
}

export class PagedResultDtoOfGetExportLayoutForViewDto implements IPagedResultDtoOfGetExportLayoutForViewDto {
    totalCount!: number | undefined;
    items!: GetExportLayoutForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetExportLayoutForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetExportLayoutForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetExportLayoutForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetExportLayoutForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetExportLayoutForViewDto {
    totalCount: number | undefined;
    items: GetExportLayoutForViewDto[] | undefined;
}

export class GetExportLayoutForViewDto implements IGetExportLayoutForViewDto {
    id!: number | undefined;
    cDescription!: string | undefined;
    iHasPhone!: boolean | undefined;
    iIsActive!: boolean | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    groupID!: number | undefined;
    iHasKeyCode!: boolean | undefined;
    cOutputCase!: string | undefined;
    cOutputCaseCode!: string | undefined;
    cGroupName!: string | undefined;
    databaseId!: number | undefined;

    constructor(data?: IGetExportLayoutForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cDescription = data["cDescription"];
            this.iHasPhone = data["iHasPhone"];
            this.iIsActive = data["iIsActive"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.groupID = data["groupID"];
            this.iHasKeyCode = data["iHasKeyCode"];
            this.cOutputCase = data["cOutputCase"];
            this.cOutputCaseCode = data["cOutputCaseCode"];
            this.cGroupName = data["cGroupName"];
            this.databaseId = data["databaseId"];
        }
    }

    static fromJS(data: any): GetExportLayoutForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetExportLayoutForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cDescription"] = this.cDescription;
        data["iHasPhone"] = this.iHasPhone;
        data["iIsActive"] = this.iIsActive;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["groupID"] = this.groupID;
        data["iHasKeyCode"] = this.iHasKeyCode;
        data["cOutputCase"] = this.cOutputCase;
        data["cOutputCaseCode"] = this.cOutputCaseCode;
        data["cGroupName"] = this.cGroupName;
        data["databaseId"] = this.databaseId;
        return data; 
    }
}

export interface IGetExportLayoutForViewDto {
    id: number | undefined;
    cDescription: string | undefined;
    iHasPhone: boolean | undefined;
    iIsActive: boolean | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    groupID: number | undefined;
    iHasKeyCode: boolean | undefined;
    cOutputCase: string | undefined;
    cOutputCaseCode: string | undefined;
    cGroupName: string | undefined;
    databaseId: number | undefined;
}

export class ExportLayoutFieldsDto implements IExportLayoutFieldsDto {
    id!: number | undefined;
    iExportOrder!: number | undefined;
    cOutputFieldName!: string | undefined;
    flddescr!: string | undefined;
    iWidth!: number | undefined;
    iIsCalculatedField!: boolean | undefined;

    constructor(data?: IExportLayoutFieldsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.iExportOrder = data["iExportOrder"];
            this.cOutputFieldName = data["cOutputFieldName"];
            this.flddescr = data["flddescr"];
            this.iWidth = data["iWidth"];
            this.iIsCalculatedField = data["iIsCalculatedField"];
        }
    }

    static fromJS(data: any): ExportLayoutFieldsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportLayoutFieldsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["iExportOrder"] = this.iExportOrder;
        data["cOutputFieldName"] = this.cOutputFieldName;
        data["flddescr"] = this.flddescr;
        data["iWidth"] = this.iWidth;
        data["iIsCalculatedField"] = this.iIsCalculatedField;
        return data; 
    }
}

export interface IExportLayoutFieldsDto {
    id: number | undefined;
    iExportOrder: number | undefined;
    cOutputFieldName: string | undefined;
    flddescr: string | undefined;
    iWidth: number | undefined;
    iIsCalculatedField: boolean | undefined;
}

export class CreateOrEditExportLayoutDto implements ICreateOrEditExportLayoutDto {
    id!: number | undefined;
    cDescription!: string | undefined;
    iHasPhone!: boolean | undefined;
    iIsActive!: boolean | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    groupID!: number | undefined;
    iHasKeyCode!: boolean | undefined;
    cOutputCase!: string | undefined;
    cOutputCaseCode!: string | undefined;
    iIsCalculatedField!: boolean | undefined;
    cGroupName!: string | undefined;
    databaseId!: number | undefined;

    constructor(data?: ICreateOrEditExportLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cDescription = data["cDescription"];
            this.iHasPhone = data["iHasPhone"];
            this.iIsActive = data["iIsActive"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.groupID = data["groupID"];
            this.iHasKeyCode = data["iHasKeyCode"];
            this.cOutputCase = data["cOutputCase"];
            this.cOutputCaseCode = data["cOutputCaseCode"];
            this.iIsCalculatedField = data["iIsCalculatedField"];
            this.cGroupName = data["cGroupName"];
            this.databaseId = data["databaseId"];
        }
    }

    static fromJS(data: any): CreateOrEditExportLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditExportLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cDescription"] = this.cDescription;
        data["iHasPhone"] = this.iHasPhone;
        data["iIsActive"] = this.iIsActive;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["groupID"] = this.groupID;
        data["iHasKeyCode"] = this.iHasKeyCode;
        data["cOutputCase"] = this.cOutputCase;
        data["cOutputCaseCode"] = this.cOutputCaseCode;
        data["iIsCalculatedField"] = this.iIsCalculatedField;
        data["cGroupName"] = this.cGroupName;
        data["databaseId"] = this.databaseId;
        return data; 
    }
}

export interface ICreateOrEditExportLayoutDto {
    id: number | undefined;
    cDescription: string | undefined;
    iHasPhone: boolean | undefined;
    iIsActive: boolean | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    groupID: number | undefined;
    iHasKeyCode: boolean | undefined;
    cOutputCase: string | undefined;
    cOutputCaseCode: string | undefined;
    iIsCalculatedField: boolean | undefined;
    cGroupName: string | undefined;
    databaseId: number | undefined;
}

export class PagedResultDtoOfGetCopyAllExportLayoutForViewDto implements IPagedResultDtoOfGetCopyAllExportLayoutForViewDto {
    totalCount!: number | undefined;
    items!: GetCopyAllExportLayoutForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCopyAllExportLayoutForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCopyAllExportLayoutForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCopyAllExportLayoutForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCopyAllExportLayoutForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCopyAllExportLayoutForViewDto {
    totalCount: number | undefined;
    items: GetCopyAllExportLayoutForViewDto[] | undefined;
}

export class GetCopyAllExportLayoutForViewDto implements IGetCopyAllExportLayoutForViewDto {
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IGetCopyAllExportLayoutForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetCopyAllExportLayoutForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCopyAllExportLayoutForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetCopyAllExportLayoutForViewDto {
    description: string | undefined;
    id: number | undefined;
}

export class CopyAllExportLayoutDto implements ICopyAllExportLayoutDto {
    databaseFromId!: number | undefined;
    groupFromId!: number | undefined;
    databaseToId!: number | undefined;
    groupToId!: number | undefined;
    layouts!: GetCopyAllExportLayoutForViewDto[] | undefined;

    constructor(data?: ICopyAllExportLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseFromId = data["databaseFromId"];
            this.groupFromId = data["groupFromId"];
            this.databaseToId = data["databaseToId"];
            this.groupToId = data["groupToId"];
            if (Array.isArray(data["layouts"])) {
                this.layouts = [] as any;
                for (let item of data["layouts"])
                    this.layouts!.push(GetCopyAllExportLayoutForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CopyAllExportLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new CopyAllExportLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseFromId"] = this.databaseFromId;
        data["groupFromId"] = this.groupFromId;
        data["databaseToId"] = this.databaseToId;
        data["groupToId"] = this.groupToId;
        if (Array.isArray(this.layouts)) {
            data["layouts"] = [];
            for (let item of this.layouts)
                data["layouts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICopyAllExportLayoutDto {
    databaseFromId: number | undefined;
    groupFromId: number | undefined;
    databaseToId: number | undefined;
    groupToId: number | undefined;
    layouts: GetCopyAllExportLayoutForViewDto[] | undefined;
}

export class ImportLayoutDto implements IImportLayoutDto {
    layoutId!: number | undefined;
    path!: string | undefined;

    constructor(data?: IImportLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutId = data["layoutId"];
            this.path = data["path"];
        }
    }

    static fromJS(data: any): ImportLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutId"] = this.layoutId;
        data["path"] = this.path;
        return data; 
    }
}

export interface IImportLayoutDto {
    layoutId: number | undefined;
    path: string | undefined;
}

export class PagedResultDtoOfExternalBuildTableDatabaseForAllDto implements IPagedResultDtoOfExternalBuildTableDatabaseForAllDto {
    totalCount!: number | undefined;
    items!: ExternalBuildTableDatabaseForAllDto[] | undefined;

    constructor(data?: IPagedResultDtoOfExternalBuildTableDatabaseForAllDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ExternalBuildTableDatabaseForAllDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExternalBuildTableDatabaseForAllDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfExternalBuildTableDatabaseForAllDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfExternalBuildTableDatabaseForAllDto {
    totalCount: number | undefined;
    items: ExternalBuildTableDatabaseForAllDto[] | undefined;
}

export class ExternalBuildTableDatabaseForAllDto implements IExternalBuildTableDatabaseForAllDto {
    id!: number | undefined;
    divisionID!: number | undefined;
    databaseID!: number | undefined;
    buildTableID!: number | undefined;
    divisionName!: string | undefined;
    databaseName!: string | undefined;
    buildTableDescription!: string | undefined;
    buildTableName!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IExternalBuildTableDatabaseForAllDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.divisionID = data["divisionID"];
            this.databaseID = data["databaseID"];
            this.buildTableID = data["buildTableID"];
            this.divisionName = data["divisionName"];
            this.databaseName = data["databaseName"];
            this.buildTableDescription = data["buildTableDescription"];
            this.buildTableName = data["buildTableName"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): ExternalBuildTableDatabaseForAllDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalBuildTableDatabaseForAllDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["divisionID"] = this.divisionID;
        data["databaseID"] = this.databaseID;
        data["buildTableID"] = this.buildTableID;
        data["divisionName"] = this.divisionName;
        data["databaseName"] = this.databaseName;
        data["buildTableDescription"] = this.buildTableDescription;
        data["buildTableName"] = this.buildTableName;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IExternalBuildTableDatabaseForAllDto {
    id: number | undefined;
    divisionID: number | undefined;
    databaseID: number | undefined;
    buildTableID: number | undefined;
    divisionName: string | undefined;
    databaseName: string | undefined;
    buildTableDescription: string | undefined;
    buildTableName: string | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class ExternalBuildTableDatabase implements IExternalBuildTableDatabase {
    databaseID!: number | undefined;
    buildTableID!: number | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    id!: number | undefined;

    constructor(data?: IExternalBuildTableDatabase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseID = data["databaseID"];
            this.buildTableID = data["buildTableID"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ExternalBuildTableDatabase {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalBuildTableDatabase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseID"] = this.databaseID;
        data["buildTableID"] = this.buildTableID;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IExternalBuildTableDatabase {
    databaseID: number | undefined;
    buildTableID: number | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    id: number | undefined;
}

export class GetAllForLookupTableInput implements IGetAllForLookupTableInput {
    filter!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IGetAllForLookupTableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAllForLookupTableInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllForLookupTableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IGetAllForLookupTableInput {
    filter: string | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class CreateOrEditExternalBuildTableDatabaseDto implements ICreateOrEditExternalBuildTableDatabaseDto {
    databaseId!: number | undefined;
    buildTableId!: number | undefined;
    cCreatedBy!: string | undefined;
    cModifiedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    dModifiedDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditExternalBuildTableDatabaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseId = data["databaseId"];
            this.buildTableId = data["buildTableId"];
            this.cCreatedBy = data["cCreatedBy"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditExternalBuildTableDatabaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditExternalBuildTableDatabaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseId"] = this.databaseId;
        data["buildTableId"] = this.buildTableId;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditExternalBuildTableDatabaseDto {
    databaseId: number | undefined;
    buildTableId: number | undefined;
    cCreatedBy: string | undefined;
    cModifiedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    dModifiedDate: moment.Moment | undefined;
    id: number | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class PagedResultDtoOfGroupBrokerDto implements IPagedResultDtoOfGroupBrokerDto {
    totalCount!: number | undefined;
    items!: GroupBrokerDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGroupBrokerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GroupBrokerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGroupBrokerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGroupBrokerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGroupBrokerDto {
    totalCount: number | undefined;
    items: GroupBrokerDto[] | undefined;
}

export class GroupBrokerDto implements IGroupBrokerDto {
    cCode!: string | undefined;
    cCompany!: string | undefined;
    isSelected!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IGroupBrokerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cCode = data["cCode"];
            this.cCompany = data["cCompany"];
            this.isSelected = data["isSelected"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GroupBrokerDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupBrokerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cCode"] = this.cCode;
        data["cCompany"] = this.cCompany;
        data["isSelected"] = this.isSelected;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGroupBrokerDto {
    cCode: string | undefined;
    cCompany: string | undefined;
    isSelected: boolean | undefined;
    id: number | undefined;
}

export class AddBrokerForGroupDto implements IAddBrokerForGroupDto {
    groupID!: number | undefined;
    selectedBroker!: GetGroupBrokerOutputDto[] | undefined;

    constructor(data?: IAddBrokerForGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupID = data["groupID"];
            if (Array.isArray(data["selectedBroker"])) {
                this.selectedBroker = [] as any;
                for (let item of data["selectedBroker"])
                    this.selectedBroker!.push(GetGroupBrokerOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddBrokerForGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddBrokerForGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupID"] = this.groupID;
        if (Array.isArray(this.selectedBroker)) {
            data["selectedBroker"] = [];
            for (let item of this.selectedBroker)
                data["selectedBroker"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddBrokerForGroupDto {
    groupID: number | undefined;
    selectedBroker: GetGroupBrokerOutputDto[] | undefined;
}

export class GetGroupBrokerOutputDto implements IGetGroupBrokerOutputDto {
    id!: number | undefined;
    cCode!: string | undefined;
    cCompany!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: IGetGroupBrokerOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cCode = data["cCode"];
            this.cCompany = data["cCompany"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): GetGroupBrokerOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGroupBrokerOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cCode"] = this.cCode;
        data["cCompany"] = this.cCompany;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IGetGroupBrokerOutputDto {
    id: number | undefined;
    cCode: string | undefined;
    cCompany: string | undefined;
    isSelected: boolean | undefined;
}

export enum ChartDateInterval {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount!: number | undefined;
    newSubscriptionAmount!: number | undefined;
    dashboardPlaceholder1!: number | undefined;
    dashboardPlaceholder2!: number | undefined;
    incomeStatistics!: IncomeStastistic[] | undefined;
    editionStatistics!: TenantEdition[] | undefined;
    expiringTenants!: ExpiringTenant[] | undefined;
    recentTenants!: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount!: number | undefined;
    maxRecentTenantsShownCount!: number | undefined;
    subscriptionEndAlertDayCount!: number | undefined;
    recentTenantsDayCount!: number | undefined;
    subscriptionEndDateStart!: moment.Moment | undefined;
    subscriptionEndDateEnd!: moment.Moment | undefined;
    tenantCreationStartDate!: moment.Moment | undefined;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (Array.isArray(data["incomeStatistics"])) {
                this.incomeStatistics = [] as any;
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
            if (Array.isArray(data["editionStatistics"])) {
                this.editionStatistics = [] as any;
                for (let item of data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
            if (Array.isArray(data["expiringTenants"])) {
                this.expiringTenants = [] as any;
                for (let item of data["expiringTenants"])
                    this.expiringTenants!.push(ExpiringTenant.fromJS(item));
            }
            if (Array.isArray(data["recentTenants"])) {
                this.recentTenants = [] as any;
                for (let item of data["recentTenants"])
                    this.recentTenants!.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? moment(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? moment(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? moment(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (Array.isArray(this.incomeStatistics)) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (Array.isArray(this.editionStatistics)) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (Array.isArray(this.expiringTenants)) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (Array.isArray(this.recentTenants)) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: moment.Moment | undefined;
    subscriptionEndDateEnd: moment.Moment | undefined;
    tenantCreationStartDate: moment.Moment | undefined;
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number | undefined;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number | undefined;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;
}

export class RecentTenant implements IRecentTenant {
    id!: number | undefined;
    name!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["incomeStatistics"])) {
                this.incomeStatistics = [] as any;
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.incomeStatistics)) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["editionStatistics"])) {
                this.editionStatistics = [] as any;
                for (let item of data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.editionStatistics)) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto | undefined;
    otherSettings!: OtherSettingsEditDto | undefined;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? OtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto | undefined;
    otherSettings: OtherSettingsEditDto | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    smsVerificationEnabled!: boolean | undefined;
    isCookieConsentEnabled!: boolean | undefined;
    isQuickThemeSelectEnabled!: boolean | undefined;
    useCaptchaOnLogin!: boolean | undefined;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
            this.useCaptchaOnLogin = data["useCaptchaOnLogin"];
            this.sessionTimeOutSettings = data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
    useCaptchaOnLogin: boolean | undefined;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean | undefined;
    smtpUseDefaultCredentials!: boolean | undefined;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredTenantActiveByDefault!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser!: boolean | undefined;
    useDefaultPasswordComplexitySettings!: boolean | undefined;
    passwordComplexity!: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity!: PasswordComplexitySetting | undefined;
    userLockOut!: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto | undefined;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowOneConcurrentLoginPerUser = data["allowOneConcurrentLoginPerUser"];
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowOneConcurrentLoginPerUser"] = this.allowOneConcurrentLoginPerUser;
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser: boolean | undefined;
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class SessionTimeOutSettingsEditDto implements ISessionTimeOutSettingsEditDto {
    isEnabled!: boolean | undefined;
    timeOutSecond!: number | undefined;
    showTimeOutNotificationSecond!: number | undefined;

    constructor(data?: ISessionTimeOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.timeOutSecond = data["timeOutSecond"];
            this.showTimeOutNotificationSecond = data["showTimeOutNotificationSecond"];
        }
    }

    static fromJS(data: any): SessionTimeOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionTimeOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["timeOutSecond"] = this.timeOutSecond;
        data["showTimeOutNotificationSecond"] = this.showTimeOutNotificationSecond;
        return data; 
    }
}

export interface ISessionTimeOutSettingsEditDto {
    isEnabled: boolean | undefined;
    timeOutSecond: number | undefined;
    showTimeOutNotificationSecond: number | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean | undefined;
    requireLowercase!: boolean | undefined;
    requireNonAlphanumeric!: boolean | undefined;
    requireUppercase!: boolean | undefined;
    requiredLength!: number | undefined;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout!: number | undefined;
    defaultAccountLockoutSeconds!: number | undefined;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean | undefined;
    isEnabled!: boolean | undefined;
    isEmailProviderEnabled!: boolean | undefined;
    isSmsProviderEnabled!: boolean | undefined;
    isRememberBrowserEnabled!: boolean | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class PagedResultDtoOfGetAllConfigurationsForViewDto implements IPagedResultDtoOfGetAllConfigurationsForViewDto {
    totalCount!: number | undefined;
    items!: GetAllConfigurationsForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllConfigurationsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAllConfigurationsForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllConfigurationsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllConfigurationsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAllConfigurationsForViewDto {
    totalCount: number | undefined;
    items: GetAllConfigurationsForViewDto[] | undefined;
}

export class GetAllConfigurationsForViewDto implements IGetAllConfigurationsForViewDto {
    id!: number | undefined;
    divisionID!: number | undefined;
    databaseID!: number | undefined;
    cItem!: string | undefined;
    cDescription!: string | undefined;
    cValue!: string | undefined;
    iIsActive!: boolean | undefined;
    cDatabaseName!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IGetAllConfigurationsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.divisionID = data["divisionID"];
            this.databaseID = data["databaseID"];
            this.cItem = data["cItem"];
            this.cDescription = data["cDescription"];
            this.cValue = data["cValue"];
            this.iIsActive = data["iIsActive"];
            this.cDatabaseName = data["cDatabaseName"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAllConfigurationsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllConfigurationsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["divisionID"] = this.divisionID;
        data["databaseID"] = this.databaseID;
        data["cItem"] = this.cItem;
        data["cDescription"] = this.cDescription;
        data["cValue"] = this.cValue;
        data["iIsActive"] = this.iIsActive;
        data["cDatabaseName"] = this.cDatabaseName;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IGetAllConfigurationsForViewDto {
    id: number | undefined;
    divisionID: number | undefined;
    databaseID: number | undefined;
    cItem: string | undefined;
    cDescription: string | undefined;
    cValue: string | undefined;
    iIsActive: boolean | undefined;
    cDatabaseName: string | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class CreateOrEditConfigurationDto implements ICreateOrEditConfigurationDto {
    divisionID!: number | undefined;
    databaseID!: number | undefined;
    cItem!: string | undefined;
    cDescription!: string | undefined;
    cValue!: string | undefined;
    iValue!: number | undefined;
    dValue!: moment.Moment | undefined;
    mValue!: string | undefined;
    iIsActive!: boolean | undefined;
    cCreatedBy!: string | undefined;
    cModifiedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    dModifiedDate!: moment.Moment | undefined;
    iIsEncrypted!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.divisionID = data["divisionID"];
            this.databaseID = data["databaseID"];
            this.cItem = data["cItem"];
            this.cDescription = data["cDescription"];
            this.cValue = data["cValue"];
            this.iValue = data["iValue"];
            this.dValue = data["dValue"] ? moment(data["dValue"].toString()) : <any>undefined;
            this.mValue = data["mValue"];
            this.iIsActive = data["iIsActive"];
            this.cCreatedBy = data["cCreatedBy"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.iIsEncrypted = data["iIsEncrypted"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["divisionID"] = this.divisionID;
        data["databaseID"] = this.databaseID;
        data["cItem"] = this.cItem;
        data["cDescription"] = this.cDescription;
        data["cValue"] = this.cValue;
        data["iValue"] = this.iValue;
        data["dValue"] = this.dValue ? this.dValue.toISOString() : <any>undefined;
        data["mValue"] = this.mValue;
        data["iIsActive"] = this.iIsActive;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["iIsEncrypted"] = this.iIsEncrypted;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditConfigurationDto {
    divisionID: number | undefined;
    databaseID: number | undefined;
    cItem: string | undefined;
    cDescription: string | undefined;
    cValue: string | undefined;
    iValue: number | undefined;
    dValue: moment.Moment | undefined;
    mValue: string | undefined;
    iIsActive: boolean | undefined;
    cCreatedBy: string | undefined;
    cModifiedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    dModifiedDate: moment.Moment | undefined;
    iIsEncrypted: boolean | undefined;
    id: number | undefined;
}

export class IDMSConfigurationDto implements IIDMSConfigurationDto {
    cValue!: string | undefined;
    iValue!: number | undefined;
    mValue!: string | undefined;
    iIsEncrypted!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IIDMSConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cValue = data["cValue"];
            this.iValue = data["iValue"];
            this.mValue = data["mValue"];
            this.iIsEncrypted = data["iIsEncrypted"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): IDMSConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new IDMSConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cValue"] = this.cValue;
        data["iValue"] = this.iValue;
        data["mValue"] = this.mValue;
        data["iIsEncrypted"] = this.iIsEncrypted;
        data["id"] = this.id;
        return data; 
    }
}

export interface IIDMSConfigurationDto {
    cValue: string | undefined;
    iValue: number | undefined;
    mValue: string | undefined;
    iIsEncrypted: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetIDMSTaskForViewDto implements IPagedResultDtoOfGetIDMSTaskForViewDto {
    totalCount!: number | undefined;
    items!: GetIDMSTaskForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetIDMSTaskForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetIDMSTaskForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetIDMSTaskForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetIDMSTaskForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetIDMSTaskForViewDto {
    totalCount: number | undefined;
    items: GetIDMSTaskForViewDto[] | undefined;
}

export class GetIDMSTaskForViewDto implements IGetIDMSTaskForViewDto {
    id!: number | undefined;
    cTaskDescription!: string | undefined;
    cTaskName!: string | undefined;
    cPermissionName!: string | undefined;

    constructor(data?: IGetIDMSTaskForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cTaskDescription = data["cTaskDescription"];
            this.cTaskName = data["cTaskName"];
            this.cPermissionName = data["cPermissionName"];
        }
    }

    static fromJS(data: any): GetIDMSTaskForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetIDMSTaskForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cTaskDescription"] = this.cTaskDescription;
        data["cTaskName"] = this.cTaskName;
        data["cPermissionName"] = this.cPermissionName;
        return data; 
    }
}

export interface IGetIDMSTaskForViewDto {
    id: number | undefined;
    cTaskDescription: string | undefined;
    cTaskName: string | undefined;
    cPermissionName: string | undefined;
}

export class SetValidEmailFlagDto implements ISetValidEmailFlagDto {
    taskGeneralFrom!: TaskGeneralDto | undefined;
    taskGeneralTo!: TaskGeneralDto | undefined;
    scheduledDate!: string | undefined;
    scheduledTime!: string | undefined;

    constructor(data?: ISetValidEmailFlagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taskGeneralFrom = data["taskGeneralFrom"] ? TaskGeneralDto.fromJS(data["taskGeneralFrom"]) : <any>undefined;
            this.taskGeneralTo = data["taskGeneralTo"] ? TaskGeneralDto.fromJS(data["taskGeneralTo"]) : <any>undefined;
            this.scheduledDate = data["scheduledDate"];
            this.scheduledTime = data["scheduledTime"];
        }
    }

    static fromJS(data: any): SetValidEmailFlagDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetValidEmailFlagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskGeneralFrom"] = this.taskGeneralFrom ? this.taskGeneralFrom.toJSON() : <any>undefined;
        data["taskGeneralTo"] = this.taskGeneralTo ? this.taskGeneralTo.toJSON() : <any>undefined;
        data["scheduledDate"] = this.scheduledDate;
        data["scheduledTime"] = this.scheduledTime;
        return data; 
    }
}

export interface ISetValidEmailFlagDto {
    taskGeneralFrom: TaskGeneralDto | undefined;
    taskGeneralTo: TaskGeneralDto | undefined;
    scheduledDate: string | undefined;
    scheduledTime: string | undefined;
}

export class TaskGeneralDto implements ITaskGeneralDto {
    databaseID!: number | undefined;
    buildID!: number | undefined;

    constructor(data?: ITaskGeneralDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseID = data["databaseID"];
            this.buildID = data["buildID"];
        }
    }

    static fromJS(data: any): TaskGeneralDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskGeneralDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseID"] = this.databaseID;
        data["buildID"] = this.buildID;
        return data; 
    }
}

export interface ITaskGeneralDto {
    databaseID: number | undefined;
    buildID: number | undefined;
}

export class AOPFromPreviousBuildDto implements IAOPFromPreviousBuildDto {
    taskGeneral!: TaskGeneralDto | undefined;
    newBuildID!: number | undefined;
    listId!: string | undefined;
    userAgree!: boolean | undefined;
    isRegister!: boolean | undefined;

    constructor(data?: IAOPFromPreviousBuildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taskGeneral = data["taskGeneral"] ? TaskGeneralDto.fromJS(data["taskGeneral"]) : <any>undefined;
            this.newBuildID = data["newBuildID"];
            this.listId = data["listId"];
            this.userAgree = data["userAgree"];
            this.isRegister = data["isRegister"];
        }
    }

    static fromJS(data: any): AOPFromPreviousBuildDto {
        data = typeof data === 'object' ? data : {};
        let result = new AOPFromPreviousBuildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskGeneral"] = this.taskGeneral ? this.taskGeneral.toJSON() : <any>undefined;
        data["newBuildID"] = this.newBuildID;
        data["listId"] = this.listId;
        data["userAgree"] = this.userAgree;
        data["isRegister"] = this.isRegister;
        return data; 
    }
}

export interface IAOPFromPreviousBuildDto {
    taskGeneral: TaskGeneralDto | undefined;
    newBuildID: number | undefined;
    listId: string | undefined;
    userAgree: boolean | undefined;
    isRegister: boolean | undefined;
}

export class LoadMailerUsageDto implements ILoadMailerUsageDto {
    taskGeneral!: TaskGeneralDto | undefined;
    newBuildID!: number | undefined;
    filePath!: string | undefined;

    constructor(data?: ILoadMailerUsageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taskGeneral = data["taskGeneral"] ? TaskGeneralDto.fromJS(data["taskGeneral"]) : <any>undefined;
            this.newBuildID = data["newBuildID"];
            this.filePath = data["filePath"];
        }
    }

    static fromJS(data: any): LoadMailerUsageDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoadMailerUsageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskGeneral"] = this.taskGeneral ? this.taskGeneral.toJSON() : <any>undefined;
        data["newBuildID"] = this.newBuildID;
        data["filePath"] = this.filePath;
        return data; 
    }
}

export interface ILoadMailerUsageDto {
    taskGeneral: TaskGeneralDto | undefined;
    newBuildID: number | undefined;
    filePath: string | undefined;
}

export class EnhancedAuditReportDto implements IEnhancedAuditReportDto {
    taskGeneral!: TaskGeneralDto | undefined;
    countId!: string | undefined;
    isListWiseReport!: boolean | undefined;
    scheduledDate!: string | undefined;
    scheduledTime!: string | undefined;

    constructor(data?: IEnhancedAuditReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taskGeneral = data["taskGeneral"] ? TaskGeneralDto.fromJS(data["taskGeneral"]) : <any>undefined;
            this.countId = data["countId"];
            this.isListWiseReport = data["isListWiseReport"];
            this.scheduledDate = data["scheduledDate"];
            this.scheduledTime = data["scheduledTime"];
        }
    }

    static fromJS(data: any): EnhancedAuditReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnhancedAuditReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskGeneral"] = this.taskGeneral ? this.taskGeneral.toJSON() : <any>undefined;
        data["countId"] = this.countId;
        data["isListWiseReport"] = this.isListWiseReport;
        data["scheduledDate"] = this.scheduledDate;
        data["scheduledTime"] = this.scheduledTime;
        return data; 
    }
}

export interface IEnhancedAuditReportDto {
    taskGeneral: TaskGeneralDto | undefined;
    countId: string | undefined;
    isListWiseReport: boolean | undefined;
    scheduledDate: string | undefined;
    scheduledTime: string | undefined;
}

export class ExportListConversionDataDto implements IExportListConversionDataDto {
    taskGeneral!: TaskGeneralDto | undefined;
    listId!: string | undefined;
    tableType!: number | undefined;
    fields!: string | undefined;
    outputType!: string | undefined;
    outputQuantity!: number | undefined;
    selection!: string | undefined;

    constructor(data?: IExportListConversionDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taskGeneral = data["taskGeneral"] ? TaskGeneralDto.fromJS(data["taskGeneral"]) : <any>undefined;
            this.listId = data["listId"];
            this.tableType = data["tableType"];
            this.fields = data["fields"];
            this.outputType = data["outputType"];
            this.outputQuantity = data["outputQuantity"];
            this.selection = data["selection"];
        }
    }

    static fromJS(data: any): ExportListConversionDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportListConversionDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskGeneral"] = this.taskGeneral ? this.taskGeneral.toJSON() : <any>undefined;
        data["listId"] = this.listId;
        data["tableType"] = this.tableType;
        data["fields"] = this.fields;
        data["outputType"] = this.outputType;
        data["outputQuantity"] = this.outputQuantity;
        data["selection"] = this.selection;
        return data; 
    }
}

export interface IExportListConversionDataDto {
    taskGeneral: TaskGeneralDto | undefined;
    listId: string | undefined;
    tableType: number | undefined;
    fields: string | undefined;
    outputType: string | undefined;
    outputQuantity: number | undefined;
    selection: string | undefined;
}

export class ApogeeCustomExportTaskDto implements IApogeeCustomExportTaskDto {
    taskGeneral!: TaskGeneralDto | undefined;
    countId!: string | undefined;
    scheduledDate!: string | undefined;
    scheduledTime!: string | undefined;

    constructor(data?: IApogeeCustomExportTaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taskGeneral = data["taskGeneral"] ? TaskGeneralDto.fromJS(data["taskGeneral"]) : <any>undefined;
            this.countId = data["countId"];
            this.scheduledDate = data["scheduledDate"];
            this.scheduledTime = data["scheduledTime"];
        }
    }

    static fromJS(data: any): ApogeeCustomExportTaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApogeeCustomExportTaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskGeneral"] = this.taskGeneral ? this.taskGeneral.toJSON() : <any>undefined;
        data["countId"] = this.countId;
        data["scheduledDate"] = this.scheduledDate;
        data["scheduledTime"] = this.scheduledTime;
        return data; 
    }
}

export interface IApogeeCustomExportTaskDto {
    taskGeneral: TaskGeneralDto | undefined;
    countId: string | undefined;
    scheduledDate: string | undefined;
    scheduledTime: string | undefined;
}

export class ApogeeExportPointInTimeTaskDto implements IApogeeExportPointInTimeTaskDto {
    taskGeneral!: TaskGeneralDto | undefined;
    buildID!: number | undefined;
    fileLocation!: string | undefined;
    inputFileName!: string | undefined;

    constructor(data?: IApogeeExportPointInTimeTaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taskGeneral = data["taskGeneral"] ? TaskGeneralDto.fromJS(data["taskGeneral"]) : <any>undefined;
            this.buildID = data["buildID"];
            this.fileLocation = data["fileLocation"];
            this.inputFileName = data["inputFileName"];
        }
    }

    static fromJS(data: any): ApogeeExportPointInTimeTaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApogeeExportPointInTimeTaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskGeneral"] = this.taskGeneral ? this.taskGeneral.toJSON() : <any>undefined;
        data["buildID"] = this.buildID;
        data["fileLocation"] = this.fileLocation;
        data["inputFileName"] = this.inputFileName;
        return data; 
    }
}

export interface IApogeeExportPointInTimeTaskDto {
    taskGeneral: TaskGeneralDto | undefined;
    buildID: number | undefined;
    fileLocation: string | undefined;
    inputFileName: string | undefined;
}

export class SearchPreviousOrderHistorybyKeyTaskDto implements ISearchPreviousOrderHistorybyKeyTaskDto {
    taskGeneral!: TaskGeneralDto | undefined;
    searchKey!: string | undefined;
    campaignId!: number | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;

    constructor(data?: ISearchPreviousOrderHistorybyKeyTaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taskGeneral = data["taskGeneral"] ? TaskGeneralDto.fromJS(data["taskGeneral"]) : <any>undefined;
            this.searchKey = data["searchKey"];
            this.campaignId = data["campaignId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchPreviousOrderHistorybyKeyTaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchPreviousOrderHistorybyKeyTaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskGeneral"] = this.taskGeneral ? this.taskGeneral.toJSON() : <any>undefined;
        data["searchKey"] = this.searchKey;
        data["campaignId"] = this.campaignId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISearchPreviousOrderHistorybyKeyTaskDto {
    taskGeneral: TaskGeneralDto | undefined;
    searchKey: string | undefined;
    campaignId: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
}

export class CopyBuildDto implements ICopyBuildDto {
    sourceBuild!: number | undefined;
    targetBuild!: number | undefined;

    constructor(data?: ICopyBuildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceBuild = data["sourceBuild"];
            this.targetBuild = data["targetBuild"];
        }
    }

    static fromJS(data: any): CopyBuildDto {
        data = typeof data === 'object' ? data : {};
        let result = new CopyBuildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceBuild"] = this.sourceBuild;
        data["targetBuild"] = this.targetBuild;
        return data; 
    }
}

export interface ICopyBuildDto {
    sourceBuild: number | undefined;
    targetBuild: number | undefined;
}

export class OptoutHardbounceTaskDto implements IOptoutHardbounceTaskDto {
    taskGeneral!: TaskGeneralDto | undefined;
    fileType!: string | undefined;
    fileLocation!: string | undefined;
    inputFileName!: string | undefined;

    constructor(data?: IOptoutHardbounceTaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taskGeneral = data["taskGeneral"] ? TaskGeneralDto.fromJS(data["taskGeneral"]) : <any>undefined;
            this.fileType = data["fileType"];
            this.fileLocation = data["fileLocation"];
            this.inputFileName = data["inputFileName"];
        }
    }

    static fromJS(data: any): OptoutHardbounceTaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptoutHardbounceTaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskGeneral"] = this.taskGeneral ? this.taskGeneral.toJSON() : <any>undefined;
        data["fileType"] = this.fileType;
        data["fileLocation"] = this.fileLocation;
        data["inputFileName"] = this.inputFileName;
        return data; 
    }
}

export interface IOptoutHardbounceTaskDto {
    taskGeneral: TaskGeneralDto | undefined;
    fileType: string | undefined;
    fileLocation: string | undefined;
    inputFileName: string | undefined;
}

export class ExportEmailHygieneDataDto implements IExportEmailHygieneDataDto {
    taskGeneral!: TaskGeneralDto | undefined;
    exportField!: string | undefined;
    exportFlagField!: string | undefined;
    flagValue!: string | undefined;

    constructor(data?: IExportEmailHygieneDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taskGeneral = data["taskGeneral"] ? TaskGeneralDto.fromJS(data["taskGeneral"]) : <any>undefined;
            this.exportField = data["exportField"];
            this.exportFlagField = data["exportFlagField"];
            this.flagValue = data["flagValue"];
        }
    }

    static fromJS(data: any): ExportEmailHygieneDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportEmailHygieneDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskGeneral"] = this.taskGeneral ? this.taskGeneral.toJSON() : <any>undefined;
        data["exportField"] = this.exportField;
        data["exportFlagField"] = this.exportFlagField;
        data["flagValue"] = this.flagValue;
        return data; 
    }
}

export interface IExportEmailHygieneDataDto {
    taskGeneral: TaskGeneralDto | undefined;
    exportField: string | undefined;
    exportFlagField: string | undefined;
    flagValue: string | undefined;
}

export class ImportEmailHygieneDataDto implements IImportEmailHygieneDataDto {
    taskGeneral!: TaskGeneralDto | undefined;
    matchField!: string | undefined;
    flagField!: string | undefined;
    filePath!: string | undefined;
    fileName!: string | undefined;

    constructor(data?: IImportEmailHygieneDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taskGeneral = data["taskGeneral"] ? TaskGeneralDto.fromJS(data["taskGeneral"]) : <any>undefined;
            this.matchField = data["matchField"];
            this.flagField = data["flagField"];
            this.filePath = data["filePath"];
            this.fileName = data["fileName"];
        }
    }

    static fromJS(data: any): ImportEmailHygieneDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportEmailHygieneDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskGeneral"] = this.taskGeneral ? this.taskGeneral.toJSON() : <any>undefined;
        data["matchField"] = this.matchField;
        data["flagField"] = this.flagField;
        data["filePath"] = this.filePath;
        data["fileName"] = this.fileName;
        return data; 
    }
}

export interface IImportEmailHygieneDataDto {
    taskGeneral: TaskGeneralDto | undefined;
    matchField: string | undefined;
    flagField: string | undefined;
    filePath: string | undefined;
    fileName: string | undefined;
}

export class ActivateLinkTableBuildDto implements IActivateLinkTableBuildDto {
    tableName!: string | undefined;
    scheduledDate!: string | undefined;
    scheduledTime!: string | undefined;

    constructor(data?: IActivateLinkTableBuildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tableName = data["tableName"];
            this.scheduledDate = data["scheduledDate"];
            this.scheduledTime = data["scheduledTime"];
        }
    }

    static fromJS(data: any): ActivateLinkTableBuildDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateLinkTableBuildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tableName"] = this.tableName;
        data["scheduledDate"] = this.scheduledDate;
        data["scheduledTime"] = this.scheduledTime;
        return data; 
    }
}

export interface IActivateLinkTableBuildDto {
    tableName: string | undefined;
    scheduledDate: string | undefined;
    scheduledTime: string | undefined;
}

export class GetAllTableDescriptionFromBuild implements IGetAllTableDescriptionFromBuild {
    exportFlagFieldDropdown!: DropdownOutputDto[] | undefined;
    defaultSelection!: string | undefined;

    constructor(data?: IGetAllTableDescriptionFromBuild) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["exportFlagFieldDropdown"])) {
                this.exportFlagFieldDropdown = [] as any;
                for (let item of data["exportFlagFieldDropdown"])
                    this.exportFlagFieldDropdown!.push(DropdownOutputDto.fromJS(item));
            }
            this.defaultSelection = data["defaultSelection"];
        }
    }

    static fromJS(data: any): GetAllTableDescriptionFromBuild {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllTableDescriptionFromBuild();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exportFlagFieldDropdown)) {
            data["exportFlagFieldDropdown"] = [];
            for (let item of this.exportFlagFieldDropdown)
                data["exportFlagFieldDropdown"].push(item.toJSON());
        }
        data["defaultSelection"] = this.defaultSelection;
        return data; 
    }
}

export interface IGetAllTableDescriptionFromBuild {
    exportFlagFieldDropdown: DropdownOutputDto[] | undefined;
    defaultSelection: string | undefined;
}

export class BulkUpdateListActionDto implements IBulkUpdateListActionDto {
    taskGeneral!: TaskGeneralDto | undefined;
    fileName!: string | undefined;

    constructor(data?: IBulkUpdateListActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taskGeneral = data["taskGeneral"] ? TaskGeneralDto.fromJS(data["taskGeneral"]) : <any>undefined;
            this.fileName = data["fileName"];
        }
    }

    static fromJS(data: any): BulkUpdateListActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkUpdateListActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskGeneral"] = this.taskGeneral ? this.taskGeneral.toJSON() : <any>undefined;
        data["fileName"] = this.fileName;
        return data; 
    }
}

export interface IBulkUpdateListActionDto {
    taskGeneral: TaskGeneralDto | undefined;
    fileName: string | undefined;
}

export class GetAllExportFlagFieldForBuildDto implements IGetAllExportFlagFieldForBuildDto {
    exportFlagFieldDropdown!: DropdownOutputDto[] | undefined;
    defaultSelection!: string | undefined;

    constructor(data?: IGetAllExportFlagFieldForBuildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["exportFlagFieldDropdown"])) {
                this.exportFlagFieldDropdown = [] as any;
                for (let item of data["exportFlagFieldDropdown"])
                    this.exportFlagFieldDropdown!.push(DropdownOutputDto.fromJS(item));
            }
            this.defaultSelection = data["defaultSelection"];
        }
    }

    static fromJS(data: any): GetAllExportFlagFieldForBuildDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllExportFlagFieldForBuildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exportFlagFieldDropdown)) {
            data["exportFlagFieldDropdown"] = [];
            for (let item of this.exportFlagFieldDropdown)
                data["exportFlagFieldDropdown"].push(item.toJSON());
        }
        data["defaultSelection"] = this.defaultSelection;
        return data; 
    }
}

export interface IGetAllExportFlagFieldForBuildDto {
    exportFlagFieldDropdown: DropdownOutputDto[] | undefined;
    defaultSelection: string | undefined;
}

export class GetServerDateTime implements IGetServerDateTime {
    date!: string | undefined;
    time!: string | undefined;

    constructor(data?: IGetServerDateTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.time = data["time"];
        }
    }

    static fromJS(data: any): GetServerDateTime {
        data = typeof data === 'object' ? data : {};
        let result = new GetServerDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["time"] = this.time;
        return data; 
    }
}

export interface IGetServerDateTime {
    date: string | undefined;
    time: string | undefined;
}

export class ModelPivotReportDto implements IModelPivotReportDto {
    databaseID!: number | undefined;
    buildID!: number | undefined;
    model1!: string | undefined;
    model2!: string | undefined;

    constructor(data?: IModelPivotReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseID = data["databaseID"];
            this.buildID = data["buildID"];
            this.model1 = data["model1"];
            this.model2 = data["model2"];
        }
    }

    static fromJS(data: any): ModelPivotReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelPivotReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseID"] = this.databaseID;
        data["buildID"] = this.buildID;
        data["model1"] = this.model1;
        data["model2"] = this.model2;
        return data; 
    }
}

export interface IModelPivotReportDto {
    databaseID: number | undefined;
    buildID: number | undefined;
    model1: string | undefined;
    model2: string | undefined;
}

export class PagedResultDtoOfIDMSUserDto implements IPagedResultDtoOfIDMSUserDto {
    totalCount!: number | undefined;
    items!: IDMSUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIDMSUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(IDMSUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIDMSUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIDMSUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIDMSUserDto {
    totalCount: number | undefined;
    items: IDMSUserDto[] | undefined;
}

export class IDMSUserDto implements IIDMSUserDto {
    cFirstName!: string | undefined;
    cLastName!: string | undefined;
    cUserID!: string | undefined;
    cEmail!: string | undefined;
    cPhone!: string | undefined;
    cFax!: string | undefined;
    iIsActive!: boolean | undefined;
    iIsNotify!: boolean | undefined;
    iLogonAttempts!: number | undefined;
    lastLogonDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    lK_AccountingDivisionCode!: string | undefined;
    divisionBrokerID!: number | undefined;
    divisionMailerID!: number | undefined;
    mailerID!: number | undefined;
    id!: number | undefined;

    constructor(data?: IIDMSUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cFirstName = data["cFirstName"];
            this.cLastName = data["cLastName"];
            this.cUserID = data["cUserID"];
            this.cEmail = data["cEmail"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            this.iIsActive = data["iIsActive"];
            this.iIsNotify = data["iIsNotify"];
            this.iLogonAttempts = data["iLogonAttempts"];
            this.lastLogonDate = data["lastLogonDate"] ? moment(data["lastLogonDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.lK_AccountingDivisionCode = data["lK_AccountingDivisionCode"];
            this.divisionBrokerID = data["divisionBrokerID"];
            this.divisionMailerID = data["divisionMailerID"];
            this.mailerID = data["mailerID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): IDMSUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new IDMSUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cFirstName"] = this.cFirstName;
        data["cLastName"] = this.cLastName;
        data["cUserID"] = this.cUserID;
        data["cEmail"] = this.cEmail;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        data["iIsActive"] = this.iIsActive;
        data["iIsNotify"] = this.iIsNotify;
        data["iLogonAttempts"] = this.iLogonAttempts;
        data["lastLogonDate"] = this.lastLogonDate ? this.lastLogonDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["lK_AccountingDivisionCode"] = this.lK_AccountingDivisionCode;
        data["divisionBrokerID"] = this.divisionBrokerID;
        data["divisionMailerID"] = this.divisionMailerID;
        data["mailerID"] = this.mailerID;
        data["id"] = this.id;
        return data; 
    }
}

export interface IIDMSUserDto {
    cFirstName: string | undefined;
    cLastName: string | undefined;
    cUserID: string | undefined;
    cEmail: string | undefined;
    cPhone: string | undefined;
    cFax: string | undefined;
    iIsActive: boolean | undefined;
    iIsNotify: boolean | undefined;
    iLogonAttempts: number | undefined;
    lastLogonDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    lK_AccountingDivisionCode: string | undefined;
    divisionBrokerID: number | undefined;
    divisionMailerID: number | undefined;
    mailerID: number | undefined;
    id: number | undefined;
}

export class GetIDMSUserForViewDto implements IGetIDMSUserForViewDto {
    tblUser!: IDMSUserDto | undefined;

    constructor(data?: IGetIDMSUserForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tblUser = data["tblUser"] ? IDMSUserDto.fromJS(data["tblUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetIDMSUserForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetIDMSUserForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tblUser"] = this.tblUser ? this.tblUser.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetIDMSUserForViewDto {
    tblUser: IDMSUserDto | undefined;
}

export class GetIDMSUserForEditOutput implements IGetIDMSUserForEditOutput {
    tblUser!: CreateOrEditIDMSUserDto | undefined;

    constructor(data?: IGetIDMSUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tblUser = data["tblUser"] ? CreateOrEditIDMSUserDto.fromJS(data["tblUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetIDMSUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIDMSUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tblUser"] = this.tblUser ? this.tblUser.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetIDMSUserForEditOutput {
    tblUser: CreateOrEditIDMSUserDto | undefined;
}

export class CreateOrEditIDMSUserDto implements ICreateOrEditIDMSUserDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditIDMSUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditIDMSUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditIDMSUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditIDMSUserDto {
    id: number | undefined;
}

export class PagedResultDtoOfGetIndustryCodeForViewDto implements IPagedResultDtoOfGetIndustryCodeForViewDto {
    totalCount!: number | undefined;
    items!: GetIndustryCodeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetIndustryCodeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetIndustryCodeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetIndustryCodeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetIndustryCodeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetIndustryCodeForViewDto {
    totalCount: number | undefined;
    items: GetIndustryCodeForViewDto[] | undefined;
}

export class GetIndustryCodeForViewDto implements IGetIndustryCodeForViewDto {
    industryCode!: IndustryCodeDto | undefined;

    constructor(data?: IGetIndustryCodeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.industryCode = data["industryCode"] ? IndustryCodeDto.fromJS(data["industryCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetIndustryCodeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetIndustryCodeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["industryCode"] = this.industryCode ? this.industryCode.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetIndustryCodeForViewDto {
    industryCode: IndustryCodeDto | undefined;
}

export class IndustryCodeDto implements IIndustryCodeDto {
    id!: number | undefined;

    constructor(data?: IIndustryCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): IndustryCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IndustryCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IIndustryCodeDto {
    id: number | undefined;
}

export class GetIndustryCodeForEditOutput implements IGetIndustryCodeForEditOutput {
    industryCode!: CreateOrEditIndustryCodeDto | undefined;

    constructor(data?: IGetIndustryCodeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.industryCode = data["industryCode"] ? CreateOrEditIndustryCodeDto.fromJS(data["industryCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetIndustryCodeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIndustryCodeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["industryCode"] = this.industryCode ? this.industryCode.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetIndustryCodeForEditOutput {
    industryCode: CreateOrEditIndustryCodeDto | undefined;
}

export class CreateOrEditIndustryCodeDto implements ICreateOrEditIndustryCodeDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditIndustryCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditIndustryCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditIndustryCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditIndustryCodeDto {
    id: number | undefined;
}

export class InstallDto implements IInstallDto {
    connectionString!: string;
    adminPassword!: string;
    webSiteUrl!: string;
    serverUrl!: string | undefined;
    defaultLanguage!: string;
    smtpSettings!: EmailSettingsEditDto | undefined;
    billInfo!: HostBillingSettingsEditDto | undefined;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.adminPassword = data["adminPassword"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverUrl = data["serverUrl"];
            this.defaultLanguage = data["defaultLanguage"];
            this.smtpSettings = data["smtpSettings"] ? EmailSettingsEditDto.fromJS(data["smtpSettings"]) : <any>undefined;
            this.billInfo = data["billInfo"] ? HostBillingSettingsEditDto.fromJS(data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto | undefined;
    billInfo: HostBillingSettingsEditDto | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl!: string | undefined;
    serverSiteUrl!: string | undefined;
    languages!: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.webSiteUrl = data["webSiteUrl"];
            this.serverSiteUrl = data["serverSiteUrl"];
            if (Array.isArray(data["languages"])) {
                this.languages = [] as any;
                for (let item of data["languages"])
                    this.languages!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist!: boolean | undefined;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDatabaseExist = data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean | undefined;
}

export class InvoiceDto implements IInvoiceDto {
    amount!: number | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: string | undefined;
    invoiceDate!: moment.Moment | undefined;
    tenantLegalName!: string | undefined;
    tenantAddress!: string[] | undefined;
    tenantTaxNo!: string | undefined;
    hostLegalName!: string | undefined;
    hostAddress!: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceDate = data["invoiceDate"] ? moment(data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = data["tenantLegalName"];
            if (Array.isArray(data["tenantAddress"])) {
                this.tenantAddress = [] as any;
                for (let item of data["tenantAddress"])
                    this.tenantAddress!.push(item);
            }
            this.tenantTaxNo = data["tenantTaxNo"];
            this.hostLegalName = data["hostLegalName"];
            if (Array.isArray(data["hostAddress"])) {
                this.hostAddress = [] as any;
                for (let item of data["hostAddress"])
                    this.hostAddress!.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (Array.isArray(this.tenantAddress)) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (Array.isArray(this.hostAddress)) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data; 
    }
}

export interface IInvoiceDto {
    amount: number | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment | undefined;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId!: number | undefined;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionPaymentId = data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto | undefined;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (Array.isArray(data["languageNames"])) {
                this.languageNames = [] as any;
                for (let item of data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(data["flags"])) {
                this.flags = [] as any;
                for (let item of data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (Array.isArray(this.languageNames)) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (Array.isArray(this.flags)) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean | undefined;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number | undefined;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class PagedResultDtoOfIListAutomateDto implements IPagedResultDtoOfIListAutomateDto {
    totalCount!: number | undefined;
    items!: IListAutomateDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIListAutomateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(IListAutomateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIListAutomateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIListAutomateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIListAutomateDto {
    totalCount: number | undefined;
    items: IListAutomateDto[] | undefined;
}

export class IListAutomateDto implements IIListAutomateDto {
    listId!: number | undefined;
    buildId!: number | undefined;
    lK_ListConversionFrequency!: string | undefined;
    iInterval!: number | undefined;
    cScheduleTime!: string | undefined;
    cSystemFileNameReadyToLoad!: string | undefined;
    iIsActive!: boolean | undefined;
    cScheduledBy!: string | undefined;
    id!: number | undefined;

    constructor(data?: IIListAutomateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.listId = data["listId"];
            this.buildId = data["buildId"];
            this.lK_ListConversionFrequency = data["lK_ListConversionFrequency"];
            this.iInterval = data["iInterval"];
            this.cScheduleTime = data["cScheduleTime"];
            this.cSystemFileNameReadyToLoad = data["cSystemFileNameReadyToLoad"];
            this.iIsActive = data["iIsActive"];
            this.cScheduledBy = data["cScheduledBy"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): IListAutomateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IListAutomateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["buildId"] = this.buildId;
        data["lK_ListConversionFrequency"] = this.lK_ListConversionFrequency;
        data["iInterval"] = this.iInterval;
        data["cScheduleTime"] = this.cScheduleTime;
        data["cSystemFileNameReadyToLoad"] = this.cSystemFileNameReadyToLoad;
        data["iIsActive"] = this.iIsActive;
        data["cScheduledBy"] = this.cScheduledBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IIListAutomateDto {
    listId: number | undefined;
    buildId: number | undefined;
    lK_ListConversionFrequency: string | undefined;
    iInterval: number | undefined;
    cScheduleTime: string | undefined;
    cSystemFileNameReadyToLoad: string | undefined;
    iIsActive: boolean | undefined;
    cScheduledBy: string | undefined;
    id: number | undefined;
}

export class CreateOrEditIListAutomateDto implements ICreateOrEditIListAutomateDto {
    listId!: number | undefined;
    buildId!: number | undefined;
    lK_ListConversionFrequency!: string | undefined;
    iInterval!: number | undefined;
    cScheduleTime!: string | undefined;
    cSystemFileNameReadyToLoad!: string | undefined;
    iIsActive!: boolean | undefined;
    cScheduledBy!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditIListAutomateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.listId = data["listId"];
            this.buildId = data["buildId"];
            this.lK_ListConversionFrequency = data["lK_ListConversionFrequency"];
            this.iInterval = data["iInterval"];
            this.cScheduleTime = data["cScheduleTime"];
            this.cSystemFileNameReadyToLoad = data["cSystemFileNameReadyToLoad"];
            this.iIsActive = data["iIsActive"];
            this.cScheduledBy = data["cScheduledBy"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditIListAutomateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditIListAutomateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["buildId"] = this.buildId;
        data["lK_ListConversionFrequency"] = this.lK_ListConversionFrequency;
        data["iInterval"] = this.iInterval;
        data["cScheduleTime"] = this.cScheduleTime;
        data["cSystemFileNameReadyToLoad"] = this.cSystemFileNameReadyToLoad;
        data["iIsActive"] = this.iIsActive;
        data["cScheduledBy"] = this.cScheduledBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditIListAutomateDto {
    listId: number | undefined;
    buildId: number | undefined;
    lK_ListConversionFrequency: string | undefined;
    iInterval: number | undefined;
    cScheduleTime: string | undefined;
    cSystemFileNameReadyToLoad: string | undefined;
    iIsActive: boolean | undefined;
    cScheduledBy: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetListLoadStatusForViewDto implements IPagedResultDtoOfGetListLoadStatusForViewDto {
    totalCount!: number | undefined;
    items!: GetListLoadStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetListLoadStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetListLoadStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetListLoadStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetListLoadStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetListLoadStatusForViewDto {
    totalCount: number | undefined;
    items: GetListLoadStatusForViewDto[] | undefined;
}

export class GetListLoadStatusForViewDto implements IGetListLoadStatusForViewDto {
    listLoadStatus!: ListLoadStatusDto | undefined;

    constructor(data?: IGetListLoadStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.listLoadStatus = data["listLoadStatus"] ? ListLoadStatusDto.fromJS(data["listLoadStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetListLoadStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetListLoadStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listLoadStatus"] = this.listLoadStatus ? this.listLoadStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetListLoadStatusForViewDto {
    listLoadStatus: ListLoadStatusDto | undefined;
}

export class ListLoadStatusDto implements IListLoadStatusDto {
    id!: number | undefined;

    constructor(data?: IListLoadStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ListLoadStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListLoadStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IListLoadStatusDto {
    id: number | undefined;
}

export class GetListLoadStatusForEditOutput implements IGetListLoadStatusForEditOutput {
    listLoadStatus!: CreateOrEditListLoadStatusDto | undefined;

    constructor(data?: IGetListLoadStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.listLoadStatus = data["listLoadStatus"] ? CreateOrEditListLoadStatusDto.fromJS(data["listLoadStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetListLoadStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetListLoadStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listLoadStatus"] = this.listLoadStatus ? this.listLoadStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetListLoadStatusForEditOutput {
    listLoadStatus: CreateOrEditListLoadStatusDto | undefined;
}

export class CreateOrEditListLoadStatusDto implements ICreateOrEditListLoadStatusDto {
    cCalculation!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditListLoadStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cCalculation = data["cCalculation"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditListLoadStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditListLoadStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cCalculation"] = this.cCalculation;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditListLoadStatusDto {
    cCalculation: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetListMailerRequestedForViewDto implements IPagedResultDtoOfGetListMailerRequestedForViewDto {
    totalCount!: number | undefined;
    items!: GetListMailerRequestedForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetListMailerRequestedForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetListMailerRequestedForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetListMailerRequestedForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetListMailerRequestedForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetListMailerRequestedForViewDto {
    totalCount: number | undefined;
    items: GetListMailerRequestedForViewDto[] | undefined;
}

export class GetListMailerRequestedForViewDto implements IGetListMailerRequestedForViewDto {
    listMailerRequested!: ListMailerRequestedDto | undefined;
    masterLoLcListName!: string | undefined;

    constructor(data?: IGetListMailerRequestedForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.listMailerRequested = data["listMailerRequested"] ? ListMailerRequestedDto.fromJS(data["listMailerRequested"]) : <any>undefined;
            this.masterLoLcListName = data["masterLoLcListName"];
        }
    }

    static fromJS(data: any): GetListMailerRequestedForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetListMailerRequestedForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listMailerRequested"] = this.listMailerRequested ? this.listMailerRequested.toJSON() : <any>undefined;
        data["masterLoLcListName"] = this.masterLoLcListName;
        return data; 
    }
}

export interface IGetListMailerRequestedForViewDto {
    listMailerRequested: ListMailerRequestedDto | undefined;
    masterLoLcListName: string | undefined;
}

export class ListMailerRequestedDto implements IListMailerRequestedDto {
    mailerID!: number | undefined;
    cCreatedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    listID!: number | undefined;
    id!: number | undefined;

    constructor(data?: IListMailerRequestedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mailerID = data["mailerID"];
            this.cCreatedBy = data["cCreatedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.listID = data["listID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ListMailerRequestedDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListMailerRequestedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailerID"] = this.mailerID;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["listID"] = this.listID;
        data["id"] = this.id;
        return data; 
    }
}

export interface IListMailerRequestedDto {
    mailerID: number | undefined;
    cCreatedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    listID: number | undefined;
    id: number | undefined;
}

export class GetListMailerRequestedForEditOutput implements IGetListMailerRequestedForEditOutput {
    listMailerRequested!: CreateOrEditListMailerRequestedDto | undefined;
    masterLoLcListName!: string | undefined;

    constructor(data?: IGetListMailerRequestedForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.listMailerRequested = data["listMailerRequested"] ? CreateOrEditListMailerRequestedDto.fromJS(data["listMailerRequested"]) : <any>undefined;
            this.masterLoLcListName = data["masterLoLcListName"];
        }
    }

    static fromJS(data: any): GetListMailerRequestedForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetListMailerRequestedForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listMailerRequested"] = this.listMailerRequested ? this.listMailerRequested.toJSON() : <any>undefined;
        data["masterLoLcListName"] = this.masterLoLcListName;
        return data; 
    }
}

export interface IGetListMailerRequestedForEditOutput {
    listMailerRequested: CreateOrEditListMailerRequestedDto | undefined;
    masterLoLcListName: string | undefined;
}

export class CreateOrEditListMailerRequestedDto implements ICreateOrEditListMailerRequestedDto {
    mailerID!: number | undefined;
    cCreatedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    listID!: number | undefined;
    action!: ActionType | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditListMailerRequestedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mailerID = data["mailerID"];
            this.cCreatedBy = data["cCreatedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.listID = data["listID"];
            this.action = data["action"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditListMailerRequestedDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditListMailerRequestedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailerID"] = this.mailerID;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["listID"] = this.listID;
        data["action"] = this.action;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditListMailerRequestedDto {
    mailerID: number | undefined;
    cCreatedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    listID: number | undefined;
    action: ActionType | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfListMailerRequestedMasterLoLLookupTableDto implements IPagedResultDtoOfListMailerRequestedMasterLoLLookupTableDto {
    totalCount!: number | undefined;
    items!: ListMailerRequestedMasterLoLLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfListMailerRequestedMasterLoLLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ListMailerRequestedMasterLoLLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfListMailerRequestedMasterLoLLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfListMailerRequestedMasterLoLLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfListMailerRequestedMasterLoLLookupTableDto {
    totalCount: number | undefined;
    items: ListMailerRequestedMasterLoLLookupTableDto[] | undefined;
}

export class ListMailerRequestedMasterLoLLookupTableDto implements IListMailerRequestedMasterLoLLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IListMailerRequestedMasterLoLLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ListMailerRequestedMasterLoLLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListMailerRequestedMasterLoLLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IListMailerRequestedMasterLoLLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetListMailerForViewDto implements IPagedResultDtoOfGetListMailerForViewDto {
    totalCount!: number | undefined;
    items!: GetListMailerForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetListMailerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetListMailerForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetListMailerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetListMailerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetListMailerForViewDto {
    totalCount: number | undefined;
    items: GetListMailerForViewDto[] | undefined;
}

export class GetListMailerForViewDto implements IGetListMailerForViewDto {
    listMailer!: ListMailerDto | undefined;
    masterLoLcListName!: string | undefined;

    constructor(data?: IGetListMailerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.listMailer = data["listMailer"] ? ListMailerDto.fromJS(data["listMailer"]) : <any>undefined;
            this.masterLoLcListName = data["masterLoLcListName"];
        }
    }

    static fromJS(data: any): GetListMailerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetListMailerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listMailer"] = this.listMailer ? this.listMailer.toJSON() : <any>undefined;
        data["masterLoLcListName"] = this.masterLoLcListName;
        return data; 
    }
}

export interface IGetListMailerForViewDto {
    listMailer: ListMailerDto | undefined;
    masterLoLcListName: string | undefined;
}

export class ListMailerDto implements IListMailerDto {
    id!: number | undefined;
    mailerID!: number | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    listID!: number | undefined;

    constructor(data?: IListMailerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.mailerID = data["mailerID"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.listID = data["listID"];
        }
    }

    static fromJS(data: any): ListMailerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListMailerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mailerID"] = this.mailerID;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["listID"] = this.listID;
        return data; 
    }
}

export interface IListMailerDto {
    id: number | undefined;
    mailerID: number | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    listID: number | undefined;
}

export class PagedResultDtoOfGetLoadProcessStatusForViewDto implements IPagedResultDtoOfGetLoadProcessStatusForViewDto {
    totalCount!: number | undefined;
    items!: GetLoadProcessStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetLoadProcessStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetLoadProcessStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetLoadProcessStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetLoadProcessStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetLoadProcessStatusForViewDto {
    totalCount: number | undefined;
    items: GetLoadProcessStatusForViewDto[] | undefined;
}

export class GetLoadProcessStatusForViewDto implements IGetLoadProcessStatusForViewDto {
    loadProcessStatus!: LoadProcessStatusDto | undefined;

    constructor(data?: IGetLoadProcessStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loadProcessStatus = data["loadProcessStatus"] ? LoadProcessStatusDto.fromJS(data["loadProcessStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetLoadProcessStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLoadProcessStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loadProcessStatus"] = this.loadProcessStatus ? this.loadProcessStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetLoadProcessStatusForViewDto {
    loadProcessStatus: LoadProcessStatusDto | undefined;
}

export class LoadProcessStatusDto implements ILoadProcessStatusDto {
    id!: number | undefined;

    constructor(data?: ILoadProcessStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LoadProcessStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoadProcessStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ILoadProcessStatusDto {
    id: number | undefined;
}

export class GetLoadProcessStatusForEditOutput implements IGetLoadProcessStatusForEditOutput {
    loadProcessStatus!: CreateOrEditLoadProcessStatusDto | undefined;

    constructor(data?: IGetLoadProcessStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loadProcessStatus = data["loadProcessStatus"] ? CreateOrEditLoadProcessStatusDto.fromJS(data["loadProcessStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetLoadProcessStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLoadProcessStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loadProcessStatus"] = this.loadProcessStatus ? this.loadProcessStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetLoadProcessStatusForEditOutput {
    loadProcessStatus: CreateOrEditLoadProcessStatusDto | undefined;
}

export class CreateOrEditLoadProcessStatusDto implements ICreateOrEditLoadProcessStatusDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditLoadProcessStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditLoadProcessStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditLoadProcessStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditLoadProcessStatusDto {
    id: number | undefined;
}

export class PagedResultDtoOfLookupDto implements IPagedResultDtoOfLookupDto {
    totalCount!: number | undefined;
    items!: LookupDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLookupDto {
    totalCount: number | undefined;
    items: LookupDto[] | undefined;
}

export class LookupDto implements ILookupDto {
    id!: number | undefined;
    cLookupValue!: string | undefined;
    iOrderBy!: number | undefined;
    cCode!: string | undefined;
    cDescription!: string | undefined;
    cField!: string | undefined;
    mField!: string | undefined;
    iField!: number | undefined;
    iIsActive!: boolean | undefined;
    cCreatedBy!: string | undefined;
    cModifiedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    dModifiedDate!: moment.Moment | undefined;

    constructor(data?: ILookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cLookupValue = data["cLookupValue"];
            this.iOrderBy = data["iOrderBy"];
            this.cCode = data["cCode"];
            this.cDescription = data["cDescription"];
            this.cField = data["cField"];
            this.mField = data["mField"];
            this.iField = data["iField"];
            this.iIsActive = data["iIsActive"];
            this.cCreatedBy = data["cCreatedBy"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cLookupValue"] = this.cLookupValue;
        data["iOrderBy"] = this.iOrderBy;
        data["cCode"] = this.cCode;
        data["cDescription"] = this.cDescription;
        data["cField"] = this.cField;
        data["mField"] = this.mField;
        data["iField"] = this.iField;
        data["iIsActive"] = this.iIsActive;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ILookupDto {
    id: number | undefined;
    cLookupValue: string | undefined;
    iOrderBy: number | undefined;
    cCode: string | undefined;
    cDescription: string | undefined;
    cField: string | undefined;
    mField: string | undefined;
    iField: number | undefined;
    iIsActive: boolean | undefined;
    cCreatedBy: string | undefined;
    cModifiedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    dModifiedDate: moment.Moment | undefined;
}

export class CreateOrEditLookupDto implements ICreateOrEditLookupDto {
    cLookupValue!: string | undefined;
    iOrderBy!: number | undefined;
    cCode!: string | undefined;
    cDescription!: string | undefined;
    cField!: string | undefined;
    mField!: string | undefined;
    iField!: number | undefined;
    iIsActive!: boolean | undefined;
    cCreatedBy!: string | undefined;
    cModifiedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    dModifiedDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cLookupValue = data["cLookupValue"];
            this.iOrderBy = data["iOrderBy"];
            this.cCode = data["cCode"];
            this.cDescription = data["cDescription"];
            this.cField = data["cField"];
            this.mField = data["mField"];
            this.iField = data["iField"];
            this.iIsActive = data["iIsActive"];
            this.cCreatedBy = data["cCreatedBy"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cLookupValue"] = this.cLookupValue;
        data["iOrderBy"] = this.iOrderBy;
        data["cCode"] = this.cCode;
        data["cDescription"] = this.cDescription;
        data["cField"] = this.cField;
        data["mField"] = this.mField;
        data["iField"] = this.iField;
        data["iIsActive"] = this.iIsActive;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditLookupDto {
    cLookupValue: string | undefined;
    iOrderBy: number | undefined;
    cCode: string | undefined;
    cDescription: string | undefined;
    cField: string | undefined;
    mField: string | undefined;
    iField: number | undefined;
    iIsActive: boolean | undefined;
    cCreatedBy: string | undefined;
    cModifiedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    dModifiedDate: moment.Moment | undefined;
    id: number | undefined;
}

export class CreateOrEditMailerDto implements ICreateOrEditMailerDto {
    cCode!: string | undefined;
    cCompany!: string | undefined;
    cAddress1!: string | undefined;
    cAddress2!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cZip!: string | undefined;
    cPhone!: string | undefined;
    cFax!: string | undefined;
    cNotes!: string | undefined;
    brokerId!: number | undefined;
    iIsActive!: boolean | undefined;
    databaseId!: number | undefined;
    cCreatedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    addPostalOffer!: boolean | undefined;
    addTelemarketingOffer!: boolean | undefined;
    autoApproveAllOffer!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMailerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cCode = data["cCode"];
            this.cCompany = data["cCompany"];
            this.cAddress1 = data["cAddress1"];
            this.cAddress2 = data["cAddress2"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cZip = data["cZip"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            this.cNotes = data["cNotes"];
            this.brokerId = data["brokerId"];
            this.iIsActive = data["iIsActive"];
            this.databaseId = data["databaseId"];
            this.cCreatedBy = data["cCreatedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.addPostalOffer = data["addPostalOffer"];
            this.addTelemarketingOffer = data["addTelemarketingOffer"];
            this.autoApproveAllOffer = data["autoApproveAllOffer"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMailerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMailerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cCode"] = this.cCode;
        data["cCompany"] = this.cCompany;
        data["cAddress1"] = this.cAddress1;
        data["cAddress2"] = this.cAddress2;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cZip"] = this.cZip;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        data["cNotes"] = this.cNotes;
        data["brokerId"] = this.brokerId;
        data["iIsActive"] = this.iIsActive;
        data["databaseId"] = this.databaseId;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["addPostalOffer"] = this.addPostalOffer;
        data["addTelemarketingOffer"] = this.addTelemarketingOffer;
        data["autoApproveAllOffer"] = this.autoApproveAllOffer;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditMailerDto {
    cCode: string | undefined;
    cCompany: string | undefined;
    cAddress1: string | undefined;
    cAddress2: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cZip: string | undefined;
    cPhone: string | undefined;
    cFax: string | undefined;
    cNotes: string | undefined;
    brokerId: number | undefined;
    iIsActive: boolean | undefined;
    databaseId: number | undefined;
    cCreatedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    addPostalOffer: boolean | undefined;
    addTelemarketingOffer: boolean | undefined;
    autoApproveAllOffer: boolean | undefined;
    id: number | undefined;
}

export class GetAllSetupInput implements IGetAllSetupInput {
    filter!: string | undefined;
    iIsActiveFilter!: number | undefined;
    selectedDatabase!: number | undefined;
    contactLastNameFilterText!: string | undefined;
    contactEmailFilterText!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IGetAllSetupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.iIsActiveFilter = data["iIsActiveFilter"];
            this.selectedDatabase = data["selectedDatabase"];
            this.contactLastNameFilterText = data["contactLastNameFilterText"];
            this.contactEmailFilterText = data["contactEmailFilterText"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAllSetupInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSetupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["iIsActiveFilter"] = this.iIsActiveFilter;
        data["selectedDatabase"] = this.selectedDatabase;
        data["contactLastNameFilterText"] = this.contactLastNameFilterText;
        data["contactEmailFilterText"] = this.contactEmailFilterText;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IGetAllSetupInput {
    filter: string | undefined;
    iIsActiveFilter: number | undefined;
    selectedDatabase: number | undefined;
    contactLastNameFilterText: string | undefined;
    contactEmailFilterText: string | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class PagedResultDtoOfManagerDto implements IPagedResultDtoOfManagerDto {
    totalCount!: number | undefined;
    items!: ManagerDto[] | undefined;

    constructor(data?: IPagedResultDtoOfManagerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ManagerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfManagerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfManagerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfManagerDto {
    totalCount: number | undefined;
    items: ManagerDto[] | undefined;
}

export class ManagerDto implements IManagerDto {
    cCode!: string | undefined;
    cCompany!: string | undefined;
    iIsActive!: boolean | undefined;
    cAddress!: string | undefined;
    databaseId!: number | undefined;
    contactsCount!: number | undefined;
    cAddress1!: string | undefined;
    cAddress2!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cZip!: string | undefined;
    cPhone!: string | undefined;
    cFax!: string | undefined;
    contactsList!: CreateOrEditContactDto[] | undefined;
    id!: number | undefined;

    constructor(data?: IManagerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cCode = data["cCode"];
            this.cCompany = data["cCompany"];
            this.iIsActive = data["iIsActive"];
            this.cAddress = data["cAddress"];
            this.databaseId = data["databaseId"];
            this.contactsCount = data["contactsCount"];
            this.cAddress1 = data["cAddress1"];
            this.cAddress2 = data["cAddress2"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cZip = data["cZip"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            if (Array.isArray(data["contactsList"])) {
                this.contactsList = [] as any;
                for (let item of data["contactsList"])
                    this.contactsList!.push(CreateOrEditContactDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ManagerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ManagerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cCode"] = this.cCode;
        data["cCompany"] = this.cCompany;
        data["iIsActive"] = this.iIsActive;
        data["cAddress"] = this.cAddress;
        data["databaseId"] = this.databaseId;
        data["contactsCount"] = this.contactsCount;
        data["cAddress1"] = this.cAddress1;
        data["cAddress2"] = this.cAddress2;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cZip"] = this.cZip;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        if (Array.isArray(this.contactsList)) {
            data["contactsList"] = [];
            for (let item of this.contactsList)
                data["contactsList"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IManagerDto {
    cCode: string | undefined;
    cCompany: string | undefined;
    iIsActive: boolean | undefined;
    cAddress: string | undefined;
    databaseId: number | undefined;
    contactsCount: number | undefined;
    cAddress1: string | undefined;
    cAddress2: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cZip: string | undefined;
    cPhone: string | undefined;
    cFax: string | undefined;
    contactsList: CreateOrEditContactDto[] | undefined;
    id: number | undefined;
}

export class CreateOrEditManagerDto implements ICreateOrEditManagerDto {
    cCode!: string | undefined;
    cCompany!: string | undefined;
    cAddress1!: string | undefined;
    cAddress2!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cZip!: string | undefined;
    cPhone!: string | undefined;
    cFax!: string | undefined;
    cNotes!: string | undefined;
    iIsActive!: boolean | undefined;
    databaseId!: number | undefined;
    cCreatedBy!: string | undefined;
    cModifiedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    dModifiedDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditManagerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cCode = data["cCode"];
            this.cCompany = data["cCompany"];
            this.cAddress1 = data["cAddress1"];
            this.cAddress2 = data["cAddress2"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cZip = data["cZip"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            this.cNotes = data["cNotes"];
            this.iIsActive = data["iIsActive"];
            this.databaseId = data["databaseId"];
            this.cCreatedBy = data["cCreatedBy"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditManagerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditManagerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cCode"] = this.cCode;
        data["cCompany"] = this.cCompany;
        data["cAddress1"] = this.cAddress1;
        data["cAddress2"] = this.cAddress2;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cZip"] = this.cZip;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        data["cNotes"] = this.cNotes;
        data["iIsActive"] = this.iIsActive;
        data["databaseId"] = this.databaseId;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditManagerDto {
    cCode: string | undefined;
    cCompany: string | undefined;
    cAddress1: string | undefined;
    cAddress2: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cZip: string | undefined;
    cPhone: string | undefined;
    cFax: string | undefined;
    cNotes: string | undefined;
    iIsActive: boolean | undefined;
    databaseId: number | undefined;
    cCreatedBy: string | undefined;
    cModifiedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    dModifiedDate: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfMasterLoLForViewDto implements IPagedResultDtoOfMasterLoLForViewDto {
    totalCount!: number | undefined;
    items!: MasterLoLForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMasterLoLForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MasterLoLForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMasterLoLForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMasterLoLForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMasterLoLForViewDto {
    totalCount: number | undefined;
    items: MasterLoLForViewDto[] | undefined;
}

export class MasterLoLForViewDto implements IMasterLoLForViewDto {
    id!: number | undefined;
    cListName!: string | undefined;
    cCode!: string | undefined;
    cNextMarkID!: string | undefined;
    ownerID!: number | undefined;
    listOwner!: string | undefined;
    managerName!: string | undefined;
    iIsActive!: boolean | undefined;
    iIsMultibuyer!: boolean | undefined;
    lK_PermissionType!: string | undefined;
    lK_ListType!: string | undefined;
    lK_ProductCode!: string | undefined;
    lK_DecisionGroup!: string | undefined;
    cEmailAddress!: string | undefined;
    permissionTypeValue!: string | undefined;

    constructor(data?: IMasterLoLForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cListName = data["cListName"];
            this.cCode = data["cCode"];
            this.cNextMarkID = data["cNextMarkID"];
            this.ownerID = data["ownerID"];
            this.listOwner = data["listOwner"];
            this.managerName = data["managerName"];
            this.iIsActive = data["iIsActive"];
            this.iIsMultibuyer = data["iIsMultibuyer"];
            this.lK_PermissionType = data["lK_PermissionType"];
            this.lK_ListType = data["lK_ListType"];
            this.lK_ProductCode = data["lK_ProductCode"];
            this.lK_DecisionGroup = data["lK_DecisionGroup"];
            this.cEmailAddress = data["cEmailAddress"];
            this.permissionTypeValue = data["permissionTypeValue"];
        }
    }

    static fromJS(data: any): MasterLoLForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new MasterLoLForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cListName"] = this.cListName;
        data["cCode"] = this.cCode;
        data["cNextMarkID"] = this.cNextMarkID;
        data["ownerID"] = this.ownerID;
        data["listOwner"] = this.listOwner;
        data["managerName"] = this.managerName;
        data["iIsActive"] = this.iIsActive;
        data["iIsMultibuyer"] = this.iIsMultibuyer;
        data["lK_PermissionType"] = this.lK_PermissionType;
        data["lK_ListType"] = this.lK_ListType;
        data["lK_ProductCode"] = this.lK_ProductCode;
        data["lK_DecisionGroup"] = this.lK_DecisionGroup;
        data["cEmailAddress"] = this.cEmailAddress;
        data["permissionTypeValue"] = this.permissionTypeValue;
        return data; 
    }
}

export interface IMasterLoLForViewDto {
    id: number | undefined;
    cListName: string | undefined;
    cCode: string | undefined;
    cNextMarkID: string | undefined;
    ownerID: number | undefined;
    listOwner: string | undefined;
    managerName: string | undefined;
    iIsActive: boolean | undefined;
    iIsMultibuyer: boolean | undefined;
    lK_PermissionType: string | undefined;
    lK_ListType: string | undefined;
    lK_ProductCode: string | undefined;
    lK_DecisionGroup: string | undefined;
    cEmailAddress: string | undefined;
    permissionTypeValue: string | undefined;
}

export class PagedResultDtoOfContactTableDto implements IPagedResultDtoOfContactTableDto {
    totalCount!: number | undefined;
    items!: ContactTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ContactTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfContactTableDto {
    totalCount: number | undefined;
    items: ContactTableDto[] | undefined;
}

export class ContactTableDto implements IContactTableDto {
    id!: number | undefined;
    name!: string | undefined;
    email!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IContactTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.email = data["email"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): ContactTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IContactTableDto {
    id: number | undefined;
    name: string | undefined;
    email: string | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class PagedResultDtoOfLookupForListofListDto implements IPagedResultDtoOfLookupForListofListDto {
    totalCount!: number | undefined;
    items!: LookupForListofListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLookupForListofListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LookupForListofListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLookupForListofListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLookupForListofListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLookupForListofListDto {
    totalCount: number | undefined;
    items: LookupForListofListDto[] | undefined;
}

export class LookupForListofListDto implements ILookupForListofListDto {
    id!: number | undefined;
    cLookupValue!: string | undefined;
    iOrderBy!: number | undefined;
    cCode!: string | undefined;
    cDescription!: string | undefined;
    cField!: string | undefined;
    mField!: string | undefined;
    iField!: number | undefined;
    iIsActive!: boolean | undefined;
    cCreatedBy!: string | undefined;
    cModifiedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    dModifiedDate!: moment.Moment | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: ILookupForListofListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cLookupValue = data["cLookupValue"];
            this.iOrderBy = data["iOrderBy"];
            this.cCode = data["cCode"];
            this.cDescription = data["cDescription"];
            this.cField = data["cField"];
            this.mField = data["mField"];
            this.iField = data["iField"];
            this.iIsActive = data["iIsActive"];
            this.cCreatedBy = data["cCreatedBy"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): LookupForListofListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupForListofListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cLookupValue"] = this.cLookupValue;
        data["iOrderBy"] = this.iOrderBy;
        data["cCode"] = this.cCode;
        data["cDescription"] = this.cDescription;
        data["cField"] = this.cField;
        data["mField"] = this.mField;
        data["iField"] = this.iField;
        data["iIsActive"] = this.iIsActive;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface ILookupForListofListDto {
    id: number | undefined;
    cLookupValue: string | undefined;
    iOrderBy: number | undefined;
    cCode: string | undefined;
    cDescription: string | undefined;
    cField: string | undefined;
    mField: string | undefined;
    iField: number | undefined;
    iIsActive: boolean | undefined;
    cCreatedBy: string | undefined;
    cModifiedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    dModifiedDate: moment.Moment | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class CreateOrEditMasterLoLDto implements ICreateOrEditMasterLoLDto {
    databaseId!: number | undefined;
    ownerID!: number | undefined;
    managerID!: number | undefined;
    listofContacts!: CreateOrEditListCASContacts[] | undefined;
    listOfMailers!: CreateOrEditListMailerDto[] | undefined;
    listofReqMailer!: CreateOrEditListMailerRequestedDto[] | undefined;
    lK_PermissionType!: string | undefined;
    lK_ListType!: string | undefined;
    lK_ProductCode!: string | undefined;
    lK_DecisionGroup!: string | undefined;
    cCode!: string | undefined;
    cDMIDWListNumber!: string | undefined;
    cListName!: string | undefined;
    cMINDatacardCode!: string | undefined;
    cNextMarkID!: string | undefined;
    iOrderContactID!: number | undefined;
    iIsMultibuyer!: boolean | undefined;
    cAppearDate!: string | undefined;
    cLastUpdateDate!: string | undefined;
    cRemoveDate!: string | undefined;
    iSendCASApproval!: boolean | undefined;
    dEmailSentDate!: moment.Moment | undefined;
    nBasePrice_Postal!: number | undefined;
    nBasePrice_Telemarketing!: number | undefined;
    nNewBasePrice_Postal!: number | undefined;
    nNewBasePrice_Telemarketing!: number | undefined;
    cCAS_Signature!: string | undefined;
    cCAS_IPAddress!: string | undefined;
    cCAS_ApprovedBy!: string | undefined;
    iIsActive!: boolean | undefined;
    iApprovalForm!: boolean | undefined;
    iDropDuplicates!: boolean | undefined;
    cCustomText1!: string | undefined;
    cCustomText2!: string | undefined;
    cCustomText3!: string | undefined;
    cCustomText4!: string | undefined;
    cCustomText5!: string | undefined;
    cCustomText6!: string | undefined;
    cCustomText7!: string | undefined;
    cCustomText8!: string | undefined;
    cCustomText9!: string | undefined;
    cCustomText10!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    iIsNCOARequired!: boolean | undefined;
    iIsProfanityCheckRequired!: boolean | undefined;
    guid!: string | undefined;
    dValidUpTill!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMasterLoLDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseId = data["databaseId"];
            this.ownerID = data["ownerID"];
            this.managerID = data["managerID"];
            if (Array.isArray(data["listofContacts"])) {
                this.listofContacts = [] as any;
                for (let item of data["listofContacts"])
                    this.listofContacts!.push(CreateOrEditListCASContacts.fromJS(item));
            }
            if (Array.isArray(data["listOfMailers"])) {
                this.listOfMailers = [] as any;
                for (let item of data["listOfMailers"])
                    this.listOfMailers!.push(CreateOrEditListMailerDto.fromJS(item));
            }
            if (Array.isArray(data["listofReqMailer"])) {
                this.listofReqMailer = [] as any;
                for (let item of data["listofReqMailer"])
                    this.listofReqMailer!.push(CreateOrEditListMailerRequestedDto.fromJS(item));
            }
            this.lK_PermissionType = data["lK_PermissionType"];
            this.lK_ListType = data["lK_ListType"];
            this.lK_ProductCode = data["lK_ProductCode"];
            this.lK_DecisionGroup = data["lK_DecisionGroup"];
            this.cCode = data["cCode"];
            this.cDMIDWListNumber = data["cDMIDWListNumber"];
            this.cListName = data["cListName"];
            this.cMINDatacardCode = data["cMINDatacardCode"];
            this.cNextMarkID = data["cNextMarkID"];
            this.iOrderContactID = data["iOrderContactID"];
            this.iIsMultibuyer = data["iIsMultibuyer"];
            this.cAppearDate = data["cAppearDate"];
            this.cLastUpdateDate = data["cLastUpdateDate"];
            this.cRemoveDate = data["cRemoveDate"];
            this.iSendCASApproval = data["iSendCASApproval"];
            this.dEmailSentDate = data["dEmailSentDate"] ? moment(data["dEmailSentDate"].toString()) : <any>undefined;
            this.nBasePrice_Postal = data["nBasePrice_Postal"];
            this.nBasePrice_Telemarketing = data["nBasePrice_Telemarketing"];
            this.nNewBasePrice_Postal = data["nNewBasePrice_Postal"];
            this.nNewBasePrice_Telemarketing = data["nNewBasePrice_Telemarketing"];
            this.cCAS_Signature = data["cCAS_Signature"];
            this.cCAS_IPAddress = data["cCAS_IPAddress"];
            this.cCAS_ApprovedBy = data["cCAS_ApprovedBy"];
            this.iIsActive = data["iIsActive"];
            this.iApprovalForm = data["iApprovalForm"];
            this.iDropDuplicates = data["iDropDuplicates"];
            this.cCustomText1 = data["cCustomText1"];
            this.cCustomText2 = data["cCustomText2"];
            this.cCustomText3 = data["cCustomText3"];
            this.cCustomText4 = data["cCustomText4"];
            this.cCustomText5 = data["cCustomText5"];
            this.cCustomText6 = data["cCustomText6"];
            this.cCustomText7 = data["cCustomText7"];
            this.cCustomText8 = data["cCustomText8"];
            this.cCustomText9 = data["cCustomText9"];
            this.cCustomText10 = data["cCustomText10"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.iIsNCOARequired = data["iIsNCOARequired"];
            this.iIsProfanityCheckRequired = data["iIsProfanityCheckRequired"];
            this.guid = data["guid"];
            this.dValidUpTill = data["dValidUpTill"] ? moment(data["dValidUpTill"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMasterLoLDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMasterLoLDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseId"] = this.databaseId;
        data["ownerID"] = this.ownerID;
        data["managerID"] = this.managerID;
        if (Array.isArray(this.listofContacts)) {
            data["listofContacts"] = [];
            for (let item of this.listofContacts)
                data["listofContacts"].push(item.toJSON());
        }
        if (Array.isArray(this.listOfMailers)) {
            data["listOfMailers"] = [];
            for (let item of this.listOfMailers)
                data["listOfMailers"].push(item.toJSON());
        }
        if (Array.isArray(this.listofReqMailer)) {
            data["listofReqMailer"] = [];
            for (let item of this.listofReqMailer)
                data["listofReqMailer"].push(item.toJSON());
        }
        data["lK_PermissionType"] = this.lK_PermissionType;
        data["lK_ListType"] = this.lK_ListType;
        data["lK_ProductCode"] = this.lK_ProductCode;
        data["lK_DecisionGroup"] = this.lK_DecisionGroup;
        data["cCode"] = this.cCode;
        data["cDMIDWListNumber"] = this.cDMIDWListNumber;
        data["cListName"] = this.cListName;
        data["cMINDatacardCode"] = this.cMINDatacardCode;
        data["cNextMarkID"] = this.cNextMarkID;
        data["iOrderContactID"] = this.iOrderContactID;
        data["iIsMultibuyer"] = this.iIsMultibuyer;
        data["cAppearDate"] = this.cAppearDate;
        data["cLastUpdateDate"] = this.cLastUpdateDate;
        data["cRemoveDate"] = this.cRemoveDate;
        data["iSendCASApproval"] = this.iSendCASApproval;
        data["dEmailSentDate"] = this.dEmailSentDate ? this.dEmailSentDate.toISOString() : <any>undefined;
        data["nBasePrice_Postal"] = this.nBasePrice_Postal;
        data["nBasePrice_Telemarketing"] = this.nBasePrice_Telemarketing;
        data["nNewBasePrice_Postal"] = this.nNewBasePrice_Postal;
        data["nNewBasePrice_Telemarketing"] = this.nNewBasePrice_Telemarketing;
        data["cCAS_Signature"] = this.cCAS_Signature;
        data["cCAS_IPAddress"] = this.cCAS_IPAddress;
        data["cCAS_ApprovedBy"] = this.cCAS_ApprovedBy;
        data["iIsActive"] = this.iIsActive;
        data["iApprovalForm"] = this.iApprovalForm;
        data["iDropDuplicates"] = this.iDropDuplicates;
        data["cCustomText1"] = this.cCustomText1;
        data["cCustomText2"] = this.cCustomText2;
        data["cCustomText3"] = this.cCustomText3;
        data["cCustomText4"] = this.cCustomText4;
        data["cCustomText5"] = this.cCustomText5;
        data["cCustomText6"] = this.cCustomText6;
        data["cCustomText7"] = this.cCustomText7;
        data["cCustomText8"] = this.cCustomText8;
        data["cCustomText9"] = this.cCustomText9;
        data["cCustomText10"] = this.cCustomText10;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["iIsNCOARequired"] = this.iIsNCOARequired;
        data["iIsProfanityCheckRequired"] = this.iIsProfanityCheckRequired;
        data["guid"] = this.guid;
        data["dValidUpTill"] = this.dValidUpTill ? this.dValidUpTill.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditMasterLoLDto {
    databaseId: number | undefined;
    ownerID: number | undefined;
    managerID: number | undefined;
    listofContacts: CreateOrEditListCASContacts[] | undefined;
    listOfMailers: CreateOrEditListMailerDto[] | undefined;
    listofReqMailer: CreateOrEditListMailerRequestedDto[] | undefined;
    lK_PermissionType: string | undefined;
    lK_ListType: string | undefined;
    lK_ProductCode: string | undefined;
    lK_DecisionGroup: string | undefined;
    cCode: string | undefined;
    cDMIDWListNumber: string | undefined;
    cListName: string | undefined;
    cMINDatacardCode: string | undefined;
    cNextMarkID: string | undefined;
    iOrderContactID: number | undefined;
    iIsMultibuyer: boolean | undefined;
    cAppearDate: string | undefined;
    cLastUpdateDate: string | undefined;
    cRemoveDate: string | undefined;
    iSendCASApproval: boolean | undefined;
    dEmailSentDate: moment.Moment | undefined;
    nBasePrice_Postal: number | undefined;
    nBasePrice_Telemarketing: number | undefined;
    nNewBasePrice_Postal: number | undefined;
    nNewBasePrice_Telemarketing: number | undefined;
    cCAS_Signature: string | undefined;
    cCAS_IPAddress: string | undefined;
    cCAS_ApprovedBy: string | undefined;
    iIsActive: boolean | undefined;
    iApprovalForm: boolean | undefined;
    iDropDuplicates: boolean | undefined;
    cCustomText1: string | undefined;
    cCustomText2: string | undefined;
    cCustomText3: string | undefined;
    cCustomText4: string | undefined;
    cCustomText5: string | undefined;
    cCustomText6: string | undefined;
    cCustomText7: string | undefined;
    cCustomText8: string | undefined;
    cCustomText9: string | undefined;
    cCustomText10: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    iIsNCOARequired: boolean | undefined;
    iIsProfanityCheckRequired: boolean | undefined;
    guid: string | undefined;
    dValidUpTill: moment.Moment | undefined;
    id: number | undefined;
}

export class CreateOrEditListCASContacts implements ICreateOrEditListCASContacts {
    contactID!: number | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    listID!: number | undefined;
    action!: ActionType | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditListCASContacts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactID = data["contactID"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.listID = data["listID"];
            this.action = data["action"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditListCASContacts {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditListCASContacts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactID"] = this.contactID;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["listID"] = this.listID;
        data["action"] = this.action;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditListCASContacts {
    contactID: number | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    listID: number | undefined;
    action: ActionType | undefined;
    id: number | undefined;
}

export class CreateOrEditListMailerDto implements ICreateOrEditListMailerDto {
    mailerID!: number | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    listID!: number | undefined;
    action!: ActionType | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditListMailerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mailerID = data["mailerID"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.listID = data["listID"];
            this.action = data["action"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditListMailerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditListMailerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mailerID"] = this.mailerID;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["listID"] = this.listID;
        data["action"] = this.action;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditListMailerDto {
    mailerID: number | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    listID: number | undefined;
    action: ActionType | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfCreateOrEditListMailerDto implements IPagedResultDtoOfCreateOrEditListMailerDto {
    totalCount!: number | undefined;
    items!: CreateOrEditListMailerDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCreateOrEditListMailerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CreateOrEditListMailerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCreateOrEditListMailerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCreateOrEditListMailerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCreateOrEditListMailerDto {
    totalCount: number | undefined;
    items: CreateOrEditListMailerDto[] | undefined;
}

export class PagedResultDtoOfCreateOrEditListCASContacts implements IPagedResultDtoOfCreateOrEditListCASContacts {
    totalCount!: number | undefined;
    items!: CreateOrEditListCASContacts[] | undefined;

    constructor(data?: IPagedResultDtoOfCreateOrEditListCASContacts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CreateOrEditListCASContacts.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCreateOrEditListCASContacts {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCreateOrEditListCASContacts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCreateOrEditListCASContacts {
    totalCount: number | undefined;
    items: CreateOrEditListCASContacts[] | undefined;
}

export class PagedResultDtoOfCreateOrEditListMailerRequestedDto implements IPagedResultDtoOfCreateOrEditListMailerRequestedDto {
    totalCount!: number | undefined;
    items!: CreateOrEditListMailerRequestedDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCreateOrEditListMailerRequestedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CreateOrEditListMailerRequestedDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCreateOrEditListMailerRequestedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCreateOrEditListMailerRequestedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCreateOrEditListMailerRequestedDto {
    totalCount: number | undefined;
    items: CreateOrEditListMailerRequestedDto[] | undefined;
}

export class ExportToExcelMasterLolDto implements IExportToExcelMasterLolDto {
    id!: number | undefined;
    listId!: number | undefined;
    cListName!: string | undefined;
    managerName!: string | undefined;
    decisionGroup!: string | undefined;
    listOwner!: string | undefined;
    listType!: string | undefined;
    lK_PermissionType!: string | undefined;
    productCode!: string | undefined;
    cCode!: string | undefined;
    cMINDatacardCode!: string | undefined;
    cNextMarkID!: string | undefined;
    nBasePrice_Postal!: number | undefined;
    nBasePrice_Telemarketing!: number | undefined;
    cAppearDate!: string | undefined;
    cLastUpdateDate!: string | undefined;
    cRemoveDate!: string | undefined;
    sendOrderTo!: string | undefined;
    dD!: string | undefined;
    sendDwap!: string | undefined;
    active!: string | undefined;
    multiBuyer!: string | undefined;
    typeOfList!: string | undefined;
    cCustomText1!: string | undefined;
    cCustomText2!: string | undefined;
    cCustomText3!: string | undefined;
    cCustomText4!: string | undefined;
    cCustomText5!: string | undefined;
    cCustomText6!: string | undefined;
    cCustomText7!: string | undefined;
    cCustomText8!: string | undefined;
    cCustomText9!: string | undefined;
    cCustomText10!: string | undefined;
    lK_ListType!: string | undefined;
    lK_ProductCode!: string | undefined;
    lK_DecisionGroup!: string | undefined;
    company!: string | undefined;
    ownerID!: number | undefined;
    dwapContacts!: string[] | undefined;
    reqMailer!: string[] | undefined;
    availableMailer!: string[] | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IExportToExcelMasterLolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.listId = data["listId"];
            this.cListName = data["cListName"];
            this.managerName = data["managerName"];
            this.decisionGroup = data["decisionGroup"];
            this.listOwner = data["listOwner"];
            this.listType = data["listType"];
            this.lK_PermissionType = data["lK_PermissionType"];
            this.productCode = data["productCode"];
            this.cCode = data["cCode"];
            this.cMINDatacardCode = data["cMINDatacardCode"];
            this.cNextMarkID = data["cNextMarkID"];
            this.nBasePrice_Postal = data["nBasePrice_Postal"];
            this.nBasePrice_Telemarketing = data["nBasePrice_Telemarketing"];
            this.cAppearDate = data["cAppearDate"];
            this.cLastUpdateDate = data["cLastUpdateDate"];
            this.cRemoveDate = data["cRemoveDate"];
            this.sendOrderTo = data["sendOrderTo"];
            this.dD = data["dD"];
            this.sendDwap = data["sendDwap"];
            this.active = data["active"];
            this.multiBuyer = data["multiBuyer"];
            this.typeOfList = data["typeOfList"];
            this.cCustomText1 = data["cCustomText1"];
            this.cCustomText2 = data["cCustomText2"];
            this.cCustomText3 = data["cCustomText3"];
            this.cCustomText4 = data["cCustomText4"];
            this.cCustomText5 = data["cCustomText5"];
            this.cCustomText6 = data["cCustomText6"];
            this.cCustomText7 = data["cCustomText7"];
            this.cCustomText8 = data["cCustomText8"];
            this.cCustomText9 = data["cCustomText9"];
            this.cCustomText10 = data["cCustomText10"];
            this.lK_ListType = data["lK_ListType"];
            this.lK_ProductCode = data["lK_ProductCode"];
            this.lK_DecisionGroup = data["lK_DecisionGroup"];
            this.company = data["company"];
            this.ownerID = data["ownerID"];
            if (Array.isArray(data["dwapContacts"])) {
                this.dwapContacts = [] as any;
                for (let item of data["dwapContacts"])
                    this.dwapContacts!.push(item);
            }
            if (Array.isArray(data["reqMailer"])) {
                this.reqMailer = [] as any;
                for (let item of data["reqMailer"])
                    this.reqMailer!.push(item);
            }
            if (Array.isArray(data["availableMailer"])) {
                this.availableMailer = [] as any;
                for (let item of data["availableMailer"])
                    this.availableMailer!.push(item);
            }
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): ExportToExcelMasterLolDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportToExcelMasterLolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["cListName"] = this.cListName;
        data["managerName"] = this.managerName;
        data["decisionGroup"] = this.decisionGroup;
        data["listOwner"] = this.listOwner;
        data["listType"] = this.listType;
        data["lK_PermissionType"] = this.lK_PermissionType;
        data["productCode"] = this.productCode;
        data["cCode"] = this.cCode;
        data["cMINDatacardCode"] = this.cMINDatacardCode;
        data["cNextMarkID"] = this.cNextMarkID;
        data["nBasePrice_Postal"] = this.nBasePrice_Postal;
        data["nBasePrice_Telemarketing"] = this.nBasePrice_Telemarketing;
        data["cAppearDate"] = this.cAppearDate;
        data["cLastUpdateDate"] = this.cLastUpdateDate;
        data["cRemoveDate"] = this.cRemoveDate;
        data["sendOrderTo"] = this.sendOrderTo;
        data["dD"] = this.dD;
        data["sendDwap"] = this.sendDwap;
        data["active"] = this.active;
        data["multiBuyer"] = this.multiBuyer;
        data["typeOfList"] = this.typeOfList;
        data["cCustomText1"] = this.cCustomText1;
        data["cCustomText2"] = this.cCustomText2;
        data["cCustomText3"] = this.cCustomText3;
        data["cCustomText4"] = this.cCustomText4;
        data["cCustomText5"] = this.cCustomText5;
        data["cCustomText6"] = this.cCustomText6;
        data["cCustomText7"] = this.cCustomText7;
        data["cCustomText8"] = this.cCustomText8;
        data["cCustomText9"] = this.cCustomText9;
        data["cCustomText10"] = this.cCustomText10;
        data["lK_ListType"] = this.lK_ListType;
        data["lK_ProductCode"] = this.lK_ProductCode;
        data["lK_DecisionGroup"] = this.lK_DecisionGroup;
        data["company"] = this.company;
        data["ownerID"] = this.ownerID;
        if (Array.isArray(this.dwapContacts)) {
            data["dwapContacts"] = [];
            for (let item of this.dwapContacts)
                data["dwapContacts"].push(item);
        }
        if (Array.isArray(this.reqMailer)) {
            data["reqMailer"] = [];
            for (let item of this.reqMailer)
                data["reqMailer"].push(item);
        }
        if (Array.isArray(this.availableMailer)) {
            data["availableMailer"] = [];
            for (let item of this.availableMailer)
                data["availableMailer"].push(item);
        }
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IExportToExcelMasterLolDto {
    id: number | undefined;
    listId: number | undefined;
    cListName: string | undefined;
    managerName: string | undefined;
    decisionGroup: string | undefined;
    listOwner: string | undefined;
    listType: string | undefined;
    lK_PermissionType: string | undefined;
    productCode: string | undefined;
    cCode: string | undefined;
    cMINDatacardCode: string | undefined;
    cNextMarkID: string | undefined;
    nBasePrice_Postal: number | undefined;
    nBasePrice_Telemarketing: number | undefined;
    cAppearDate: string | undefined;
    cLastUpdateDate: string | undefined;
    cRemoveDate: string | undefined;
    sendOrderTo: string | undefined;
    dD: string | undefined;
    sendDwap: string | undefined;
    active: string | undefined;
    multiBuyer: string | undefined;
    typeOfList: string | undefined;
    cCustomText1: string | undefined;
    cCustomText2: string | undefined;
    cCustomText3: string | undefined;
    cCustomText4: string | undefined;
    cCustomText5: string | undefined;
    cCustomText6: string | undefined;
    cCustomText7: string | undefined;
    cCustomText8: string | undefined;
    cCustomText9: string | undefined;
    cCustomText10: string | undefined;
    lK_ListType: string | undefined;
    lK_ProductCode: string | undefined;
    lK_DecisionGroup: string | undefined;
    company: string | undefined;
    ownerID: number | undefined;
    dwapContacts: string[] | undefined;
    reqMailer: string[] | undefined;
    availableMailer: string[] | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class ExportListMailerAccess implements IExportListMailerAccess {
    listId!: number | undefined;
    code!: string | undefined;
    listName!: string | undefined;
    type!: string | undefined;
    company!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IExportListMailerAccess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.listId = data["listId"];
            this.code = data["code"];
            this.listName = data["listName"];
            this.type = data["type"];
            this.company = data["company"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): ExportListMailerAccess {
        data = typeof data === 'object' ? data : {};
        let result = new ExportListMailerAccess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["code"] = this.code;
        data["listName"] = this.listName;
        data["type"] = this.type;
        data["company"] = this.company;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IExportListMailerAccess {
    listId: number | undefined;
    code: string | undefined;
    listName: string | undefined;
    type: string | undefined;
    company: string | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class GetAllForTableInput implements IGetAllForTableInput {
    filter!: string | undefined;
    selectedDatabase!: number | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IGetAllForTableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.selectedDatabase = data["selectedDatabase"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAllForTableInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllForTableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["selectedDatabase"] = this.selectedDatabase;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IGetAllForTableInput {
    filter: string | undefined;
    selectedDatabase: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class PagedResultDtoOfGetMatchAppendDatabaseUserForViewDto implements IPagedResultDtoOfGetMatchAppendDatabaseUserForViewDto {
    totalCount!: number | undefined;
    items!: GetMatchAppendDatabaseUserForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMatchAppendDatabaseUserForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetMatchAppendDatabaseUserForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMatchAppendDatabaseUserForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMatchAppendDatabaseUserForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetMatchAppendDatabaseUserForViewDto {
    totalCount: number | undefined;
    items: GetMatchAppendDatabaseUserForViewDto[] | undefined;
}

export class GetMatchAppendDatabaseUserForViewDto implements IGetMatchAppendDatabaseUserForViewDto {
    matchAppendDatabaseUser!: MatchAppendDatabaseUserDto | undefined;

    constructor(data?: IGetMatchAppendDatabaseUserForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendDatabaseUser = data["matchAppendDatabaseUser"] ? MatchAppendDatabaseUserDto.fromJS(data["matchAppendDatabaseUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMatchAppendDatabaseUserForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMatchAppendDatabaseUserForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendDatabaseUser"] = this.matchAppendDatabaseUser ? this.matchAppendDatabaseUser.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetMatchAppendDatabaseUserForViewDto {
    matchAppendDatabaseUser: MatchAppendDatabaseUserDto | undefined;
}

export class MatchAppendDatabaseUserDto implements IMatchAppendDatabaseUserDto {
    userID!: number | undefined;
    databaseID!: number | undefined;
    cCreatedBy!: string | undefined;
    cCreatedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IMatchAppendDatabaseUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userID = data["userID"];
            this.databaseID = data["databaseID"];
            this.cCreatedBy = data["cCreatedBy"];
            this.cCreatedDate = data["cCreatedDate"] ? moment(data["cCreatedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MatchAppendDatabaseUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchAppendDatabaseUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userID"] = this.userID;
        data["databaseID"] = this.databaseID;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cCreatedDate"] = this.cCreatedDate ? this.cCreatedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMatchAppendDatabaseUserDto {
    userID: number | undefined;
    databaseID: number | undefined;
    cCreatedBy: string | undefined;
    cCreatedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    id: number | undefined;
}

export class GetMatchAppendDatabaseUserForEditOutput implements IGetMatchAppendDatabaseUserForEditOutput {
    matchAppendDatabaseUser!: CreateOrEditMatchAppendDatabaseUserDto | undefined;

    constructor(data?: IGetMatchAppendDatabaseUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendDatabaseUser = data["matchAppendDatabaseUser"] ? CreateOrEditMatchAppendDatabaseUserDto.fromJS(data["matchAppendDatabaseUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMatchAppendDatabaseUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMatchAppendDatabaseUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendDatabaseUser"] = this.matchAppendDatabaseUser ? this.matchAppendDatabaseUser.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetMatchAppendDatabaseUserForEditOutput {
    matchAppendDatabaseUser: CreateOrEditMatchAppendDatabaseUserDto | undefined;
}

export class CreateOrEditMatchAppendDatabaseUserDto implements ICreateOrEditMatchAppendDatabaseUserDto {
    userID!: number | undefined;
    databaseID!: number | undefined;
    cCreatedDate!: string | undefined;
    cCreatedBy!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMatchAppendDatabaseUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userID = data["userID"];
            this.databaseID = data["databaseID"];
            this.cCreatedDate = data["cCreatedDate"];
            this.cCreatedBy = data["cCreatedBy"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMatchAppendDatabaseUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMatchAppendDatabaseUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userID"] = this.userID;
        data["databaseID"] = this.databaseID;
        data["cCreatedDate"] = this.cCreatedDate;
        data["cCreatedBy"] = this.cCreatedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditMatchAppendDatabaseUserDto {
    userID: number | undefined;
    databaseID: number | undefined;
    cCreatedDate: string | undefined;
    cCreatedBy: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetMatchAppendInputLayoutForViewDto implements IPagedResultDtoOfGetMatchAppendInputLayoutForViewDto {
    totalCount!: number | undefined;
    items!: GetMatchAppendInputLayoutForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMatchAppendInputLayoutForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetMatchAppendInputLayoutForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMatchAppendInputLayoutForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMatchAppendInputLayoutForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetMatchAppendInputLayoutForViewDto {
    totalCount: number | undefined;
    items: GetMatchAppendInputLayoutForViewDto[] | undefined;
}

export class GetMatchAppendInputLayoutForViewDto implements IGetMatchAppendInputLayoutForViewDto {
    matchAppendInputLayout!: MatchAppendInputLayoutDto | undefined;
    matchAppendcClientName!: string | undefined;

    constructor(data?: IGetMatchAppendInputLayoutForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendInputLayout = data["matchAppendInputLayout"] ? MatchAppendInputLayoutDto.fromJS(data["matchAppendInputLayout"]) : <any>undefined;
            this.matchAppendcClientName = data["matchAppendcClientName"];
        }
    }

    static fromJS(data: any): GetMatchAppendInputLayoutForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMatchAppendInputLayoutForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendInputLayout"] = this.matchAppendInputLayout ? this.matchAppendInputLayout.toJSON() : <any>undefined;
        data["matchAppendcClientName"] = this.matchAppendcClientName;
        return data; 
    }
}

export interface IGetMatchAppendInputLayoutForViewDto {
    matchAppendInputLayout: MatchAppendInputLayoutDto | undefined;
    matchAppendcClientName: string | undefined;
}

export class MatchAppendInputLayoutDto implements IMatchAppendInputLayoutDto {
    matchAppendId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IMatchAppendInputLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendId = data["matchAppendId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MatchAppendInputLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchAppendInputLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendId"] = this.matchAppendId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMatchAppendInputLayoutDto {
    matchAppendId: number | undefined;
    id: number | undefined;
}

export class GetMatchAppendInputLayoutForEditOutput implements IGetMatchAppendInputLayoutForEditOutput {
    matchAppendInputLayout!: CreateOrEditMatchAppendInputLayoutDto | undefined;
    matchAppendcClientName!: string | undefined;

    constructor(data?: IGetMatchAppendInputLayoutForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendInputLayout = data["matchAppendInputLayout"] ? CreateOrEditMatchAppendInputLayoutDto.fromJS(data["matchAppendInputLayout"]) : <any>undefined;
            this.matchAppendcClientName = data["matchAppendcClientName"];
        }
    }

    static fromJS(data: any): GetMatchAppendInputLayoutForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMatchAppendInputLayoutForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendInputLayout"] = this.matchAppendInputLayout ? this.matchAppendInputLayout.toJSON() : <any>undefined;
        data["matchAppendcClientName"] = this.matchAppendcClientName;
        return data; 
    }
}

export interface IGetMatchAppendInputLayoutForEditOutput {
    matchAppendInputLayout: CreateOrEditMatchAppendInputLayoutDto | undefined;
    matchAppendcClientName: string | undefined;
}

export class CreateOrEditMatchAppendInputLayoutDto implements ICreateOrEditMatchAppendInputLayoutDto {
    matchAppendId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMatchAppendInputLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendId = data["matchAppendId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMatchAppendInputLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMatchAppendInputLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendId"] = this.matchAppendId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditMatchAppendInputLayoutDto {
    matchAppendId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfMatchAppendInputLayoutMatchAppendLookupTableDto implements IPagedResultDtoOfMatchAppendInputLayoutMatchAppendLookupTableDto {
    totalCount!: number | undefined;
    items!: MatchAppendInputLayoutMatchAppendLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMatchAppendInputLayoutMatchAppendLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MatchAppendInputLayoutMatchAppendLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMatchAppendInputLayoutMatchAppendLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMatchAppendInputLayoutMatchAppendLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMatchAppendInputLayoutMatchAppendLookupTableDto {
    totalCount: number | undefined;
    items: MatchAppendInputLayoutMatchAppendLookupTableDto[] | undefined;
}

export class MatchAppendInputLayoutMatchAppendLookupTableDto implements IMatchAppendInputLayoutMatchAppendLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IMatchAppendInputLayoutMatchAppendLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): MatchAppendInputLayoutMatchAppendLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchAppendInputLayoutMatchAppendLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IMatchAppendInputLayoutMatchAppendLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetMatchAppendOutputLayoutForViewDto implements IPagedResultDtoOfGetMatchAppendOutputLayoutForViewDto {
    totalCount!: number | undefined;
    items!: GetMatchAppendOutputLayoutForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMatchAppendOutputLayoutForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetMatchAppendOutputLayoutForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMatchAppendOutputLayoutForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMatchAppendOutputLayoutForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetMatchAppendOutputLayoutForViewDto {
    totalCount: number | undefined;
    items: GetMatchAppendOutputLayoutForViewDto[] | undefined;
}

export class GetMatchAppendOutputLayoutForViewDto implements IGetMatchAppendOutputLayoutForViewDto {
    matchAppendOutputLayout!: MatchAppendOutputLayoutDto | undefined;

    constructor(data?: IGetMatchAppendOutputLayoutForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendOutputLayout = data["matchAppendOutputLayout"] ? MatchAppendOutputLayoutDto.fromJS(data["matchAppendOutputLayout"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMatchAppendOutputLayoutForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMatchAppendOutputLayoutForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendOutputLayout"] = this.matchAppendOutputLayout ? this.matchAppendOutputLayout.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetMatchAppendOutputLayoutForViewDto {
    matchAppendOutputLayout: MatchAppendOutputLayoutDto | undefined;
}

export class MatchAppendOutputLayoutDto implements IMatchAppendOutputLayoutDto {
    id!: number | undefined;

    constructor(data?: IMatchAppendOutputLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MatchAppendOutputLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchAppendOutputLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IMatchAppendOutputLayoutDto {
    id: number | undefined;
}

export class GetMatchAppendOutputLayoutForEditOutput implements IGetMatchAppendOutputLayoutForEditOutput {
    matchAppendOutputLayout!: CreateOrEditMatchAppendOutputLayoutDto | undefined;

    constructor(data?: IGetMatchAppendOutputLayoutForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendOutputLayout = data["matchAppendOutputLayout"] ? CreateOrEditMatchAppendOutputLayoutDto.fromJS(data["matchAppendOutputLayout"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMatchAppendOutputLayoutForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMatchAppendOutputLayoutForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendOutputLayout"] = this.matchAppendOutputLayout ? this.matchAppendOutputLayout.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetMatchAppendOutputLayoutForEditOutput {
    matchAppendOutputLayout: CreateOrEditMatchAppendOutputLayoutDto | undefined;
}

export class CreateOrEditMatchAppendOutputLayoutDto implements ICreateOrEditMatchAppendOutputLayoutDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditMatchAppendOutputLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMatchAppendOutputLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMatchAppendOutputLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditMatchAppendOutputLayoutDto {
    id: number | undefined;
}

export class PagedResultDtoOfGetMatchAppendForViewDto implements IPagedResultDtoOfGetMatchAppendForViewDto {
    totalCount!: number | undefined;
    items!: GetMatchAppendForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMatchAppendForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetMatchAppendForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMatchAppendForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMatchAppendForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetMatchAppendForViewDto {
    totalCount: number | undefined;
    items: GetMatchAppendForViewDto[] | undefined;
}

export class GetMatchAppendForViewDto implements IGetMatchAppendForViewDto {
    databaseID!: number | undefined;
    databaseName!: string | undefined;
    buildDescription!: string | undefined;
    status!: string | undefined;
    buildID!: number | undefined;
    statusDate!: string | undefined;
    cClientName!: string | undefined;
    cRequestReason!: string | undefined;
    statusId!: number | undefined;
    idmsMatchFieldName!: string | undefined;
    cClientFileName!: string | undefined;
    id!: number | undefined;

    constructor(data?: IGetMatchAppendForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseID = data["databaseID"];
            this.databaseName = data["databaseName"];
            this.buildDescription = data["buildDescription"];
            this.status = data["status"];
            this.buildID = data["buildID"];
            this.statusDate = data["statusDate"];
            this.cClientName = data["cClientName"];
            this.cRequestReason = data["cRequestReason"];
            this.statusId = data["statusId"];
            this.idmsMatchFieldName = data["idmsMatchFieldName"];
            this.cClientFileName = data["cClientFileName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMatchAppendForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMatchAppendForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseID"] = this.databaseID;
        data["databaseName"] = this.databaseName;
        data["buildDescription"] = this.buildDescription;
        data["status"] = this.status;
        data["buildID"] = this.buildID;
        data["statusDate"] = this.statusDate;
        data["cClientName"] = this.cClientName;
        data["cRequestReason"] = this.cRequestReason;
        data["statusId"] = this.statusId;
        data["idmsMatchFieldName"] = this.idmsMatchFieldName;
        data["cClientFileName"] = this.cClientFileName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetMatchAppendForViewDto {
    databaseID: number | undefined;
    databaseName: string | undefined;
    buildDescription: string | undefined;
    status: string | undefined;
    buildID: number | undefined;
    statusDate: string | undefined;
    cClientName: string | undefined;
    cRequestReason: string | undefined;
    statusId: number | undefined;
    idmsMatchFieldName: string | undefined;
    cClientFileName: string | undefined;
    id: number | undefined;
}

export class MatchAndAppendStatusDto implements IMatchAndAppendStatusDto {
    id!: number | undefined;
    statusDescription!: string | undefined;
    dCreatedDate!: string | undefined;
    cCreatedBy!: string | undefined;

    constructor(data?: IMatchAndAppendStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.statusDescription = data["statusDescription"];
            this.dCreatedDate = data["dCreatedDate"];
            this.cCreatedBy = data["cCreatedBy"];
        }
    }

    static fromJS(data: any): MatchAndAppendStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchAndAppendStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["statusDescription"] = this.statusDescription;
        data["dCreatedDate"] = this.dCreatedDate;
        data["cCreatedBy"] = this.cCreatedBy;
        return data; 
    }
}

export interface IMatchAndAppendStatusDto {
    id: number | undefined;
    statusDescription: string | undefined;
    dCreatedDate: string | undefined;
    cCreatedBy: string | undefined;
}

export class MatchAppendDto implements IMatchAppendDto {
    databaseID!: number | undefined;
    buildID!: number | undefined;
    uploadFilePath!: string | undefined;
    lK_FileType!: string | undefined;
    lK_ExportFileFormatID!: string | undefined;
    cOrderType!: string | undefined;
    cKeyCode!: string | undefined;
    iSkipFirstRow!: boolean | undefined;
    cClientName!: string | undefined;
    cRequestReason!: string | undefined;
    cSourceFilter!: string | undefined;
    cInputFilter!: string | undefined;
    cIDMSMatchFieldName!: string | undefined;
    cInputMatchFieldName!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    cClientFileName!: string | undefined;
    iExportType!: number | undefined;
    cBuildDescription!: string | undefined;
    id!: number | undefined;

    constructor(data?: IMatchAppendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseID = data["databaseID"];
            this.buildID = data["buildID"];
            this.uploadFilePath = data["uploadFilePath"];
            this.lK_FileType = data["lK_FileType"];
            this.lK_ExportFileFormatID = data["lK_ExportFileFormatID"];
            this.cOrderType = data["cOrderType"];
            this.cKeyCode = data["cKeyCode"];
            this.iSkipFirstRow = data["iSkipFirstRow"];
            this.cClientName = data["cClientName"];
            this.cRequestReason = data["cRequestReason"];
            this.cSourceFilter = data["cSourceFilter"];
            this.cInputFilter = data["cInputFilter"];
            this.cIDMSMatchFieldName = data["cIDMSMatchFieldName"];
            this.cInputMatchFieldName = data["cInputMatchFieldName"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.cClientFileName = data["cClientFileName"];
            this.iExportType = data["iExportType"];
            this.cBuildDescription = data["cBuildDescription"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MatchAppendDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchAppendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseID"] = this.databaseID;
        data["buildID"] = this.buildID;
        data["uploadFilePath"] = this.uploadFilePath;
        data["lK_FileType"] = this.lK_FileType;
        data["lK_ExportFileFormatID"] = this.lK_ExportFileFormatID;
        data["cOrderType"] = this.cOrderType;
        data["cKeyCode"] = this.cKeyCode;
        data["iSkipFirstRow"] = this.iSkipFirstRow;
        data["cClientName"] = this.cClientName;
        data["cRequestReason"] = this.cRequestReason;
        data["cSourceFilter"] = this.cSourceFilter;
        data["cInputFilter"] = this.cInputFilter;
        data["cIDMSMatchFieldName"] = this.cIDMSMatchFieldName;
        data["cInputMatchFieldName"] = this.cInputMatchFieldName;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["cClientFileName"] = this.cClientFileName;
        data["iExportType"] = this.iExportType;
        data["cBuildDescription"] = this.cBuildDescription;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMatchAppendDto {
    databaseID: number | undefined;
    buildID: number | undefined;
    uploadFilePath: string | undefined;
    lK_FileType: string | undefined;
    lK_ExportFileFormatID: string | undefined;
    cOrderType: string | undefined;
    cKeyCode: string | undefined;
    iSkipFirstRow: boolean | undefined;
    cClientName: string | undefined;
    cRequestReason: string | undefined;
    cSourceFilter: string | undefined;
    cInputFilter: string | undefined;
    cIDMSMatchFieldName: string | undefined;
    cInputMatchFieldName: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    cClientFileName: string | undefined;
    iExportType: number | undefined;
    cBuildDescription: string | undefined;
    id: number | undefined;
}

export class MatchAndAppendInputLayoutDto implements IMatchAndAppendInputLayoutDto {
    matchAppendId!: number | undefined;
    cFieldName!: string | undefined;
    iStartIndex!: number | undefined;
    iEndIndex!: number | undefined;
    iDataLength!: number | undefined;
    iImportLayoutOrder!: number | undefined;
    startIndex!: string | undefined;
    endIndex!: string | undefined;
    dataLength!: string | undefined;
    importLayoutOrder!: string | undefined;
    mappingDescription!: string | undefined;
    cMCMapping!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    actionType!: ActionType | undefined;
    id!: number | undefined;

    constructor(data?: IMatchAndAppendInputLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendId = data["matchAppendId"];
            this.cFieldName = data["cFieldName"];
            this.iStartIndex = data["iStartIndex"];
            this.iEndIndex = data["iEndIndex"];
            this.iDataLength = data["iDataLength"];
            this.iImportLayoutOrder = data["iImportLayoutOrder"];
            this.startIndex = data["startIndex"];
            this.endIndex = data["endIndex"];
            this.dataLength = data["dataLength"];
            this.importLayoutOrder = data["importLayoutOrder"];
            this.mappingDescription = data["mappingDescription"];
            this.cMCMapping = data["cMCMapping"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.actionType = data["actionType"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MatchAndAppendInputLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchAndAppendInputLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendId"] = this.matchAppendId;
        data["cFieldName"] = this.cFieldName;
        data["iStartIndex"] = this.iStartIndex;
        data["iEndIndex"] = this.iEndIndex;
        data["iDataLength"] = this.iDataLength;
        data["iImportLayoutOrder"] = this.iImportLayoutOrder;
        data["startIndex"] = this.startIndex;
        data["endIndex"] = this.endIndex;
        data["dataLength"] = this.dataLength;
        data["importLayoutOrder"] = this.importLayoutOrder;
        data["mappingDescription"] = this.mappingDescription;
        data["cMCMapping"] = this.cMCMapping;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["actionType"] = this.actionType;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMatchAndAppendInputLayoutDto {
    matchAppendId: number | undefined;
    cFieldName: string | undefined;
    iStartIndex: number | undefined;
    iEndIndex: number | undefined;
    iDataLength: number | undefined;
    iImportLayoutOrder: number | undefined;
    startIndex: string | undefined;
    endIndex: string | undefined;
    dataLength: string | undefined;
    importLayoutOrder: string | undefined;
    mappingDescription: string | undefined;
    cMCMapping: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    actionType: ActionType | undefined;
    id: number | undefined;
}

export class CreateOrEditMatchAppendDto implements ICreateOrEditMatchAppendDto {
    matchAppendDto!: MatchAppendDto | undefined;
    matchAppendInputLayout!: MatchAndAppendInputLayoutDto | undefined;
    matchAppendOutputLayout!: MatchAndAppendOutputLayoutDto | undefined;
    selectedFields!: string[] | undefined;
    selectedTable!: string | undefined;
    matchAppendInputLayoutList!: MatchAndAppendInputLayoutDto[] | undefined;
    matchAppendOutputLayoutList!: MatchAndAppendOutputLayoutDto[] | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMatchAppendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendDto = data["matchAppendDto"] ? MatchAppendDto.fromJS(data["matchAppendDto"]) : <any>undefined;
            this.matchAppendInputLayout = data["matchAppendInputLayout"] ? MatchAndAppendInputLayoutDto.fromJS(data["matchAppendInputLayout"]) : <any>undefined;
            this.matchAppendOutputLayout = data["matchAppendOutputLayout"] ? MatchAndAppendOutputLayoutDto.fromJS(data["matchAppendOutputLayout"]) : <any>undefined;
            if (Array.isArray(data["selectedFields"])) {
                this.selectedFields = [] as any;
                for (let item of data["selectedFields"])
                    this.selectedFields!.push(item);
            }
            this.selectedTable = data["selectedTable"];
            if (Array.isArray(data["matchAppendInputLayoutList"])) {
                this.matchAppendInputLayoutList = [] as any;
                for (let item of data["matchAppendInputLayoutList"])
                    this.matchAppendInputLayoutList!.push(MatchAndAppendInputLayoutDto.fromJS(item));
            }
            if (Array.isArray(data["matchAppendOutputLayoutList"])) {
                this.matchAppendOutputLayoutList = [] as any;
                for (let item of data["matchAppendOutputLayoutList"])
                    this.matchAppendOutputLayoutList!.push(MatchAndAppendOutputLayoutDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMatchAppendDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMatchAppendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendDto"] = this.matchAppendDto ? this.matchAppendDto.toJSON() : <any>undefined;
        data["matchAppendInputLayout"] = this.matchAppendInputLayout ? this.matchAppendInputLayout.toJSON() : <any>undefined;
        data["matchAppendOutputLayout"] = this.matchAppendOutputLayout ? this.matchAppendOutputLayout.toJSON() : <any>undefined;
        if (Array.isArray(this.selectedFields)) {
            data["selectedFields"] = [];
            for (let item of this.selectedFields)
                data["selectedFields"].push(item);
        }
        data["selectedTable"] = this.selectedTable;
        if (Array.isArray(this.matchAppendInputLayoutList)) {
            data["matchAppendInputLayoutList"] = [];
            for (let item of this.matchAppendInputLayoutList)
                data["matchAppendInputLayoutList"].push(item.toJSON());
        }
        if (Array.isArray(this.matchAppendOutputLayoutList)) {
            data["matchAppendOutputLayoutList"] = [];
            for (let item of this.matchAppendOutputLayoutList)
                data["matchAppendOutputLayoutList"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditMatchAppendDto {
    matchAppendDto: MatchAppendDto | undefined;
    matchAppendInputLayout: MatchAndAppendInputLayoutDto | undefined;
    matchAppendOutputLayout: MatchAndAppendOutputLayoutDto | undefined;
    selectedFields: string[] | undefined;
    selectedTable: string | undefined;
    matchAppendInputLayoutList: MatchAndAppendInputLayoutDto[] | undefined;
    matchAppendOutputLayoutList: MatchAndAppendOutputLayoutDto[] | undefined;
    id: number | undefined;
}

export class MatchAndAppendOutputLayoutDto implements IMatchAndAppendOutputLayoutDto {
    matchAppendID!: number | undefined;
    cTableName!: string | undefined;
    cFieldName!: string | undefined;
    iOutputLength!: number | undefined;
    outputLength!: string | undefined;
    cOutputFieldName!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    actionType!: ActionType | undefined;
    cModifiedBy!: string | undefined;
    iOutputLayoutOrder!: number | undefined;
    outputLayoutOrder!: string | undefined;
    id!: number | undefined;

    constructor(data?: IMatchAndAppendOutputLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendID = data["matchAppendID"];
            this.cTableName = data["cTableName"];
            this.cFieldName = data["cFieldName"];
            this.iOutputLength = data["iOutputLength"];
            this.outputLength = data["outputLength"];
            this.cOutputFieldName = data["cOutputFieldName"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.actionType = data["actionType"];
            this.cModifiedBy = data["cModifiedBy"];
            this.iOutputLayoutOrder = data["iOutputLayoutOrder"];
            this.outputLayoutOrder = data["outputLayoutOrder"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MatchAndAppendOutputLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchAndAppendOutputLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendID"] = this.matchAppendID;
        data["cTableName"] = this.cTableName;
        data["cFieldName"] = this.cFieldName;
        data["iOutputLength"] = this.iOutputLength;
        data["outputLength"] = this.outputLength;
        data["cOutputFieldName"] = this.cOutputFieldName;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["cModifiedBy"] = this.cModifiedBy;
        data["iOutputLayoutOrder"] = this.iOutputLayoutOrder;
        data["outputLayoutOrder"] = this.outputLayoutOrder;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMatchAndAppendOutputLayoutDto {
    matchAppendID: number | undefined;
    cTableName: string | undefined;
    cFieldName: string | undefined;
    iOutputLength: number | undefined;
    outputLength: string | undefined;
    cOutputFieldName: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    actionType: ActionType | undefined;
    cModifiedBy: string | undefined;
    iOutputLayoutOrder: number | undefined;
    outputLayoutOrder: string | undefined;
    id: number | undefined;
}

export class GetMatchAppendForEditOutput implements IGetMatchAppendForEditOutput {
    matchAppend!: CreateOrEditMatchAppendDto | undefined;

    constructor(data?: IGetMatchAppendForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppend = data["matchAppend"] ? CreateOrEditMatchAppendDto.fromJS(data["matchAppend"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMatchAppendForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMatchAppendForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppend"] = this.matchAppend ? this.matchAppend.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetMatchAppendForEditOutput {
    matchAppend: CreateOrEditMatchAppendDto | undefined;
}

export class PagedResultDtoOfGetMatchAppendStatusForViewDto implements IPagedResultDtoOfGetMatchAppendStatusForViewDto {
    totalCount!: number | undefined;
    items!: GetMatchAppendStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMatchAppendStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetMatchAppendStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMatchAppendStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMatchAppendStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetMatchAppendStatusForViewDto {
    totalCount: number | undefined;
    items: GetMatchAppendStatusForViewDto[] | undefined;
}

export class GetMatchAppendStatusForViewDto implements IGetMatchAppendStatusForViewDto {
    matchAppendStatus!: MatchAppendStatusDto | undefined;

    constructor(data?: IGetMatchAppendStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendStatus = data["matchAppendStatus"] ? MatchAppendStatusDto.fromJS(data["matchAppendStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMatchAppendStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMatchAppendStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendStatus"] = this.matchAppendStatus ? this.matchAppendStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetMatchAppendStatusForViewDto {
    matchAppendStatus: MatchAppendStatusDto | undefined;
}

export class MatchAppendStatusDto implements IMatchAppendStatusDto {
    matchAppendID!: number | undefined;
    iStatusID!: number | undefined;
    iIsCurrent!: boolean | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    id!: number | undefined;

    constructor(data?: IMatchAppendStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendID = data["matchAppendID"];
            this.iStatusID = data["iStatusID"];
            this.iIsCurrent = data["iIsCurrent"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MatchAppendStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchAppendStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendID"] = this.matchAppendID;
        data["iStatusID"] = this.iStatusID;
        data["iIsCurrent"] = this.iIsCurrent;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMatchAppendStatusDto {
    matchAppendID: number | undefined;
    iStatusID: number | undefined;
    iIsCurrent: boolean | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    id: number | undefined;
}

export class GetMatchAppendStatusForEditOutput implements IGetMatchAppendStatusForEditOutput {
    matchAppendStatus!: CreateOrEditMatchAppendStatusDto | undefined;

    constructor(data?: IGetMatchAppendStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchAppendStatus = data["matchAppendStatus"] ? CreateOrEditMatchAppendStatusDto.fromJS(data["matchAppendStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMatchAppendStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMatchAppendStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchAppendStatus"] = this.matchAppendStatus ? this.matchAppendStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetMatchAppendStatusForEditOutput {
    matchAppendStatus: CreateOrEditMatchAppendStatusDto | undefined;
}

export class CreateOrEditMatchAppendStatusDto implements ICreateOrEditMatchAppendStatusDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditMatchAppendStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMatchAppendStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMatchAppendStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditMatchAppendStatusDto {
    id: number | undefined;
}

export class PagedResultDtoOfGetModelDetailForViewDto implements IPagedResultDtoOfGetModelDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetModelDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetModelDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetModelDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetModelDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetModelDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetModelDetailForViewDto {
    totalCount: number | undefined;
    items: GetModelDetailForViewDto[] | undefined;
}

export class GetModelDetailForViewDto implements IGetModelDetailForViewDto {
    modelDetail!: ModelDetailDto | undefined;

    constructor(data?: IGetModelDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modelDetail = data["modelDetail"] ? ModelDetailDto.fromJS(data["modelDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetModelDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetModelDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelDetail"] = this.modelDetail ? this.modelDetail.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetModelDetailForViewDto {
    modelDetail: ModelDetailDto | undefined;
}

export class ModelDetailDto implements IModelDetailDto {
    modelID!: number | undefined;
    buildID!: number | undefined;
    cSQL_Score!: string | undefined;
    cSQL_Deciles!: string | undefined;
    cSQL_Preselect!: string | undefined;
    cSAS_ScoreFileName!: string | undefined;
    cSAS_ScoreRealFileName!: string | undefined;
    dSampleScoredDateLast!: moment.Moment | undefined;
    cSampleScoredByLast!: string | undefined;
    dFinalScoredDateLAst!: moment.Moment | undefined;
    cFinalScoredByLast!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    cCompleteSQL!: string | undefined;
    iDoNotGenerateModelSQL!: boolean | undefined;

    constructor(data?: IModelDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modelID = data["modelID"];
            this.buildID = data["buildID"];
            this.cSQL_Score = data["cSQL_Score"];
            this.cSQL_Deciles = data["cSQL_Deciles"];
            this.cSQL_Preselect = data["cSQL_Preselect"];
            this.cSAS_ScoreFileName = data["cSAS_ScoreFileName"];
            this.cSAS_ScoreRealFileName = data["cSAS_ScoreRealFileName"];
            this.dSampleScoredDateLast = data["dSampleScoredDateLast"] ? moment(data["dSampleScoredDateLast"].toString()) : <any>undefined;
            this.cSampleScoredByLast = data["cSampleScoredByLast"];
            this.dFinalScoredDateLAst = data["dFinalScoredDateLAst"] ? moment(data["dFinalScoredDateLAst"].toString()) : <any>undefined;
            this.cFinalScoredByLast = data["cFinalScoredByLast"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.cCompleteSQL = data["cCompleteSQL"];
            this.iDoNotGenerateModelSQL = data["iDoNotGenerateModelSQL"];
        }
    }

    static fromJS(data: any): ModelDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelID"] = this.modelID;
        data["buildID"] = this.buildID;
        data["cSQL_Score"] = this.cSQL_Score;
        data["cSQL_Deciles"] = this.cSQL_Deciles;
        data["cSQL_Preselect"] = this.cSQL_Preselect;
        data["cSAS_ScoreFileName"] = this.cSAS_ScoreFileName;
        data["cSAS_ScoreRealFileName"] = this.cSAS_ScoreRealFileName;
        data["dSampleScoredDateLast"] = this.dSampleScoredDateLast ? this.dSampleScoredDateLast.toISOString() : <any>undefined;
        data["cSampleScoredByLast"] = this.cSampleScoredByLast;
        data["dFinalScoredDateLAst"] = this.dFinalScoredDateLAst ? this.dFinalScoredDateLAst.toISOString() : <any>undefined;
        data["cFinalScoredByLast"] = this.cFinalScoredByLast;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["cCompleteSQL"] = this.cCompleteSQL;
        data["iDoNotGenerateModelSQL"] = this.iDoNotGenerateModelSQL;
        return data; 
    }
}

export interface IModelDetailDto {
    modelID: number | undefined;
    buildID: number | undefined;
    cSQL_Score: string | undefined;
    cSQL_Deciles: string | undefined;
    cSQL_Preselect: string | undefined;
    cSAS_ScoreFileName: string | undefined;
    cSAS_ScoreRealFileName: string | undefined;
    dSampleScoredDateLast: moment.Moment | undefined;
    cSampleScoredByLast: string | undefined;
    dFinalScoredDateLAst: moment.Moment | undefined;
    cFinalScoredByLast: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    cCompleteSQL: string | undefined;
    iDoNotGenerateModelSQL: boolean | undefined;
}

export class GetModelDetailForEditOutput implements IGetModelDetailForEditOutput {
    modelDetail!: CreateOrEditModelDetailDto | undefined;

    constructor(data?: IGetModelDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modelDetail = data["modelDetail"] ? CreateOrEditModelDetailDto.fromJS(data["modelDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetModelDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetModelDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelDetail"] = this.modelDetail ? this.modelDetail.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetModelDetailForEditOutput {
    modelDetail: CreateOrEditModelDetailDto | undefined;
}

export class CreateOrEditModelDetailDto implements ICreateOrEditModelDetailDto {
    cSQL_Score!: string | undefined;
    cSQL_Deciles!: string | undefined;
    cSQL_Preselect!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditModelDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cSQL_Score = data["cSQL_Score"];
            this.cSQL_Deciles = data["cSQL_Deciles"];
            this.cSQL_Preselect = data["cSQL_Preselect"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditModelDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditModelDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cSQL_Score"] = this.cSQL_Score;
        data["cSQL_Deciles"] = this.cSQL_Deciles;
        data["cSQL_Preselect"] = this.cSQL_Preselect;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditModelDetailDto {
    cSQL_Score: string | undefined;
    cSQL_Deciles: string | undefined;
    cSQL_Preselect: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetModelQueueForViewDto implements IPagedResultDtoOfGetModelQueueForViewDto {
    totalCount!: number | undefined;
    items!: GetModelQueueForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetModelQueueForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetModelQueueForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetModelQueueForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetModelQueueForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetModelQueueForViewDto {
    totalCount: number | undefined;
    items: GetModelQueueForViewDto[] | undefined;
}

export class GetModelQueueForViewDto implements IGetModelQueueForViewDto {
    modelQueue!: ModelQueueDto | undefined;

    constructor(data?: IGetModelQueueForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modelQueue = data["modelQueue"] ? ModelQueueDto.fromJS(data["modelQueue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetModelQueueForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetModelQueueForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelQueue"] = this.modelQueue ? this.modelQueue.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetModelQueueForViewDto {
    modelQueue: ModelQueueDto | undefined;
}

export class ModelQueueDto implements IModelQueueDto {
    id!: number | undefined;

    constructor(data?: IModelQueueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ModelQueueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelQueueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IModelQueueDto {
    id: number | undefined;
}

export class GetModelQueueForEditOutput implements IGetModelQueueForEditOutput {
    modelQueue!: CreateOrEditModelQueueDto | undefined;

    constructor(data?: IGetModelQueueForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modelQueue = data["modelQueue"] ? CreateOrEditModelQueueDto.fromJS(data["modelQueue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetModelQueueForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetModelQueueForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelQueue"] = this.modelQueue ? this.modelQueue.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetModelQueueForEditOutput {
    modelQueue: CreateOrEditModelQueueDto | undefined;
}

export class CreateOrEditModelQueueDto implements ICreateOrEditModelQueueDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditModelQueueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditModelQueueDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditModelQueueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditModelQueueDto {
    id: number | undefined;
}

export class PagedResultDtoOfModelScoringDto implements IPagedResultDtoOfModelScoringDto {
    totalCount!: number | undefined;
    items!: ModelScoringDto[] | undefined;

    constructor(data?: IPagedResultDtoOfModelScoringDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ModelScoringDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfModelScoringDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfModelScoringDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfModelScoringDto {
    totalCount: number | undefined;
    items: ModelScoringDto[] | undefined;
}

export class ModelScoringDto implements IModelScoringDto {
    modelId!: number | undefined;
    cModelNumber!: string | undefined;
    cModelName!: string | undefined;
    cDescription!: string | undefined;
    cDatabaseName!: string | undefined;
    cBuildDescription!: string | undefined;
    cLookupDescription!: string | undefined;
    cStatus!: number | undefined;
    dStatusDate!: string | undefined;
    iIsActive!: boolean | undefined;
    modelType!: string | undefined;
    giftWeight!: string | undefined;
    id!: number | undefined;

    constructor(data?: IModelScoringDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modelId = data["modelId"];
            this.cModelNumber = data["cModelNumber"];
            this.cModelName = data["cModelName"];
            this.cDescription = data["cDescription"];
            this.cDatabaseName = data["cDatabaseName"];
            this.cBuildDescription = data["cBuildDescription"];
            this.cLookupDescription = data["cLookupDescription"];
            this.cStatus = data["cStatus"];
            this.dStatusDate = data["dStatusDate"];
            this.iIsActive = data["iIsActive"];
            this.modelType = data["modelType"];
            this.giftWeight = data["giftWeight"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ModelScoringDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelScoringDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelId"] = this.modelId;
        data["cModelNumber"] = this.cModelNumber;
        data["cModelName"] = this.cModelName;
        data["cDescription"] = this.cDescription;
        data["cDatabaseName"] = this.cDatabaseName;
        data["cBuildDescription"] = this.cBuildDescription;
        data["cLookupDescription"] = this.cLookupDescription;
        data["cStatus"] = this.cStatus;
        data["dStatusDate"] = this.dStatusDate;
        data["iIsActive"] = this.iIsActive;
        data["modelType"] = this.modelType;
        data["giftWeight"] = this.giftWeight;
        data["id"] = this.id;
        return data; 
    }
}

export interface IModelScoringDto {
    modelId: number | undefined;
    cModelNumber: string | undefined;
    cModelName: string | undefined;
    cDescription: string | undefined;
    cDatabaseName: string | undefined;
    cBuildDescription: string | undefined;
    cLookupDescription: string | undefined;
    cStatus: number | undefined;
    dStatusDate: string | undefined;
    iIsActive: boolean | undefined;
    modelType: string | undefined;
    giftWeight: string | undefined;
    id: number | undefined;
}

export class GetModelTypeAndWeightDto implements IGetModelTypeAndWeightDto {
    modelType!: DropdownOutputDto[] | undefined;
    modelGiftWeight!: DropdownOutputDto[] | undefined;

    constructor(data?: IGetModelTypeAndWeightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["modelType"])) {
                this.modelType = [] as any;
                for (let item of data["modelType"])
                    this.modelType!.push(DropdownOutputDto.fromJS(item));
            }
            if (Array.isArray(data["modelGiftWeight"])) {
                this.modelGiftWeight = [] as any;
                for (let item of data["modelGiftWeight"])
                    this.modelGiftWeight!.push(DropdownOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetModelTypeAndWeightDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetModelTypeAndWeightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.modelType)) {
            data["modelType"] = [];
            for (let item of this.modelType)
                data["modelType"].push(item.toJSON());
        }
        if (Array.isArray(this.modelGiftWeight)) {
            data["modelGiftWeight"] = [];
            for (let item of this.modelGiftWeight)
                data["modelGiftWeight"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetModelTypeAndWeightDto {
    modelType: DropdownOutputDto[] | undefined;
    modelGiftWeight: DropdownOutputDto[] | undefined;
}

export class CreateOrEditModelDto implements ICreateOrEditModelDto {
    isCopyModel!: boolean | undefined;
    modelSummaryData!: ModelSummaryDto | undefined;
    modelDetailData!: ModelDetailDto | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isCopyModel = data["isCopyModel"];
            this.modelSummaryData = data["modelSummaryData"] ? ModelSummaryDto.fromJS(data["modelSummaryData"]) : <any>undefined;
            this.modelDetailData = data["modelDetailData"] ? ModelDetailDto.fromJS(data["modelDetailData"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isCopyModel"] = this.isCopyModel;
        data["modelSummaryData"] = this.modelSummaryData ? this.modelSummaryData.toJSON() : <any>undefined;
        data["modelDetailData"] = this.modelDetailData ? this.modelDetailData.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditModelDto {
    isCopyModel: boolean | undefined;
    modelSummaryData: ModelSummaryDto | undefined;
    modelDetailData: ModelDetailDto | undefined;
    id: number | undefined;
}

export class ModelSummaryDto implements IModelSummaryDto {
    databaseId!: number | undefined;
    cModelName!: string | undefined;
    iIntercept!: number | undefined;
    cDescription!: string | undefined;
    cModelNumber!: string | undefined;
    cClientName!: string | undefined;
    iIsScoredForEveryBuild!: boolean | undefined;
    nChildTableNumber!: number | undefined;
    iIsActive!: boolean | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    lK_ModelType!: string | undefined;
    lK_GiftWeight!: string | undefined;

    constructor(data?: IModelSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseId = data["databaseId"];
            this.cModelName = data["cModelName"];
            this.iIntercept = data["iIntercept"];
            this.cDescription = data["cDescription"];
            this.cModelNumber = data["cModelNumber"];
            this.cClientName = data["cClientName"];
            this.iIsScoredForEveryBuild = data["iIsScoredForEveryBuild"];
            this.nChildTableNumber = data["nChildTableNumber"];
            this.iIsActive = data["iIsActive"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.lK_ModelType = data["lK_ModelType"];
            this.lK_GiftWeight = data["lK_GiftWeight"];
        }
    }

    static fromJS(data: any): ModelSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseId"] = this.databaseId;
        data["cModelName"] = this.cModelName;
        data["iIntercept"] = this.iIntercept;
        data["cDescription"] = this.cDescription;
        data["cModelNumber"] = this.cModelNumber;
        data["cClientName"] = this.cClientName;
        data["iIsScoredForEveryBuild"] = this.iIsScoredForEveryBuild;
        data["nChildTableNumber"] = this.nChildTableNumber;
        data["iIsActive"] = this.iIsActive;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["lK_ModelType"] = this.lK_ModelType;
        data["lK_GiftWeight"] = this.lK_GiftWeight;
        return data; 
    }
}

export interface IModelSummaryDto {
    databaseId: number | undefined;
    cModelName: string | undefined;
    iIntercept: number | undefined;
    cDescription: string | undefined;
    cModelNumber: string | undefined;
    cClientName: string | undefined;
    iIsScoredForEveryBuild: boolean | undefined;
    nChildTableNumber: number | undefined;
    iIsActive: boolean | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    lK_ModelType: string | undefined;
    lK_GiftWeight: string | undefined;
}

export class GetModelScoringDropdownDto implements IGetModelScoringDropdownDto {
    databases!: GetAllDatabaseDto | undefined;
    builds!: GetAllBuildsDto | undefined;

    constructor(data?: IGetModelScoringDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databases = data["databases"] ? GetAllDatabaseDto.fromJS(data["databases"]) : <any>undefined;
            this.builds = data["builds"] ? GetAllBuildsDto.fromJS(data["builds"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetModelScoringDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetModelScoringDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databases"] = this.databases ? this.databases.toJSON() : <any>undefined;
        data["builds"] = this.builds ? this.builds.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetModelScoringDropdownDto {
    databases: GetAllDatabaseDto | undefined;
    builds: GetAllBuildsDto | undefined;
}

export class GetAllDatabaseDto implements IGetAllDatabaseDto {
    databases!: DropdownOutputDto[] | undefined;
    defaultDatabase!: number | undefined;

    constructor(data?: IGetAllDatabaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["databases"])) {
                this.databases = [] as any;
                for (let item of data["databases"])
                    this.databases!.push(DropdownOutputDto.fromJS(item));
            }
            this.defaultDatabase = data["defaultDatabase"];
        }
    }

    static fromJS(data: any): GetAllDatabaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDatabaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.databases)) {
            data["databases"] = [];
            for (let item of this.databases)
                data["databases"].push(item.toJSON());
        }
        data["defaultDatabase"] = this.defaultDatabase;
        return data; 
    }
}

export interface IGetAllDatabaseDto {
    databases: DropdownOutputDto[] | undefined;
    defaultDatabase: number | undefined;
}

export class GetAllBuildsDto implements IGetAllBuildsDto {
    buildDropDown!: DropdownOutputDto[] | undefined;
    defaultSelection!: number | undefined;

    constructor(data?: IGetAllBuildsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["buildDropDown"])) {
                this.buildDropDown = [] as any;
                for (let item of data["buildDropDown"])
                    this.buildDropDown!.push(DropdownOutputDto.fromJS(item));
            }
            this.defaultSelection = data["defaultSelection"];
        }
    }

    static fromJS(data: any): GetAllBuildsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllBuildsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.buildDropDown)) {
            data["buildDropDown"] = [];
            for (let item of this.buildDropDown)
                data["buildDropDown"].push(item.toJSON());
        }
        data["defaultSelection"] = this.defaultSelection;
        return data; 
    }
}

export interface IGetAllBuildsDto {
    buildDropDown: DropdownOutputDto[] | undefined;
    defaultSelection: number | undefined;
}

export class ModelStatusDto implements IModelStatusDto {
    id!: number | undefined;
    modelDetailID!: number | undefined;
    iStatus!: string | undefined;
    dCreatedDate!: string | undefined;
    cCreatedBy!: string | undefined;

    constructor(data?: IModelStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.modelDetailID = data["modelDetailID"];
            this.iStatus = data["iStatus"];
            this.dCreatedDate = data["dCreatedDate"];
            this.cCreatedBy = data["cCreatedBy"];
        }
    }

    static fromJS(data: any): ModelStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["modelDetailID"] = this.modelDetailID;
        data["iStatus"] = this.iStatus;
        data["dCreatedDate"] = this.dCreatedDate;
        data["cCreatedBy"] = this.cCreatedBy;
        return data; 
    }
}

export interface IModelStatusDto {
    id: number | undefined;
    modelDetailID: number | undefined;
    iStatus: string | undefined;
    dCreatedDate: string | undefined;
    cCreatedBy: string | undefined;
}

export class PagedResultDtoOfGetNeighborhoodForViewDto implements IPagedResultDtoOfGetNeighborhoodForViewDto {
    totalCount!: number | undefined;
    items!: GetNeighborhoodForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetNeighborhoodForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetNeighborhoodForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetNeighborhoodForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetNeighborhoodForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetNeighborhoodForViewDto {
    totalCount: number | undefined;
    items: GetNeighborhoodForViewDto[] | undefined;
}

export class GetNeighborhoodForViewDto implements IGetNeighborhoodForViewDto {
    neighborhood!: NeighborhoodDto | undefined;

    constructor(data?: IGetNeighborhoodForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.neighborhood = data["neighborhood"] ? NeighborhoodDto.fromJS(data["neighborhood"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetNeighborhoodForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetNeighborhoodForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["neighborhood"] = this.neighborhood ? this.neighborhood.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetNeighborhoodForViewDto {
    neighborhood: NeighborhoodDto | undefined;
}

export class NeighborhoodDto implements INeighborhoodDto {
    id!: number | undefined;

    constructor(data?: INeighborhoodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): NeighborhoodDto {
        data = typeof data === 'object' ? data : {};
        let result = new NeighborhoodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface INeighborhoodDto {
    id: number | undefined;
}

export class GetNeighborhoodForEditOutput implements IGetNeighborhoodForEditOutput {
    neighborhood!: CreateOrEditNeighborhoodDto | undefined;

    constructor(data?: IGetNeighborhoodForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.neighborhood = data["neighborhood"] ? CreateOrEditNeighborhoodDto.fromJS(data["neighborhood"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetNeighborhoodForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNeighborhoodForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["neighborhood"] = this.neighborhood ? this.neighborhood.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetNeighborhoodForEditOutput {
    neighborhood: CreateOrEditNeighborhoodDto | undefined;
}

export class CreateOrEditNeighborhoodDto implements ICreateOrEditNeighborhoodDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditNeighborhoodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditNeighborhoodDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditNeighborhoodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditNeighborhoodDto {
    id: number | undefined;
}

export enum UserNotificationState {
    Unread = 0,
    Read = 1,
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number | undefined;
    totalCount!: number | undefined;
    items!: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;
}

export class UserNotification implements IUserNotification {
    tenantId!: number | undefined;
    userId!: number | undefined;
    state!: UserNotificationState | undefined;
    notification!: TenantNotification | undefined;
    id!: string | undefined;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;
}

export class TenantNotification implements ITenantNotification {
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData | undefined;
    entityType!: string | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity | undefined;
    creationTime!: moment.Moment | undefined;
    id!: string | undefined;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            this.entityId = data["entityId"];
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;
}

export class NotificationData implements INotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string]: any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).type = data["type"];
            if (data["properties"]) {
                this.properties = {} as any;
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties![key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string]: any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0,
    Success = 1,
    Warn = 2,
    Error = 3,
    Fatal = 4,
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfGuid {
    id: string | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (Array.isArray(data["notifications"])) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (Array.isArray(data["notifications"])) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;
}

export class GetOccupationForViewDto implements IGetOccupationForViewDto {
    configuredFields!: AdvanceSelectionFields | undefined;
    industries!: DropdownOutputDto[] | undefined;

    constructor(data?: IGetOccupationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.configuredFields = data["configuredFields"] ? AdvanceSelectionFields.fromJS(data["configuredFields"]) : <any>undefined;
            if (Array.isArray(data["industries"])) {
                this.industries = [] as any;
                for (let item of data["industries"])
                    this.industries!.push(DropdownOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetOccupationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOccupationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configuredFields"] = this.configuredFields ? this.configuredFields.toJSON() : <any>undefined;
        if (Array.isArray(this.industries)) {
            data["industries"] = [];
            for (let item of this.industries)
                data["industries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetOccupationForViewDto {
    configuredFields: AdvanceSelectionFields | undefined;
    industries: DropdownOutputDto[] | undefined;
}

export class PagedResultDtoOfGetOfferForViewDto implements IPagedResultDtoOfGetOfferForViewDto {
    totalCount!: number | undefined;
    items!: GetOfferForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetOfferForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetOfferForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetOfferForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetOfferForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetOfferForViewDto {
    totalCount: number | undefined;
    items: GetOfferForViewDto[] | undefined;
}

export class GetOfferForViewDto implements IGetOfferForViewDto {
    offer!: OfferDto | undefined;
    mailercCompany!: string | undefined;

    constructor(data?: IGetOfferForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.offer = data["offer"] ? OfferDto.fromJS(data["offer"]) : <any>undefined;
            this.mailercCompany = data["mailercCompany"];
        }
    }

    static fromJS(data: any): GetOfferForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOfferForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offer"] = this.offer ? this.offer.toJSON() : <any>undefined;
        data["mailercCompany"] = this.mailercCompany;
        return data; 
    }
}

export interface IGetOfferForViewDto {
    offer: OfferDto | undefined;
    mailercCompany: string | undefined;
}

export class OfferDto implements IOfferDto {
    cOfferCode!: string | undefined;
    cOfferName!: string | undefined;
    lK_OfferType!: string | undefined;
    iIsActive!: boolean | undefined;
    mailerId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOfferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cOfferCode = data["cOfferCode"];
            this.cOfferName = data["cOfferName"];
            this.lK_OfferType = data["lK_OfferType"];
            this.iIsActive = data["iIsActive"];
            this.mailerId = data["mailerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OfferDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cOfferCode"] = this.cOfferCode;
        data["cOfferName"] = this.cOfferName;
        data["lK_OfferType"] = this.lK_OfferType;
        data["iIsActive"] = this.iIsActive;
        data["mailerId"] = this.mailerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOfferDto {
    cOfferCode: string | undefined;
    cOfferName: string | undefined;
    lK_OfferType: string | undefined;
    iIsActive: boolean | undefined;
    mailerId: number | undefined;
    id: number | undefined;
}

export class GetOfferForEditOutput implements IGetOfferForEditOutput {
    offer!: CreateOrEditOfferDto | undefined;
    mailercCompany!: string | undefined;

    constructor(data?: IGetOfferForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.offer = data["offer"] ? CreateOrEditOfferDto.fromJS(data["offer"]) : <any>undefined;
            this.mailercCompany = data["mailercCompany"];
        }
    }

    static fromJS(data: any): GetOfferForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOfferForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offer"] = this.offer ? this.offer.toJSON() : <any>undefined;
        data["mailercCompany"] = this.mailercCompany;
        return data; 
    }
}

export interface IGetOfferForEditOutput {
    offer: CreateOrEditOfferDto | undefined;
    mailercCompany: string | undefined;
}

export class CreateOrEditOfferDto implements ICreateOrEditOfferDto {
    offerTypeDescription!: DropdownOutputDto[] | undefined;
    cOfferCode!: string | undefined;
    cOfferName!: string;
    lK_OfferType!: string;
    iIsActive!: boolean | undefined;
    iHideInDWAP!: boolean | undefined;
    isAutoApprove!: boolean | undefined;
    mailerId!: number | undefined;
    cCreatedBy!: string | undefined;
    cModifiedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    dModifiedDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditOfferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["offerTypeDescription"])) {
                this.offerTypeDescription = [] as any;
                for (let item of data["offerTypeDescription"])
                    this.offerTypeDescription!.push(DropdownOutputDto.fromJS(item));
            }
            this.cOfferCode = data["cOfferCode"];
            this.cOfferName = data["cOfferName"];
            this.lK_OfferType = data["lK_OfferType"];
            this.iIsActive = data["iIsActive"];
            this.iHideInDWAP = data["iHideInDWAP"];
            this.isAutoApprove = data["isAutoApprove"];
            this.mailerId = data["mailerId"];
            this.cCreatedBy = data["cCreatedBy"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditOfferDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditOfferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.offerTypeDescription)) {
            data["offerTypeDescription"] = [];
            for (let item of this.offerTypeDescription)
                data["offerTypeDescription"].push(item.toJSON());
        }
        data["cOfferCode"] = this.cOfferCode;
        data["cOfferName"] = this.cOfferName;
        data["lK_OfferType"] = this.lK_OfferType;
        data["iIsActive"] = this.iIsActive;
        data["iHideInDWAP"] = this.iHideInDWAP;
        data["isAutoApprove"] = this.isAutoApprove;
        data["mailerId"] = this.mailerId;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditOfferDto {
    offerTypeDescription: DropdownOutputDto[] | undefined;
    cOfferCode: string | undefined;
    cOfferName: string;
    lK_OfferType: string;
    iIsActive: boolean | undefined;
    iHideInDWAP: boolean | undefined;
    isAutoApprove: boolean | undefined;
    mailerId: number | undefined;
    cCreatedBy: string | undefined;
    cModifiedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    dModifiedDate: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOfferSampleDto implements IPagedResultDtoOfOfferSampleDto {
    totalCount!: number | undefined;
    items!: OfferSampleDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOfferSampleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OfferSampleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOfferSampleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOfferSampleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOfferSampleDto {
    totalCount: number | undefined;
    items: OfferSampleDto[] | undefined;
}

export class OfferSampleDto implements IOfferSampleDto {
    cDescription!: string | undefined;
    offerId!: number | undefined;
    cFileName!: string | undefined;
    id!: number | undefined;

    constructor(data?: IOfferSampleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cDescription = data["cDescription"];
            this.offerId = data["offerId"];
            this.cFileName = data["cFileName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OfferSampleDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferSampleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cDescription"] = this.cDescription;
        data["offerId"] = this.offerId;
        data["cFileName"] = this.cFileName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOfferSampleDto {
    cDescription: string | undefined;
    offerId: number | undefined;
    cFileName: string | undefined;
    id: number | undefined;
}

export class CreateOrEditOfferSampleDto implements ICreateOrEditOfferSampleDto {
    cDescription!: string | undefined;
    cFileName!: string | undefined;
    offerId!: number | undefined;
    mailerCompany!: string | undefined;
    cCreatedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditOfferSampleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cDescription = data["cDescription"];
            this.cFileName = data["cFileName"];
            this.offerId = data["offerId"];
            this.mailerCompany = data["mailerCompany"];
            this.cCreatedBy = data["cCreatedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditOfferSampleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditOfferSampleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cDescription"] = this.cDescription;
        data["cFileName"] = this.cFileName;
        data["offerId"] = this.offerId;
        data["mailerCompany"] = this.mailerCompany;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditOfferSampleDto {
    cDescription: string | undefined;
    cFileName: string | undefined;
    offerId: number | undefined;
    mailerCompany: string | undefined;
    cCreatedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    id: number | undefined;
}

export class CampaignStatusDto implements ICampaignStatusDto {
    id!: number | undefined;
    orderID!: number | undefined;
    iStatus!: number | undefined;
    iIsCurrent!: boolean | undefined;
    dCreatedDate!: string | undefined;
    cCreatedBy!: string | undefined;
    iStopRequested!: string | undefined;

    constructor(data?: ICampaignStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.orderID = data["orderID"];
            this.iStatus = data["iStatus"];
            this.iIsCurrent = data["iIsCurrent"];
            this.dCreatedDate = data["dCreatedDate"];
            this.cCreatedBy = data["cCreatedBy"];
            this.iStopRequested = data["iStopRequested"];
        }
    }

    static fromJS(data: any): CampaignStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderID"] = this.orderID;
        data["iStatus"] = this.iStatus;
        data["iIsCurrent"] = this.iIsCurrent;
        data["dCreatedDate"] = this.dCreatedDate;
        data["cCreatedBy"] = this.cCreatedBy;
        data["iStopRequested"] = this.iStopRequested;
        return data; 
    }
}

export interface ICampaignStatusDto {
    id: number | undefined;
    orderID: number | undefined;
    iStatus: number | undefined;
    iIsCurrent: boolean | undefined;
    dCreatedDate: string | undefined;
    cCreatedBy: string | undefined;
    iStopRequested: string | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number | undefined;
    roleCount!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.roleCount = data["roleCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    roleCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number | undefined;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.name = data["name"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number | undefined;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number | undefined;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }
}

export interface IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["userIds"])) {
                this.userIds = [] as any;
                for (let item of data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PagedResultDtoOfOwnerDto implements IPagedResultDtoOfOwnerDto {
    totalCount!: number | undefined;
    items!: OwnerDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OwnerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOwnerDto {
    totalCount: number | undefined;
    items: OwnerDto[] | undefined;
}

export class OwnerDto implements IOwnerDto {
    cCode!: string | undefined;
    cCompany!: string | undefined;
    iIsActive!: boolean | undefined;
    cAddress!: string | undefined;
    databaseId!: number | undefined;
    contactsCount!: number | undefined;
    cAddress1!: string | undefined;
    cAddress2!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cZip!: string | undefined;
    cPhone!: string | undefined;
    cFax!: string | undefined;
    contactsList!: CreateOrEditContactDto[] | undefined;
    id!: number | undefined;

    constructor(data?: IOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cCode = data["cCode"];
            this.cCompany = data["cCompany"];
            this.iIsActive = data["iIsActive"];
            this.cAddress = data["cAddress"];
            this.databaseId = data["databaseId"];
            this.contactsCount = data["contactsCount"];
            this.cAddress1 = data["cAddress1"];
            this.cAddress2 = data["cAddress2"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cZip = data["cZip"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            if (Array.isArray(data["contactsList"])) {
                this.contactsList = [] as any;
                for (let item of data["contactsList"])
                    this.contactsList!.push(CreateOrEditContactDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cCode"] = this.cCode;
        data["cCompany"] = this.cCompany;
        data["iIsActive"] = this.iIsActive;
        data["cAddress"] = this.cAddress;
        data["databaseId"] = this.databaseId;
        data["contactsCount"] = this.contactsCount;
        data["cAddress1"] = this.cAddress1;
        data["cAddress2"] = this.cAddress2;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cZip"] = this.cZip;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        if (Array.isArray(this.contactsList)) {
            data["contactsList"] = [];
            for (let item of this.contactsList)
                data["contactsList"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IOwnerDto {
    cCode: string | undefined;
    cCompany: string | undefined;
    iIsActive: boolean | undefined;
    cAddress: string | undefined;
    databaseId: number | undefined;
    contactsCount: number | undefined;
    cAddress1: string | undefined;
    cAddress2: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cZip: string | undefined;
    cPhone: string | undefined;
    cFax: string | undefined;
    contactsList: CreateOrEditContactDto[] | undefined;
    id: number | undefined;
}

export class CreateOrEditOwnerDto implements ICreateOrEditOwnerDto {
    cCode!: string | undefined;
    cCompany!: string | undefined;
    cAddress1!: string | undefined;
    cAddress2!: string | undefined;
    cCity!: string | undefined;
    cState!: string | undefined;
    cZip!: string | undefined;
    cPhone!: string | undefined;
    cFax!: string | undefined;
    cNotes!: string | undefined;
    iIsActive!: boolean | undefined;
    databaseId!: number | undefined;
    cCreatedBy!: string | undefined;
    cModifiedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    dModifiedDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cCode = data["cCode"];
            this.cCompany = data["cCompany"];
            this.cAddress1 = data["cAddress1"];
            this.cAddress2 = data["cAddress2"];
            this.cCity = data["cCity"];
            this.cState = data["cState"];
            this.cZip = data["cZip"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            this.cNotes = data["cNotes"];
            this.iIsActive = data["iIsActive"];
            this.databaseId = data["databaseId"];
            this.cCreatedBy = data["cCreatedBy"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditOwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditOwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cCode"] = this.cCode;
        data["cCompany"] = this.cCompany;
        data["cAddress1"] = this.cAddress1;
        data["cAddress2"] = this.cAddress2;
        data["cCity"] = this.cCity;
        data["cState"] = this.cState;
        data["cZip"] = this.cZip;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        data["cNotes"] = this.cNotes;
        data["iIsActive"] = this.iIsActive;
        data["databaseId"] = this.databaseId;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditOwnerDto {
    cCode: string | undefined;
    cCompany: string | undefined;
    cAddress1: string | undefined;
    cAddress2: string | undefined;
    cCity: string | undefined;
    cState: string | undefined;
    cZip: string | undefined;
    cPhone: string | undefined;
    cFax: string | undefined;
    cNotes: string | undefined;
    iIsActive: boolean | undefined;
    databaseId: number | undefined;
    cCreatedBy: string | undefined;
    cModifiedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    dModifiedDate: moment.Moment | undefined;
    id: number | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition!: EditionSelectDto | undefined;
    additionalPrice!: number | undefined;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            this.additionalPrice = data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto | undefined;
    additionalPrice: number | undefined;
}

export class EditionSelectDto implements IEditionSelectDto {
    id!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    expiringEditionId!: number | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    isFree!: boolean | undefined;
    additionalData!: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
            this.dailyPrice = data["dailyPrice"];
            this.weeklyPrice = data["weeklyPrice"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.isFree = data["isFree"];
            this.additionalData = data["additionalData"] ? AdditionalData.fromJS(data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEditionSelectDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean | undefined;
    additionalData: AdditionalData | undefined;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId!: number | undefined;
    editionPaymentType!: EditionPaymentType | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    subscriptionPaymentGatewayType!: SubscriptionPaymentGatewayType | undefined;
    recurringPaymentEnabled!: boolean | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.editionPaymentType = data["editionPaymentType"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = data["recurringPaymentEnabled"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data; 
    }
}

export interface ICreatePaymentDto {
    editionId: number | undefined;
    editionPaymentType: EditionPaymentType | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType | undefined;
    recurringPaymentEnabled: boolean | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
}

export enum PaymentPeriodType {
    Daily = 1,
    Weekly = 7,
    Monthly = 30,
    Annual = 365,
}

export enum EditionPaymentType {
    NewRegistration = 0,
    BuyNow = 1,
    Upgrade = 2,
    Extend = 3,
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1,
    Stripe = 2,
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType | undefined;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.gateway = data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data; 
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount!: number | undefined;
    items!: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number | undefined;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway!: string | undefined;
    amount!: number | undefined;
    editionId!: number | undefined;
    dayCount!: number | undefined;
    paymentPeriodType!: string | undefined;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    status!: string | undefined;
    editionDisplayName!: string | undefined;
    tenantId!: number | undefined;
    invoiceNo!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.status = data["status"];
            this.editionDisplayName = data["editionDisplayName"];
            this.tenantId = data["tenantId"];
            this.invoiceNo = data["invoiceNo"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number | undefined;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType!: SubscriptionPaymentGatewayType | undefined;
    supportsRecurringPayments!: boolean | undefined;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gatewayType = data["gatewayType"];
            this.supportsRecurringPayments = data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data; 
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType | undefined;
    supportsRecurringPayments: boolean | undefined;
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType | undefined;
    amount!: number | undefined;
    editionId!: number | undefined;
    tenantId!: number | undefined;
    dayCount!: number | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: number | undefined;
    status!: SubscriptionPaymentStatus | undefined;
    isRecurring!: boolean | undefined;
    externalPaymentId!: string | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.tenantId = data["tenantId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.status = data["status"];
            this.isRecurring = data["isRecurring"];
            this.externalPaymentId = data["externalPaymentId"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    tenantId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number | undefined;
    status: SubscriptionPaymentStatus | undefined;
    isRecurring: boolean | undefined;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    id: number | undefined;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1,
    Paid = 2,
    Failed = 3,
    Cancelled = 4,
    Completed = 5,
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId!: string | undefined;
    demoUsername!: string | undefined;
    demoPassword!: string | undefined;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.demoUsername = data["demoUsername"];
            this.demoPassword = data["demoPassword"];
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        return data; 
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number | undefined;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class DropdownForProcessQueueDto implements IDropdownForProcessQueueDto {
    value!: number | undefined;
    label!: string | undefined;
    action!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IDropdownForProcessQueueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.label = data["label"];
            this.action = data["action"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): DropdownForProcessQueueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DropdownForProcessQueueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["label"] = this.label;
        data["action"] = this.action;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IDropdownForProcessQueueDto {
    value: number | undefined;
    label: string | undefined;
    action: string | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class PagedResultDtoOfProcessQueueDto implements IPagedResultDtoOfProcessQueueDto {
    totalCount!: number | undefined;
    items!: ProcessQueueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProcessQueueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProcessQueueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProcessQueueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProcessQueueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProcessQueueDto {
    totalCount: number | undefined;
    items: ProcessQueueDto[] | undefined;
}

export class ProcessQueueDto implements IProcessQueueDto {
    cQueueName!: string | undefined;
    cDescription!: string | undefined;
    iAllowedThreadCount!: number | undefined;
    lK_QueueType!: string | undefined;
    lK_ProcessType!: string | undefined;
    iIsSuspended!: boolean | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    queueDescription!: string | undefined;
    processDescription!: string | undefined;
    id!: number | undefined;

    constructor(data?: IProcessQueueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cQueueName = data["cQueueName"];
            this.cDescription = data["cDescription"];
            this.iAllowedThreadCount = data["iAllowedThreadCount"];
            this.lK_QueueType = data["lK_QueueType"];
            this.lK_ProcessType = data["lK_ProcessType"];
            this.iIsSuspended = data["iIsSuspended"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.queueDescription = data["queueDescription"];
            this.processDescription = data["processDescription"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProcessQueueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessQueueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cQueueName"] = this.cQueueName;
        data["cDescription"] = this.cDescription;
        data["iAllowedThreadCount"] = this.iAllowedThreadCount;
        data["lK_QueueType"] = this.lK_QueueType;
        data["lK_ProcessType"] = this.lK_ProcessType;
        data["iIsSuspended"] = this.iIsSuspended;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["queueDescription"] = this.queueDescription;
        data["processDescription"] = this.processDescription;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProcessQueueDto {
    cQueueName: string | undefined;
    cDescription: string | undefined;
    iAllowedThreadCount: number | undefined;
    lK_QueueType: string | undefined;
    lK_ProcessType: string | undefined;
    iIsSuspended: boolean | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    queueDescription: string | undefined;
    processDescription: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfProcessQueueDatabaseDtoForView implements IPagedResultDtoOfProcessQueueDatabaseDtoForView {
    totalCount!: number | undefined;
    items!: ProcessQueueDatabaseDtoForView[] | undefined;

    constructor(data?: IPagedResultDtoOfProcessQueueDatabaseDtoForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProcessQueueDatabaseDtoForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProcessQueueDatabaseDtoForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProcessQueueDatabaseDtoForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProcessQueueDatabaseDtoForView {
    totalCount: number | undefined;
    items: ProcessQueueDatabaseDtoForView[] | undefined;
}

export class ProcessQueueDatabaseDtoForView implements IProcessQueueDatabaseDtoForView {
    databaseId!: number | undefined;
    processQueueId!: number | undefined;
    cDatabaseName!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IProcessQueueDatabaseDtoForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseId = data["databaseId"];
            this.processQueueId = data["processQueueId"];
            this.cDatabaseName = data["cDatabaseName"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): ProcessQueueDatabaseDtoForView {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessQueueDatabaseDtoForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseId"] = this.databaseId;
        data["processQueueId"] = this.processQueueId;
        data["cDatabaseName"] = this.cDatabaseName;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IProcessQueueDatabaseDtoForView {
    databaseId: number | undefined;
    processQueueId: number | undefined;
    cDatabaseName: string | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class GetProcessQueueForViewDto implements IGetProcessQueueForViewDto {
    processQueue!: ProcessQueueDto | undefined;

    constructor(data?: IGetProcessQueueForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.processQueue = data["processQueue"] ? ProcessQueueDto.fromJS(data["processQueue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetProcessQueueForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProcessQueueForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processQueue"] = this.processQueue ? this.processQueue.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetProcessQueueForViewDto {
    processQueue: ProcessQueueDto | undefined;
}

export class CreateOrEditProcessQueueDto implements ICreateOrEditProcessQueueDto {
    cQueueName!: string | undefined;
    cDescription!: string | undefined;
    iAllowedThreadCount!: number | undefined;
    lK_QueueType!: string | undefined;
    lK_ProcessType!: string | undefined;
    iIsSuspended!: boolean | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditProcessQueueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cQueueName = data["cQueueName"];
            this.cDescription = data["cDescription"];
            this.iAllowedThreadCount = data["iAllowedThreadCount"];
            this.lK_QueueType = data["lK_QueueType"];
            this.lK_ProcessType = data["lK_ProcessType"];
            this.iIsSuspended = data["iIsSuspended"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditProcessQueueDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditProcessQueueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cQueueName"] = this.cQueueName;
        data["cDescription"] = this.cDescription;
        data["iAllowedThreadCount"] = this.iAllowedThreadCount;
        data["lK_QueueType"] = this.lK_QueueType;
        data["lK_ProcessType"] = this.lK_ProcessType;
        data["iIsSuspended"] = this.iIsSuspended;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditProcessQueueDto {
    cQueueName: string | undefined;
    cDescription: string | undefined;
    iAllowedThreadCount: number | undefined;
    lK_QueueType: string | undefined;
    lK_ProcessType: string | undefined;
    iIsSuspended: boolean | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    id: number | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
    phoneNumber: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken!: string;
    x!: number | undefined;
    y!: number | undefined;
    width!: number | undefined;
    height!: number | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting | undefined;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class RedisCacheDto implements IRedisCacheDto {
    value!: string | undefined;
    label!: string | undefined;
    count!: string | undefined;
    id!: number | undefined;

    constructor(data?: IRedisCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.label = data["label"];
            this.count = data["count"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RedisCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new RedisCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["label"] = this.label;
        data["count"] = this.count;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRedisCacheDto {
    value: string | undefined;
    label: string | undefined;
    count: string | undefined;
    id: number | undefined;
}

export class GetReportForViewDto implements IGetReportForViewDto {
    reportOptions!: DropdownOutputDto[] | undefined;
    selectedReport!: number | undefined;
    reports!: ReportDto[] | undefined;
    accessToken!: string | undefined;

    constructor(data?: IGetReportForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["reportOptions"])) {
                this.reportOptions = [] as any;
                for (let item of data["reportOptions"])
                    this.reportOptions!.push(DropdownOutputDto.fromJS(item));
            }
            this.selectedReport = data["selectedReport"];
            if (Array.isArray(data["reports"])) {
                this.reports = [] as any;
                for (let item of data["reports"])
                    this.reports!.push(ReportDto.fromJS(item));
            }
            this.accessToken = data["accessToken"];
        }
    }

    static fromJS(data: any): GetReportForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reportOptions)) {
            data["reportOptions"] = [];
            for (let item of this.reportOptions)
                data["reportOptions"].push(item.toJSON());
        }
        data["selectedReport"] = this.selectedReport;
        if (Array.isArray(this.reports)) {
            data["reports"] = [];
            for (let item of this.reports)
                data["reports"].push(item.toJSON());
        }
        data["accessToken"] = this.accessToken;
        return data; 
    }
}

export interface IGetReportForViewDto {
    reportOptions: DropdownOutputDto[] | undefined;
    selectedReport: number | undefined;
    reports: ReportDto[] | undefined;
    accessToken: string | undefined;
}

export class ReportDto implements IReportDto {
    id!: number | undefined;
    cReportID!: string | undefined;
    cReportName!: string | undefined;
    cReportWorkSpaceID!: string | undefined;
    cReportConfig!: string | undefined;

    constructor(data?: IReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cReportID = data["cReportID"];
            this.cReportName = data["cReportName"];
            this.cReportWorkSpaceID = data["cReportWorkSpaceID"];
            this.cReportConfig = data["cReportConfig"];
        }
    }

    static fromJS(data: any): ReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cReportID"] = this.cReportID;
        data["cReportName"] = this.cReportName;
        data["cReportWorkSpaceID"] = this.cReportWorkSpaceID;
        data["cReportConfig"] = this.cReportConfig;
        return data; 
    }
}

export interface IReportDto {
    id: number | undefined;
    cReportID: string | undefined;
    cReportName: string | undefined;
    cReportWorkSpaceID: string | undefined;
    cReportConfig: string | undefined;
}

export class UserReport implements IUserReport {
    userID!: number | undefined;
    idmsUserFk!: IDMSUser | undefined;
    reportID!: number | undefined;
    reportFk!: Report | undefined;
    id!: number | undefined;

    constructor(data?: IUserReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userID = data["userID"];
            this.idmsUserFk = data["idmsUserFk"] ? IDMSUser.fromJS(data["idmsUserFk"]) : <any>undefined;
            this.reportID = data["reportID"];
            this.reportFk = data["reportFk"] ? Report.fromJS(data["reportFk"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserReport {
        data = typeof data === 'object' ? data : {};
        let result = new UserReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userID"] = this.userID;
        data["idmsUserFk"] = this.idmsUserFk ? this.idmsUserFk.toJSON() : <any>undefined;
        data["reportID"] = this.reportID;
        data["reportFk"] = this.reportFk ? this.reportFk.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserReport {
    userID: number | undefined;
    idmsUserFk: IDMSUser | undefined;
    reportID: number | undefined;
    reportFk: Report | undefined;
    id: number | undefined;
}

export class IDMSUser implements IIDMSUser {
    cFirstName!: string;
    cLastName!: string;
    cUserID!: string;
    cEmail!: string;
    cPhone!: string;
    cFax!: string;
    iIsActive!: boolean | undefined;
    iIsNotify!: boolean | undefined;
    iLogonAttempts!: number | undefined;
    lastLogonDate!: moment.Moment | undefined;
    cCreatedBy!: string;
    dCreatedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    lK_AccountingDivisionCode!: string;
    mailerID!: number | undefined;
    divisionMailerID!: number | undefined;
    divisionBrokerID!: number | undefined;
    id!: number | undefined;

    constructor(data?: IIDMSUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cFirstName = data["cFirstName"];
            this.cLastName = data["cLastName"];
            this.cUserID = data["cUserID"];
            this.cEmail = data["cEmail"];
            this.cPhone = data["cPhone"];
            this.cFax = data["cFax"];
            this.iIsActive = data["iIsActive"];
            this.iIsNotify = data["iIsNotify"];
            this.iLogonAttempts = data["iLogonAttempts"];
            this.lastLogonDate = data["lastLogonDate"] ? moment(data["lastLogonDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.lK_AccountingDivisionCode = data["lK_AccountingDivisionCode"];
            this.mailerID = data["mailerID"];
            this.divisionMailerID = data["divisionMailerID"];
            this.divisionBrokerID = data["divisionBrokerID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): IDMSUser {
        data = typeof data === 'object' ? data : {};
        let result = new IDMSUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cFirstName"] = this.cFirstName;
        data["cLastName"] = this.cLastName;
        data["cUserID"] = this.cUserID;
        data["cEmail"] = this.cEmail;
        data["cPhone"] = this.cPhone;
        data["cFax"] = this.cFax;
        data["iIsActive"] = this.iIsActive;
        data["iIsNotify"] = this.iIsNotify;
        data["iLogonAttempts"] = this.iLogonAttempts;
        data["lastLogonDate"] = this.lastLogonDate ? this.lastLogonDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["lK_AccountingDivisionCode"] = this.lK_AccountingDivisionCode;
        data["mailerID"] = this.mailerID;
        data["divisionMailerID"] = this.divisionMailerID;
        data["divisionBrokerID"] = this.divisionBrokerID;
        data["id"] = this.id;
        return data; 
    }
}

export interface IIDMSUser {
    cFirstName: string;
    cLastName: string;
    cUserID: string;
    cEmail: string;
    cPhone: string;
    cFax: string;
    iIsActive: boolean | undefined;
    iIsNotify: boolean | undefined;
    iLogonAttempts: number | undefined;
    lastLogonDate: moment.Moment | undefined;
    cCreatedBy: string;
    dCreatedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    lK_AccountingDivisionCode: string;
    mailerID: number | undefined;
    divisionMailerID: number | undefined;
    divisionBrokerID: number | undefined;
    id: number | undefined;
}

export class Report implements IReport {
    cReportID!: string;
    cReportName!: string;
    cReportWorkSpaceID!: string;
    cReportConfig!: string;
    id!: number | undefined;

    constructor(data?: IReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cReportID = data["cReportID"];
            this.cReportName = data["cReportName"];
            this.cReportWorkSpaceID = data["cReportWorkSpaceID"];
            this.cReportConfig = data["cReportConfig"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Report {
        data = typeof data === 'object' ? data : {};
        let result = new Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cReportID"] = this.cReportID;
        data["cReportName"] = this.cReportName;
        data["cReportWorkSpaceID"] = this.cReportWorkSpaceID;
        data["cReportConfig"] = this.cReportConfig;
        data["id"] = this.id;
        return data; 
    }
}

export interface IReport {
    cReportID: string;
    cReportName: string;
    cReportWorkSpaceID: string;
    cReportConfig: string;
    id: number | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean | undefined;
    isDefault!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto | undefined;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (Array.isArray(data["permissions"])) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (Array.isArray(data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class RoleReportDto implements IRoleReportDto {
    role!: string | undefined;
    permission!: string | undefined;

    constructor(data?: IRoleReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"];
            this.permission = data["permission"];
        }
    }

    static fromJS(data: any): RoleReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role;
        data["permission"] = this.permission;
        return data; 
    }
}

export interface IRoleReportDto {
    role: string | undefined;
    permission: string | undefined;
}

export class GetSavedSelectionDetailForViewDto implements IGetSavedSelectionDetailForViewDto {
    iGroupNumber!: number | undefined;
    cJoinOperator!: string | undefined;
    cFieldDescription!: string | undefined;
    cValueOperator!: string | undefined;
    cValues!: string | undefined;

    constructor(data?: IGetSavedSelectionDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.iGroupNumber = data["iGroupNumber"];
            this.cJoinOperator = data["cJoinOperator"];
            this.cFieldDescription = data["cFieldDescription"];
            this.cValueOperator = data["cValueOperator"];
            this.cValues = data["cValues"];
        }
    }

    static fromJS(data: any): GetSavedSelectionDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSavedSelectionDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iGroupNumber"] = this.iGroupNumber;
        data["cJoinOperator"] = this.cJoinOperator;
        data["cFieldDescription"] = this.cFieldDescription;
        data["cValueOperator"] = this.cValueOperator;
        data["cValues"] = this.cValues;
        return data; 
    }
}

export interface IGetSavedSelectionDetailForViewDto {
    iGroupNumber: number | undefined;
    cJoinOperator: string | undefined;
    cFieldDescription: string | undefined;
    cValueOperator: string | undefined;
    cValues: string | undefined;
}

export class PagedResultDtoOfGetSavedSelectionForViewDto implements IPagedResultDtoOfGetSavedSelectionForViewDto {
    totalCount!: number | undefined;
    items!: GetSavedSelectionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSavedSelectionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSavedSelectionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSavedSelectionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSavedSelectionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetSavedSelectionForViewDto {
    totalCount: number | undefined;
    items: GetSavedSelectionForViewDto[] | undefined;
}

export class GetSavedSelectionForViewDto implements IGetSavedSelectionForViewDto {
    id!: number | undefined;
    cDescription!: string | undefined;
    isOR!: boolean | undefined;
    userDefault!: boolean | undefined;
    iIsDefault!: boolean | undefined;
    cChannelType!: string | undefined;

    constructor(data?: IGetSavedSelectionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cDescription = data["cDescription"];
            this.isOR = data["isOR"];
            this.userDefault = data["userDefault"];
            this.iIsDefault = data["iIsDefault"];
            this.cChannelType = data["cChannelType"];
        }
    }

    static fromJS(data: any): GetSavedSelectionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSavedSelectionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cDescription"] = this.cDescription;
        data["isOR"] = this.isOR;
        data["userDefault"] = this.userDefault;
        data["iIsDefault"] = this.iIsDefault;
        data["cChannelType"] = this.cChannelType;
        return data; 
    }
}

export interface IGetSavedSelectionForViewDto {
    id: number | undefined;
    cDescription: string | undefined;
    isOR: boolean | undefined;
    userDefault: boolean | undefined;
    iIsDefault: boolean | undefined;
    cChannelType: string | undefined;
}

export class AddSavedSelection implements IAddSavedSelection {
    segmentID!: number | undefined;
    campaignID!: number | undefined;
    savedSelectionList!: GetSavedSelectionForViewDto[] | undefined;

    constructor(data?: IAddSavedSelection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.segmentID = data["segmentID"];
            this.campaignID = data["campaignID"];
            if (Array.isArray(data["savedSelectionList"])) {
                this.savedSelectionList = [] as any;
                for (let item of data["savedSelectionList"])
                    this.savedSelectionList!.push(GetSavedSelectionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddSavedSelection {
        data = typeof data === 'object' ? data : {};
        let result = new AddSavedSelection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["segmentID"] = this.segmentID;
        data["campaignID"] = this.campaignID;
        if (Array.isArray(this.savedSelectionList)) {
            data["savedSelectionList"] = [];
            for (let item of this.savedSelectionList)
                data["savedSelectionList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddSavedSelection {
    segmentID: number | undefined;
    campaignID: number | undefined;
    savedSelectionList: GetSavedSelectionForViewDto[] | undefined;
}

export class PagedResultDtoOfSecurityGroupDto implements IPagedResultDtoOfSecurityGroupDto {
    totalCount!: number | undefined;
    items!: SecurityGroupDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSecurityGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SecurityGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSecurityGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSecurityGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSecurityGroupDto {
    totalCount: number | undefined;
    items: SecurityGroupDto[] | undefined;
}

export class SecurityGroupDto implements ISecurityGroupDto {
    databaseID!: number | undefined;
    cGroupName!: string | undefined;
    userCount!: number | undefined;
    cGroupDescription!: string | undefined;
    cStatus!: string | undefined;
    iIsActive!: boolean | undefined;
    groupBrokerList!: string[] | undefined;
    groupUsers!: string[] | undefined;
    id!: number | undefined;

    constructor(data?: ISecurityGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseID = data["databaseID"];
            this.cGroupName = data["cGroupName"];
            this.userCount = data["userCount"];
            this.cGroupDescription = data["cGroupDescription"];
            this.cStatus = data["cStatus"];
            this.iIsActive = data["iIsActive"];
            if (Array.isArray(data["groupBrokerList"])) {
                this.groupBrokerList = [] as any;
                for (let item of data["groupBrokerList"])
                    this.groupBrokerList!.push(item);
            }
            if (Array.isArray(data["groupUsers"])) {
                this.groupUsers = [] as any;
                for (let item of data["groupUsers"])
                    this.groupUsers!.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SecurityGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseID"] = this.databaseID;
        data["cGroupName"] = this.cGroupName;
        data["userCount"] = this.userCount;
        data["cGroupDescription"] = this.cGroupDescription;
        data["cStatus"] = this.cStatus;
        data["iIsActive"] = this.iIsActive;
        if (Array.isArray(this.groupBrokerList)) {
            data["groupBrokerList"] = [];
            for (let item of this.groupBrokerList)
                data["groupBrokerList"].push(item);
        }
        if (Array.isArray(this.groupUsers)) {
            data["groupUsers"] = [];
            for (let item of this.groupUsers)
                data["groupUsers"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface ISecurityGroupDto {
    databaseID: number | undefined;
    cGroupName: string | undefined;
    userCount: number | undefined;
    cGroupDescription: string | undefined;
    cStatus: string | undefined;
    iIsActive: boolean | undefined;
    groupBrokerList: string[] | undefined;
    groupUsers: string[] | undefined;
    id: number | undefined;
}

export class CreateOrEditSecurityGroupDto implements ICreateOrEditSecurityGroupDto {
    databaseId!: number | undefined;
    cGroupName!: string | undefined;
    cGroupDescription!: string | undefined;
    cStatus!: string | undefined;
    iIsActive!: boolean | undefined;
    cCreatedBy!: string | undefined;
    cModifiedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    dModifiedDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditSecurityGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.databaseId = data["databaseId"];
            this.cGroupName = data["cGroupName"];
            this.cGroupDescription = data["cGroupDescription"];
            this.cStatus = data["cStatus"];
            this.iIsActive = data["iIsActive"];
            this.cCreatedBy = data["cCreatedBy"];
            this.cModifiedBy = data["cModifiedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSecurityGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSecurityGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseId"] = this.databaseId;
        data["cGroupName"] = this.cGroupName;
        data["cGroupDescription"] = this.cGroupDescription;
        data["cStatus"] = this.cStatus;
        data["iIsActive"] = this.iIsActive;
        data["cCreatedBy"] = this.cCreatedBy;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditSecurityGroupDto {
    databaseId: number | undefined;
    cGroupName: string | undefined;
    cGroupDescription: string | undefined;
    cStatus: string | undefined;
    iIsActive: boolean | undefined;
    cCreatedBy: string | undefined;
    cModifiedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    dModifiedDate: moment.Moment | undefined;
    id: number | undefined;
}

export class GetAllSecurityGroupsInput implements IGetAllSecurityGroupsInput {
    filter!: string | undefined;
    selectedDatabase!: number | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IGetAllSecurityGroupsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.selectedDatabase = data["selectedDatabase"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAllSecurityGroupsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSecurityGroupsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["selectedDatabase"] = this.selectedDatabase;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IGetAllSecurityGroupsInput {
    filter: string | undefined;
    selectedDatabase: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class PagedResultDtoOfUserCountDto implements IPagedResultDtoOfUserCountDto {
    totalCount!: number | undefined;
    items!: UserCountDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserCountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserCountDto {
    totalCount: number | undefined;
    items: UserCountDto[] | undefined;
}

export class UserCountDto implements IUserCountDto {
    firstName!: string | undefined;
    lastName!: string | undefined;
    email!: string | undefined;

    constructor(data?: IUserCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
        }
    }

    static fromJS(data: any): UserCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        return data; 
    }
}

export interface IUserCountDto {
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
}

export class GetAllApprovedSourcesInput implements IGetAllApprovedSourcesInput {
    filter!: string | undefined;
    segmentID!: number | undefined;
    unsavedListIDs!: number[] | undefined;

    constructor(data?: IGetAllApprovedSourcesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.segmentID = data["segmentID"];
            if (Array.isArray(data["unsavedListIDs"])) {
                this.unsavedListIDs = [] as any;
                for (let item of data["unsavedListIDs"])
                    this.unsavedListIDs!.push(item);
            }
        }
    }

    static fromJS(data: any): GetAllApprovedSourcesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllApprovedSourcesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["segmentID"] = this.segmentID;
        if (Array.isArray(this.unsavedListIDs)) {
            data["unsavedListIDs"] = [];
            for (let item of this.unsavedListIDs)
                data["unsavedListIDs"].push(item);
        }
        return data; 
    }
}

export interface IGetAllApprovedSourcesInput {
    filter: string | undefined;
    segmentID: number | undefined;
    unsavedListIDs: number[] | undefined;
}

export class SourceDto implements ISourceDto {
    listName!: string | undefined;
    listID!: number | undefined;
    action!: ActionType | undefined;
    id!: number | undefined;

    constructor(data?: ISourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.listName = data["listName"];
            this.listID = data["listID"];
            this.action = data["action"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listName"] = this.listName;
        data["listID"] = this.listID;
        data["action"] = this.action;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISourceDto {
    listName: string | undefined;
    listID: number | undefined;
    action: ActionType | undefined;
    id: number | undefined;
}

export class GetExistingSourceDataForView implements IGetExistingSourceDataForView {
    iDedupeOrderSpecified!: number | undefined;
    currentStatus!: number | undefined;
    campaignLevel!: boolean | undefined;
    selectedSources!: SourceDto[] | undefined;

    constructor(data?: IGetExistingSourceDataForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.iDedupeOrderSpecified = data["iDedupeOrderSpecified"];
            this.currentStatus = data["currentStatus"];
            this.campaignLevel = data["campaignLevel"];
            if (Array.isArray(data["selectedSources"])) {
                this.selectedSources = [] as any;
                for (let item of data["selectedSources"])
                    this.selectedSources!.push(SourceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetExistingSourceDataForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetExistingSourceDataForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iDedupeOrderSpecified"] = this.iDedupeOrderSpecified;
        data["currentStatus"] = this.currentStatus;
        data["campaignLevel"] = this.campaignLevel;
        if (Array.isArray(this.selectedSources)) {
            data["selectedSources"] = [];
            for (let item of this.selectedSources)
                data["selectedSources"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetExistingSourceDataForView {
    iDedupeOrderSpecified: number | undefined;
    currentStatus: number | undefined;
    campaignLevel: boolean | undefined;
    selectedSources: SourceDto[] | undefined;
}

export class SaveSourcesInputDto implements ISaveSourcesInputDto {
    segmentID!: number | undefined;
    addedSources!: SourceDto[] | undefined;
    deletedSources!: SourceDto[] | undefined;

    constructor(data?: ISaveSourcesInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.segmentID = data["segmentID"];
            if (Array.isArray(data["addedSources"])) {
                this.addedSources = [] as any;
                for (let item of data["addedSources"])
                    this.addedSources!.push(SourceDto.fromJS(item));
            }
            if (Array.isArray(data["deletedSources"])) {
                this.deletedSources = [] as any;
                for (let item of data["deletedSources"])
                    this.deletedSources!.push(SourceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaveSourcesInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveSourcesInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["segmentID"] = this.segmentID;
        if (Array.isArray(this.addedSources)) {
            data["addedSources"] = [];
            for (let item of this.addedSources)
                data["addedSources"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedSources)) {
            data["deletedSources"] = [];
            for (let item of this.deletedSources)
                data["deletedSources"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISaveSourcesInputDto {
    segmentID: number | undefined;
    addedSources: SourceDto[] | undefined;
    deletedSources: SourceDto[] | undefined;
}

export class GetSegmentPrevOrdersForViewDto implements IGetSegmentPrevOrdersForViewDto {
    description!: string | undefined;
    orderNo!: string | undefined;
    company!: string | undefined;
    cIndividualOrCompany!: string | undefined;
    cIncludeOrExclude!: string | undefined;
    orderStatusCreatedDate!: moment.Moment | undefined;
    action!: ActionType | undefined;
    previousOrderID!: number | undefined;
    orderID!: number | undefined;
    prevSegmentIDs!: string | undefined;
    cLVAOrderNo!: string | undefined;
    cMatchFieldName!: string | undefined;
    cMatchFieldDescription!: string | undefined;
    buildId!: number | undefined;

    constructor(data?: IGetSegmentPrevOrdersForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.orderNo = data["orderNo"];
            this.company = data["company"];
            this.cIndividualOrCompany = data["cIndividualOrCompany"];
            this.cIncludeOrExclude = data["cIncludeOrExclude"];
            this.orderStatusCreatedDate = data["orderStatusCreatedDate"] ? moment(data["orderStatusCreatedDate"].toString()) : <any>undefined;
            this.action = data["action"];
            this.previousOrderID = data["previousOrderID"];
            this.orderID = data["orderID"];
            this.prevSegmentIDs = data["prevSegmentIDs"];
            this.cLVAOrderNo = data["cLVAOrderNo"];
            this.cMatchFieldName = data["cMatchFieldName"];
            this.cMatchFieldDescription = data["cMatchFieldDescription"];
            this.buildId = data["buildId"];
        }
    }

    static fromJS(data: any): GetSegmentPrevOrdersForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSegmentPrevOrdersForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["orderNo"] = this.orderNo;
        data["company"] = this.company;
        data["cIndividualOrCompany"] = this.cIndividualOrCompany;
        data["cIncludeOrExclude"] = this.cIncludeOrExclude;
        data["orderStatusCreatedDate"] = this.orderStatusCreatedDate ? this.orderStatusCreatedDate.toISOString() : <any>undefined;
        data["action"] = this.action;
        data["previousOrderID"] = this.previousOrderID;
        data["orderID"] = this.orderID;
        data["prevSegmentIDs"] = this.prevSegmentIDs;
        data["cLVAOrderNo"] = this.cLVAOrderNo;
        data["cMatchFieldName"] = this.cMatchFieldName;
        data["cMatchFieldDescription"] = this.cMatchFieldDescription;
        data["buildId"] = this.buildId;
        return data; 
    }
}

export interface IGetSegmentPrevOrdersForViewDto {
    description: string | undefined;
    orderNo: string | undefined;
    company: string | undefined;
    cIndividualOrCompany: string | undefined;
    cIncludeOrExclude: string | undefined;
    orderStatusCreatedDate: moment.Moment | undefined;
    action: ActionType | undefined;
    previousOrderID: number | undefined;
    orderID: number | undefined;
    prevSegmentIDs: string | undefined;
    cLVAOrderNo: string | undefined;
    cMatchFieldName: string | undefined;
    cMatchFieldDescription: string | undefined;
    buildId: number | undefined;
}

export class SegmentPrevOrdersView implements ISegmentPrevOrdersView {
    currentStatus!: number | undefined;
    listOfSegmentPrevOrders!: GetSegmentPrevOrdersForViewDto[] | undefined;

    constructor(data?: ISegmentPrevOrdersView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentStatus = data["currentStatus"];
            if (Array.isArray(data["listOfSegmentPrevOrders"])) {
                this.listOfSegmentPrevOrders = [] as any;
                for (let item of data["listOfSegmentPrevOrders"])
                    this.listOfSegmentPrevOrders!.push(GetSegmentPrevOrdersForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SegmentPrevOrdersView {
        data = typeof data === 'object' ? data : {};
        let result = new SegmentPrevOrdersView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentStatus"] = this.currentStatus;
        if (Array.isArray(this.listOfSegmentPrevOrders)) {
            data["listOfSegmentPrevOrders"] = [];
            for (let item of this.listOfSegmentPrevOrders)
                data["listOfSegmentPrevOrders"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISegmentPrevOrdersView {
    currentStatus: number | undefined;
    listOfSegmentPrevOrders: GetSegmentPrevOrdersForViewDto[] | undefined;
}

export class CreateOrEditSegmentPrevOrdersDto implements ICreateOrEditSegmentPrevOrdersDto {
    campaignID!: number | undefined;
    listOfSegmentOrders!: SegmentPrevOrdersDto[] | undefined;

    constructor(data?: ICreateOrEditSegmentPrevOrdersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignID = data["campaignID"];
            if (Array.isArray(data["listOfSegmentOrders"])) {
                this.listOfSegmentOrders = [] as any;
                for (let item of data["listOfSegmentOrders"])
                    this.listOfSegmentOrders!.push(SegmentPrevOrdersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrEditSegmentPrevOrdersDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSegmentPrevOrdersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignID"] = this.campaignID;
        if (Array.isArray(this.listOfSegmentOrders)) {
            data["listOfSegmentOrders"] = [];
            for (let item of this.listOfSegmentOrders)
                data["listOfSegmentOrders"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateOrEditSegmentPrevOrdersDto {
    campaignID: number | undefined;
    listOfSegmentOrders: SegmentPrevOrdersDto[] | undefined;
}

export class SegmentPrevOrdersDto implements ISegmentPrevOrdersDto {
    prevOrderID!: number | undefined;
    cIncludeExclude!: string | undefined;
    cPrevSegmentID!: string | undefined;
    cPrevSegmentNumber!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    cCompanyFieldName!: string | undefined;
    segmentId!: number | undefined;
    action!: ActionType | undefined;
    cMatchFieldName!: string | undefined;
    cMatchFieldDescription!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISegmentPrevOrdersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.prevOrderID = data["prevOrderID"];
            this.cIncludeExclude = data["cIncludeExclude"];
            this.cPrevSegmentID = data["cPrevSegmentID"];
            this.cPrevSegmentNumber = data["cPrevSegmentNumber"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.cCompanyFieldName = data["cCompanyFieldName"];
            this.segmentId = data["segmentId"];
            this.action = data["action"];
            this.cMatchFieldName = data["cMatchFieldName"];
            this.cMatchFieldDescription = data["cMatchFieldDescription"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SegmentPrevOrdersDto {
        data = typeof data === 'object' ? data : {};
        let result = new SegmentPrevOrdersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prevOrderID"] = this.prevOrderID;
        data["cIncludeExclude"] = this.cIncludeExclude;
        data["cPrevSegmentID"] = this.cPrevSegmentID;
        data["cPrevSegmentNumber"] = this.cPrevSegmentNumber;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["cCompanyFieldName"] = this.cCompanyFieldName;
        data["segmentId"] = this.segmentId;
        data["action"] = this.action;
        data["cMatchFieldName"] = this.cMatchFieldName;
        data["cMatchFieldDescription"] = this.cMatchFieldDescription;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISegmentPrevOrdersDto {
    prevOrderID: number | undefined;
    cIncludeExclude: string | undefined;
    cPrevSegmentID: string | undefined;
    cPrevSegmentNumber: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    cCompanyFieldName: string | undefined;
    segmentId: number | undefined;
    action: ActionType | undefined;
    cMatchFieldName: string | undefined;
    cMatchFieldDescription: string | undefined;
    id: number | undefined;
}

export class SegmentDataPreviewDto implements ISegmentDataPreviewDto {
    columns!: DropdownOutputDto[] | undefined;
    data!: string | undefined;
    dataForExport!: any | undefined;
    isExportLayoutCheckBoxVisible!: boolean | undefined;
    description!: string | undefined;
    tooltipDescription!: string | undefined;

    constructor(data?: ISegmentDataPreviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["columns"])) {
                this.columns = [] as any;
                for (let item of data["columns"])
                    this.columns!.push(DropdownOutputDto.fromJS(item));
            }
            this.data = data["data"];
            this.dataForExport = data["dataForExport"];
            this.isExportLayoutCheckBoxVisible = data["isExportLayoutCheckBoxVisible"];
            this.description = data["description"];
            this.tooltipDescription = data["tooltipDescription"];
        }
    }

    static fromJS(data: any): SegmentDataPreviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new SegmentDataPreviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        data["data"] = this.data;
        data["dataForExport"] = this.dataForExport;
        data["isExportLayoutCheckBoxVisible"] = this.isExportLayoutCheckBoxVisible;
        data["description"] = this.description;
        data["tooltipDescription"] = this.tooltipDescription;
        return data; 
    }
}

export interface ISegmentDataPreviewDto {
    columns: DropdownOutputDto[] | undefined;
    data: string | undefined;
    dataForExport: any | undefined;
    isExportLayoutCheckBoxVisible: boolean | undefined;
    description: string | undefined;
    tooltipDescription: string | undefined;
}

export class GetAllSegmentForCampaign implements IGetAllSegmentForCampaign {
    pagedSegments!: PagedResultDtoOfGetSegmentListForView | undefined;
    currentStatus!: number | undefined;

    constructor(data?: IGetAllSegmentForCampaign) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pagedSegments = data["pagedSegments"] ? PagedResultDtoOfGetSegmentListForView.fromJS(data["pagedSegments"]) : <any>undefined;
            this.currentStatus = data["currentStatus"];
        }
    }

    static fromJS(data: any): GetAllSegmentForCampaign {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSegmentForCampaign();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pagedSegments"] = this.pagedSegments ? this.pagedSegments.toJSON() : <any>undefined;
        data["currentStatus"] = this.currentStatus;
        return data; 
    }
}

export interface IGetAllSegmentForCampaign {
    pagedSegments: PagedResultDtoOfGetSegmentListForView | undefined;
    currentStatus: number | undefined;
}

export class PagedResultDtoOfGetSegmentListForView implements IPagedResultDtoOfGetSegmentListForView {
    totalCount!: number | undefined;
    items!: GetSegmentListForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSegmentListForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSegmentListForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSegmentListForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSegmentListForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetSegmentListForView {
    totalCount: number | undefined;
    items: GetSegmentListForView[] | undefined;
}

export class GetSegmentListForView implements IGetSegmentListForView {
    id!: number | undefined;
    description!: string | undefined;
    cMaxPerGroup!: string | undefined;
    iProvidedQty!: number | undefined;
    iRequiredQty!: number | undefined;
    iOutputQty!: number | undefined;
    iAvailableQty!: number | undefined;
    iDedupeOrderSpecified!: number | undefined;
    cKeyCode1!: string | undefined;
    cKeyCode2!: string | undefined;
    cFieldDescription!: string | undefined;
    cFieldName!: string | undefined;
    orderId!: number | undefined;
    iGroup!: number | undefined;

    constructor(data?: IGetSegmentListForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.description = data["description"];
            this.cMaxPerGroup = data["cMaxPerGroup"];
            this.iProvidedQty = data["iProvidedQty"];
            this.iRequiredQty = data["iRequiredQty"];
            this.iOutputQty = data["iOutputQty"];
            this.iAvailableQty = data["iAvailableQty"];
            this.iDedupeOrderSpecified = data["iDedupeOrderSpecified"];
            this.cKeyCode1 = data["cKeyCode1"];
            this.cKeyCode2 = data["cKeyCode2"];
            this.cFieldDescription = data["cFieldDescription"];
            this.cFieldName = data["cFieldName"];
            this.orderId = data["orderId"];
            this.iGroup = data["iGroup"];
        }
    }

    static fromJS(data: any): GetSegmentListForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetSegmentListForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["cMaxPerGroup"] = this.cMaxPerGroup;
        data["iProvidedQty"] = this.iProvidedQty;
        data["iRequiredQty"] = this.iRequiredQty;
        data["iOutputQty"] = this.iOutputQty;
        data["iAvailableQty"] = this.iAvailableQty;
        data["iDedupeOrderSpecified"] = this.iDedupeOrderSpecified;
        data["cKeyCode1"] = this.cKeyCode1;
        data["cKeyCode2"] = this.cKeyCode2;
        data["cFieldDescription"] = this.cFieldDescription;
        data["cFieldName"] = this.cFieldName;
        data["orderId"] = this.orderId;
        data["iGroup"] = this.iGroup;
        return data; 
    }
}

export interface IGetSegmentListForView {
    id: number | undefined;
    description: string | undefined;
    cMaxPerGroup: string | undefined;
    iProvidedQty: number | undefined;
    iRequiredQty: number | undefined;
    iOutputQty: number | undefined;
    iAvailableQty: number | undefined;
    iDedupeOrderSpecified: number | undefined;
    cKeyCode1: string | undefined;
    cKeyCode2: string | undefined;
    cFieldDescription: string | undefined;
    cFieldName: string | undefined;
    orderId: number | undefined;
    iGroup: number | undefined;
}

export class GetAllSegmentsDropdownOutputDto implements IGetAllSegmentsDropdownOutputDto {
    segmentDropDown!: DropdownOutputDto[] | undefined;
    currentStatus!: number | undefined;
    isQuickCountButtonVisible!: boolean | undefined;
    isSICScreenConfigured!: boolean | undefined;
    isOccupationScreenConfigured!: boolean | undefined;
    isCountyCityScreenConfigured!: boolean | undefined;
    isGeoSearchConfigured!: boolean | undefined;
    defaultMaxPerValue!: string | undefined;

    constructor(data?: IGetAllSegmentsDropdownOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["segmentDropDown"])) {
                this.segmentDropDown = [] as any;
                for (let item of data["segmentDropDown"])
                    this.segmentDropDown!.push(DropdownOutputDto.fromJS(item));
            }
            this.currentStatus = data["currentStatus"];
            this.isQuickCountButtonVisible = data["isQuickCountButtonVisible"];
            this.isSICScreenConfigured = data["isSICScreenConfigured"];
            this.isOccupationScreenConfigured = data["isOccupationScreenConfigured"];
            this.isCountyCityScreenConfigured = data["isCountyCityScreenConfigured"];
            this.isGeoSearchConfigured = data["isGeoSearchConfigured"];
            this.defaultMaxPerValue = data["defaultMaxPerValue"];
        }
    }

    static fromJS(data: any): GetAllSegmentsDropdownOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSegmentsDropdownOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.segmentDropDown)) {
            data["segmentDropDown"] = [];
            for (let item of this.segmentDropDown)
                data["segmentDropDown"].push(item.toJSON());
        }
        data["currentStatus"] = this.currentStatus;
        data["isQuickCountButtonVisible"] = this.isQuickCountButtonVisible;
        data["isSICScreenConfigured"] = this.isSICScreenConfigured;
        data["isOccupationScreenConfigured"] = this.isOccupationScreenConfigured;
        data["isCountyCityScreenConfigured"] = this.isCountyCityScreenConfigured;
        data["isGeoSearchConfigured"] = this.isGeoSearchConfigured;
        data["defaultMaxPerValue"] = this.defaultMaxPerValue;
        return data; 
    }
}

export interface IGetAllSegmentsDropdownOutputDto {
    segmentDropDown: DropdownOutputDto[] | undefined;
    currentStatus: number | undefined;
    isQuickCountButtonVisible: boolean | undefined;
    isSICScreenConfigured: boolean | undefined;
    isOccupationScreenConfigured: boolean | undefined;
    isCountyCityScreenConfigured: boolean | undefined;
    isGeoSearchConfigured: boolean | undefined;
    defaultMaxPerValue: string | undefined;
}

export class CreateOrEditSegmentDto implements ICreateOrEditSegmentDto {
    orderId!: number | undefined;
    cDescription!: string;
    iUseAutosuppress!: boolean | undefined;
    cKeyCode1!: string | undefined;
    cKeyCode2!: string | undefined;
    iRequiredQty!: number | undefined;
    iProvidedQty!: number | undefined;
    iDedupeOrderSpecified!: number | undefined;
    iDedupeOrderUsed!: number | undefined;
    cMaxPerGroup!: string | undefined;
    cTitleSuppression!: string | undefined;
    cFixedTitle!: string | undefined;
    iDoubleMultiBuyerCount!: number | undefined;
    iIsOrderLevel!: boolean | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    iGroup!: number | undefined;
    iOutputQty!: number | undefined;
    iAvailableQty!: number | undefined;
    iIsRandomRadiusNth!: boolean | undefined;
    cFieldDescription!: string | undefined;
    applyDefaultRules!: boolean | undefined;
    iIsCalculateDistance!: boolean | undefined;
    cNthPriorityField!: string | undefined;
    cNthPriorityFieldDescription!: string | undefined;
    cNthPriorityFieldOrder!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditSegmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.cDescription = data["cDescription"];
            this.iUseAutosuppress = data["iUseAutosuppress"];
            this.cKeyCode1 = data["cKeyCode1"];
            this.cKeyCode2 = data["cKeyCode2"];
            this.iRequiredQty = data["iRequiredQty"];
            this.iProvidedQty = data["iProvidedQty"];
            this.iDedupeOrderSpecified = data["iDedupeOrderSpecified"];
            this.iDedupeOrderUsed = data["iDedupeOrderUsed"];
            this.cMaxPerGroup = data["cMaxPerGroup"];
            this.cTitleSuppression = data["cTitleSuppression"];
            this.cFixedTitle = data["cFixedTitle"];
            this.iDoubleMultiBuyerCount = data["iDoubleMultiBuyerCount"];
            this.iIsOrderLevel = data["iIsOrderLevel"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.iGroup = data["iGroup"];
            this.iOutputQty = data["iOutputQty"];
            this.iAvailableQty = data["iAvailableQty"];
            this.iIsRandomRadiusNth = data["iIsRandomRadiusNth"];
            this.cFieldDescription = data["cFieldDescription"];
            this.applyDefaultRules = data["applyDefaultRules"];
            this.iIsCalculateDistance = data["iIsCalculateDistance"];
            this.cNthPriorityField = data["cNthPriorityField"];
            this.cNthPriorityFieldDescription = data["cNthPriorityFieldDescription"];
            this.cNthPriorityFieldOrder = data["cNthPriorityFieldOrder"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSegmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSegmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["cDescription"] = this.cDescription;
        data["iUseAutosuppress"] = this.iUseAutosuppress;
        data["cKeyCode1"] = this.cKeyCode1;
        data["cKeyCode2"] = this.cKeyCode2;
        data["iRequiredQty"] = this.iRequiredQty;
        data["iProvidedQty"] = this.iProvidedQty;
        data["iDedupeOrderSpecified"] = this.iDedupeOrderSpecified;
        data["iDedupeOrderUsed"] = this.iDedupeOrderUsed;
        data["cMaxPerGroup"] = this.cMaxPerGroup;
        data["cTitleSuppression"] = this.cTitleSuppression;
        data["cFixedTitle"] = this.cFixedTitle;
        data["iDoubleMultiBuyerCount"] = this.iDoubleMultiBuyerCount;
        data["iIsOrderLevel"] = this.iIsOrderLevel;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["iGroup"] = this.iGroup;
        data["iOutputQty"] = this.iOutputQty;
        data["iAvailableQty"] = this.iAvailableQty;
        data["iIsRandomRadiusNth"] = this.iIsRandomRadiusNth;
        data["cFieldDescription"] = this.cFieldDescription;
        data["applyDefaultRules"] = this.applyDefaultRules;
        data["iIsCalculateDistance"] = this.iIsCalculateDistance;
        data["cNthPriorityField"] = this.cNthPriorityField;
        data["cNthPriorityFieldDescription"] = this.cNthPriorityFieldDescription;
        data["cNthPriorityFieldOrder"] = this.cNthPriorityFieldOrder;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditSegmentDto {
    orderId: number | undefined;
    cDescription: string;
    iUseAutosuppress: boolean | undefined;
    cKeyCode1: string | undefined;
    cKeyCode2: string | undefined;
    iRequiredQty: number | undefined;
    iProvidedQty: number | undefined;
    iDedupeOrderSpecified: number | undefined;
    iDedupeOrderUsed: number | undefined;
    cMaxPerGroup: string | undefined;
    cTitleSuppression: string | undefined;
    cFixedTitle: string | undefined;
    iDoubleMultiBuyerCount: number | undefined;
    iIsOrderLevel: boolean | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    iGroup: number | undefined;
    iOutputQty: number | undefined;
    iAvailableQty: number | undefined;
    iIsRandomRadiusNth: boolean | undefined;
    cFieldDescription: string | undefined;
    applyDefaultRules: boolean | undefined;
    iIsCalculateDistance: boolean | undefined;
    cNthPriorityField: string | undefined;
    cNthPriorityFieldDescription: string | undefined;
    cNthPriorityFieldOrder: string | undefined;
    id: number | undefined;
}

export class CreateOrEditSegmentOutputDto implements ICreateOrEditSegmentOutputDto {
    id!: number | undefined;
    newStatus!: number | undefined;

    constructor(data?: ICreateOrEditSegmentOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newStatus = data["newStatus"];
        }
    }

    static fromJS(data: any): CreateOrEditSegmentOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSegmentOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newStatus"] = this.newStatus;
        return data; 
    }
}

export interface ICreateOrEditSegmentOutputDto {
    id: number | undefined;
    newStatus: number | undefined;
}

export class CopySegmentDto implements ICopySegmentDto {
    iSegmentId!: number | undefined;
    iCampaignId!: number | undefined;
    iMaxDedupeId!: number | undefined;
    iCopyToOrderID!: number | undefined;
    iCopyFromOrderID!: number | undefined;
    iSegmentFrom!: number | undefined;
    iSegmentTo!: number | undefined;
    sInitiatedBy!: string | undefined;
    sCommaSeparatedSegments!: string | undefined;
    cCopyMode!: string | undefined;
    iNumberOfCopies!: number | undefined;
    cSegmentDescription!: string | undefined;
    cKeyCode1!: string | undefined;
    cKeyCode2!: string | undefined;
    cmaxPer!: string | undefined;
    iGroup!: number | undefined;
    iRequiredQty!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICopySegmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.iSegmentId = data["iSegmentId"];
            this.iCampaignId = data["iCampaignId"];
            this.iMaxDedupeId = data["iMaxDedupeId"];
            this.iCopyToOrderID = data["iCopyToOrderID"];
            this.iCopyFromOrderID = data["iCopyFromOrderID"];
            this.iSegmentFrom = data["iSegmentFrom"];
            this.iSegmentTo = data["iSegmentTo"];
            this.sInitiatedBy = data["sInitiatedBy"];
            this.sCommaSeparatedSegments = data["sCommaSeparatedSegments"];
            this.cCopyMode = data["cCopyMode"];
            this.iNumberOfCopies = data["iNumberOfCopies"];
            this.cSegmentDescription = data["cSegmentDescription"];
            this.cKeyCode1 = data["cKeyCode1"];
            this.cKeyCode2 = data["cKeyCode2"];
            this.cmaxPer = data["cmaxPer"];
            this.iGroup = data["iGroup"];
            this.iRequiredQty = data["iRequiredQty"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CopySegmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CopySegmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iSegmentId"] = this.iSegmentId;
        data["iCampaignId"] = this.iCampaignId;
        data["iMaxDedupeId"] = this.iMaxDedupeId;
        data["iCopyToOrderID"] = this.iCopyToOrderID;
        data["iCopyFromOrderID"] = this.iCopyFromOrderID;
        data["iSegmentFrom"] = this.iSegmentFrom;
        data["iSegmentTo"] = this.iSegmentTo;
        data["sInitiatedBy"] = this.sInitiatedBy;
        data["sCommaSeparatedSegments"] = this.sCommaSeparatedSegments;
        data["cCopyMode"] = this.cCopyMode;
        data["iNumberOfCopies"] = this.iNumberOfCopies;
        data["cSegmentDescription"] = this.cSegmentDescription;
        data["cKeyCode1"] = this.cKeyCode1;
        data["cKeyCode2"] = this.cKeyCode2;
        data["cmaxPer"] = this.cmaxPer;
        data["iGroup"] = this.iGroup;
        data["iRequiredQty"] = this.iRequiredQty;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICopySegmentDto {
    iSegmentId: number | undefined;
    iCampaignId: number | undefined;
    iMaxDedupeId: number | undefined;
    iCopyToOrderID: number | undefined;
    iCopyFromOrderID: number | undefined;
    iSegmentFrom: number | undefined;
    iSegmentTo: number | undefined;
    sInitiatedBy: string | undefined;
    sCommaSeparatedSegments: string | undefined;
    cCopyMode: string | undefined;
    iNumberOfCopies: number | undefined;
    cSegmentDescription: string | undefined;
    cKeyCode1: string | undefined;
    cKeyCode2: string | undefined;
    cmaxPer: string | undefined;
    iGroup: number | undefined;
    iRequiredQty: number | undefined;
    id: number | undefined;
}

export class ImportSegmentDTO implements IImportSegmentDTO {
    iCopyToCampaignID!: number | undefined;
    iCopyFromCampaignID!: number | undefined;
    sCommaSeparatedSegments!: string | undefined;
    cSegmentDescription!: string | undefined;
    numberOfSegments!: number | undefined;
    isValid!: boolean | undefined;

    constructor(data?: IImportSegmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.iCopyToCampaignID = data["iCopyToCampaignID"];
            this.iCopyFromCampaignID = data["iCopyFromCampaignID"];
            this.sCommaSeparatedSegments = data["sCommaSeparatedSegments"];
            this.cSegmentDescription = data["cSegmentDescription"];
            this.numberOfSegments = data["numberOfSegments"];
            this.isValid = data["isValid"];
        }
    }

    static fromJS(data: any): ImportSegmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ImportSegmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iCopyToCampaignID"] = this.iCopyToCampaignID;
        data["iCopyFromCampaignID"] = this.iCopyFromCampaignID;
        data["sCommaSeparatedSegments"] = this.sCommaSeparatedSegments;
        data["cSegmentDescription"] = this.cSegmentDescription;
        data["numberOfSegments"] = this.numberOfSegments;
        data["isValid"] = this.isValid;
        return data; 
    }
}

export interface IImportSegmentDTO {
    iCopyToCampaignID: number | undefined;
    iCopyFromCampaignID: number | undefined;
    sCommaSeparatedSegments: string | undefined;
    cSegmentDescription: string | undefined;
    numberOfSegments: number | undefined;
    isValid: boolean | undefined;
}

export class BatchEditSegmentDto implements IBatchEditSegmentDto {
    index!: number | undefined;
    dirty!: boolean | undefined;
    nextStatus!: number | undefined;
    iDisplayOutputQty!: number | undefined;
    orderId!: number | undefined;
    cDescription!: string;
    iUseAutosuppress!: boolean | undefined;
    cKeyCode1!: string | undefined;
    cKeyCode2!: string | undefined;
    iRequiredQty!: number | undefined;
    iProvidedQty!: number | undefined;
    iDedupeOrderSpecified!: number | undefined;
    iDedupeOrderUsed!: number | undefined;
    cMaxPerGroup!: string | undefined;
    cTitleSuppression!: string | undefined;
    cFixedTitle!: string | undefined;
    iDoubleMultiBuyerCount!: number | undefined;
    iIsOrderLevel!: boolean | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    iGroup!: number | undefined;
    iOutputQty!: number | undefined;
    iAvailableQty!: number | undefined;
    iIsRandomRadiusNth!: boolean | undefined;
    cFieldDescription!: string | undefined;
    applyDefaultRules!: boolean | undefined;
    iIsCalculateDistance!: boolean | undefined;
    cNthPriorityField!: string | undefined;
    cNthPriorityFieldDescription!: string | undefined;
    cNthPriorityFieldOrder!: string | undefined;
    id!: number | undefined;

    constructor(data?: IBatchEditSegmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.index = data["index"];
            this.dirty = data["dirty"];
            this.nextStatus = data["nextStatus"];
            this.iDisplayOutputQty = data["iDisplayOutputQty"];
            this.orderId = data["orderId"];
            this.cDescription = data["cDescription"];
            this.iUseAutosuppress = data["iUseAutosuppress"];
            this.cKeyCode1 = data["cKeyCode1"];
            this.cKeyCode2 = data["cKeyCode2"];
            this.iRequiredQty = data["iRequiredQty"];
            this.iProvidedQty = data["iProvidedQty"];
            this.iDedupeOrderSpecified = data["iDedupeOrderSpecified"];
            this.iDedupeOrderUsed = data["iDedupeOrderUsed"];
            this.cMaxPerGroup = data["cMaxPerGroup"];
            this.cTitleSuppression = data["cTitleSuppression"];
            this.cFixedTitle = data["cFixedTitle"];
            this.iDoubleMultiBuyerCount = data["iDoubleMultiBuyerCount"];
            this.iIsOrderLevel = data["iIsOrderLevel"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.iGroup = data["iGroup"];
            this.iOutputQty = data["iOutputQty"];
            this.iAvailableQty = data["iAvailableQty"];
            this.iIsRandomRadiusNth = data["iIsRandomRadiusNth"];
            this.cFieldDescription = data["cFieldDescription"];
            this.applyDefaultRules = data["applyDefaultRules"];
            this.iIsCalculateDistance = data["iIsCalculateDistance"];
            this.cNthPriorityField = data["cNthPriorityField"];
            this.cNthPriorityFieldDescription = data["cNthPriorityFieldDescription"];
            this.cNthPriorityFieldOrder = data["cNthPriorityFieldOrder"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BatchEditSegmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatchEditSegmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["dirty"] = this.dirty;
        data["nextStatus"] = this.nextStatus;
        data["iDisplayOutputQty"] = this.iDisplayOutputQty;
        data["orderId"] = this.orderId;
        data["cDescription"] = this.cDescription;
        data["iUseAutosuppress"] = this.iUseAutosuppress;
        data["cKeyCode1"] = this.cKeyCode1;
        data["cKeyCode2"] = this.cKeyCode2;
        data["iRequiredQty"] = this.iRequiredQty;
        data["iProvidedQty"] = this.iProvidedQty;
        data["iDedupeOrderSpecified"] = this.iDedupeOrderSpecified;
        data["iDedupeOrderUsed"] = this.iDedupeOrderUsed;
        data["cMaxPerGroup"] = this.cMaxPerGroup;
        data["cTitleSuppression"] = this.cTitleSuppression;
        data["cFixedTitle"] = this.cFixedTitle;
        data["iDoubleMultiBuyerCount"] = this.iDoubleMultiBuyerCount;
        data["iIsOrderLevel"] = this.iIsOrderLevel;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["iGroup"] = this.iGroup;
        data["iOutputQty"] = this.iOutputQty;
        data["iAvailableQty"] = this.iAvailableQty;
        data["iIsRandomRadiusNth"] = this.iIsRandomRadiusNth;
        data["cFieldDescription"] = this.cFieldDescription;
        data["applyDefaultRules"] = this.applyDefaultRules;
        data["iIsCalculateDistance"] = this.iIsCalculateDistance;
        data["cNthPriorityField"] = this.cNthPriorityField;
        data["cNthPriorityFieldDescription"] = this.cNthPriorityFieldDescription;
        data["cNthPriorityFieldOrder"] = this.cNthPriorityFieldOrder;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBatchEditSegmentDto {
    index: number | undefined;
    dirty: boolean | undefined;
    nextStatus: number | undefined;
    iDisplayOutputQty: number | undefined;
    orderId: number | undefined;
    cDescription: string;
    iUseAutosuppress: boolean | undefined;
    cKeyCode1: string | undefined;
    cKeyCode2: string | undefined;
    iRequiredQty: number | undefined;
    iProvidedQty: number | undefined;
    iDedupeOrderSpecified: number | undefined;
    iDedupeOrderUsed: number | undefined;
    cMaxPerGroup: string | undefined;
    cTitleSuppression: string | undefined;
    cFixedTitle: string | undefined;
    iDoubleMultiBuyerCount: number | undefined;
    iIsOrderLevel: boolean | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    iGroup: number | undefined;
    iOutputQty: number | undefined;
    iAvailableQty: number | undefined;
    iIsRandomRadiusNth: boolean | undefined;
    cFieldDescription: string | undefined;
    applyDefaultRules: boolean | undefined;
    iIsCalculateDistance: boolean | undefined;
    cNthPriorityField: string | undefined;
    cNthPriorityFieldDescription: string | undefined;
    cNthPriorityFieldOrder: string | undefined;
    id: number | undefined;
}

export class GetInitialStateForBatchEdit implements IGetInitialStateForBatchEdit {
    isCalculateDistanceSet!: boolean | undefined;
    hasDefaultRules!: boolean | undefined;
    maxPers!: DropdownOutputDto[] | undefined;

    constructor(data?: IGetInitialStateForBatchEdit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isCalculateDistanceSet = data["isCalculateDistanceSet"];
            this.hasDefaultRules = data["hasDefaultRules"];
            if (Array.isArray(data["maxPers"])) {
                this.maxPers = [] as any;
                for (let item of data["maxPers"])
                    this.maxPers!.push(DropdownOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetInitialStateForBatchEdit {
        data = typeof data === 'object' ? data : {};
        let result = new GetInitialStateForBatchEdit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isCalculateDistanceSet"] = this.isCalculateDistanceSet;
        data["hasDefaultRules"] = this.hasDefaultRules;
        if (Array.isArray(this.maxPers)) {
            data["maxPers"] = [];
            for (let item of this.maxPers)
                data["maxPers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetInitialStateForBatchEdit {
    isCalculateDistanceSet: boolean | undefined;
    hasDefaultRules: boolean | undefined;
    maxPers: DropdownOutputDto[] | undefined;
}

export class SaveBatchSegmentDto implements ISaveBatchSegmentDto {
    modifiedSegments!: CreateOrEditSegmentDto[] | undefined;
    nextStatus!: number | undefined;

    constructor(data?: ISaveBatchSegmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["modifiedSegments"])) {
                this.modifiedSegments = [] as any;
                for (let item of data["modifiedSegments"])
                    this.modifiedSegments!.push(CreateOrEditSegmentDto.fromJS(item));
            }
            this.nextStatus = data["nextStatus"];
        }
    }

    static fromJS(data: any): SaveBatchSegmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveBatchSegmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.modifiedSegments)) {
            data["modifiedSegments"] = [];
            for (let item of this.modifiedSegments)
                data["modifiedSegments"].push(item.toJSON());
        }
        data["nextStatus"] = this.nextStatus;
        return data; 
    }
}

export interface ISaveBatchSegmentDto {
    modifiedSegments: CreateOrEditSegmentDto[] | undefined;
    nextStatus: number | undefined;
}

export class BulkSegmentDto implements IBulkSegmentDto {
    campaignId!: number | undefined;
    isDefaultFormat!: boolean | undefined;
    isPopulateKeycode!: boolean | undefined;
    isGroupByKeyCode1!: boolean | undefined;
    path!: string | undefined;
    databaseId!: number | undefined;

    constructor(data?: IBulkSegmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignId = data["campaignId"];
            this.isDefaultFormat = data["isDefaultFormat"];
            this.isPopulateKeycode = data["isPopulateKeycode"];
            this.isGroupByKeyCode1 = data["isGroupByKeyCode1"];
            this.path = data["path"];
            this.databaseId = data["databaseId"];
        }
    }

    static fromJS(data: any): BulkSegmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkSegmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["isDefaultFormat"] = this.isDefaultFormat;
        data["isPopulateKeycode"] = this.isPopulateKeycode;
        data["isGroupByKeyCode1"] = this.isGroupByKeyCode1;
        data["path"] = this.path;
        data["databaseId"] = this.databaseId;
        return data; 
    }
}

export interface IBulkSegmentDto {
    campaignId: number | undefined;
    isDefaultFormat: boolean | undefined;
    isPopulateKeycode: boolean | undefined;
    isGroupByKeyCode1: boolean | undefined;
    path: string | undefined;
    databaseId: number | undefined;
}

export class GlobalChangesDto implements IGlobalChangesDto {
    pagedSegments!: PagedResultDtoOfSegmentsGlobalChangesDto | undefined;
    finalFilterText!: string | undefined;

    constructor(data?: IGlobalChangesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pagedSegments = data["pagedSegments"] ? PagedResultDtoOfSegmentsGlobalChangesDto.fromJS(data["pagedSegments"]) : <any>undefined;
            this.finalFilterText = data["finalFilterText"];
        }
    }

    static fromJS(data: any): GlobalChangesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GlobalChangesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pagedSegments"] = this.pagedSegments ? this.pagedSegments.toJSON() : <any>undefined;
        data["finalFilterText"] = this.finalFilterText;
        return data; 
    }
}

export interface IGlobalChangesDto {
    pagedSegments: PagedResultDtoOfSegmentsGlobalChangesDto | undefined;
    finalFilterText: string | undefined;
}

export class PagedResultDtoOfSegmentsGlobalChangesDto implements IPagedResultDtoOfSegmentsGlobalChangesDto {
    totalCount!: number | undefined;
    items!: SegmentsGlobalChangesDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSegmentsGlobalChangesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SegmentsGlobalChangesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSegmentsGlobalChangesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSegmentsGlobalChangesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSegmentsGlobalChangesDto {
    totalCount: number | undefined;
    items: SegmentsGlobalChangesDto[] | undefined;
}

export class SegmentsGlobalChangesDto implements ISegmentsGlobalChangesDto {
    cDescription!: string | undefined;
    cKeyCode1!: string | undefined;
    iRequiredQty!: number | undefined;
    iProvidedQty!: number | undefined;
    iDedupeOrderSpecified!: number | undefined;
    iAvailableQty!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISegmentsGlobalChangesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cDescription = data["cDescription"];
            this.cKeyCode1 = data["cKeyCode1"];
            this.iRequiredQty = data["iRequiredQty"];
            this.iProvidedQty = data["iProvidedQty"];
            this.iDedupeOrderSpecified = data["iDedupeOrderSpecified"];
            this.iAvailableQty = data["iAvailableQty"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SegmentsGlobalChangesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SegmentsGlobalChangesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cDescription"] = this.cDescription;
        data["cKeyCode1"] = this.cKeyCode1;
        data["iRequiredQty"] = this.iRequiredQty;
        data["iProvidedQty"] = this.iProvidedQty;
        data["iDedupeOrderSpecified"] = this.iDedupeOrderSpecified;
        data["iAvailableQty"] = this.iAvailableQty;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISegmentsGlobalChangesDto {
    cDescription: string | undefined;
    cKeyCode1: string | undefined;
    iRequiredQty: number | undefined;
    iProvidedQty: number | undefined;
    iDedupeOrderSpecified: number | undefined;
    iAvailableQty: number | undefined;
    id: number | undefined;
}

export class SaveGlobalChangesInputDto implements ISaveGlobalChangesInputDto {
    campaignId!: number | undefined;
    databaseId!: number | undefined;
    divisionId!: number | undefined;
    userID!: string | undefined;
    sourceSegment!: number | undefined;
    action!: string | undefined;
    targetSegments!: string | undefined;
    searchValue!: string | undefined;
    replaceValue!: string | undefined;
    fieldName!: string | undefined;
    compareFieldName!: string | undefined;
    includeExclude!: string | undefined;
    option!: number | undefined;
    filterText!: string | undefined;
    fieldId!: number | undefined;
    fieldDescription!: string | undefined;
    campaignStatus!: CampaignStatus | undefined;

    constructor(data?: ISaveGlobalChangesInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignId = data["campaignId"];
            this.databaseId = data["databaseId"];
            this.divisionId = data["divisionId"];
            this.userID = data["userID"];
            this.sourceSegment = data["sourceSegment"];
            this.action = data["action"];
            this.targetSegments = data["targetSegments"];
            this.searchValue = data["searchValue"];
            this.replaceValue = data["replaceValue"];
            this.fieldName = data["fieldName"];
            this.compareFieldName = data["compareFieldName"];
            this.includeExclude = data["includeExclude"];
            this.option = data["option"];
            this.filterText = data["filterText"];
            this.fieldId = data["fieldId"];
            this.fieldDescription = data["fieldDescription"];
            this.campaignStatus = data["campaignStatus"];
        }
    }

    static fromJS(data: any): SaveGlobalChangesInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveGlobalChangesInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["databaseId"] = this.databaseId;
        data["divisionId"] = this.divisionId;
        data["userID"] = this.userID;
        data["sourceSegment"] = this.sourceSegment;
        data["action"] = this.action;
        data["targetSegments"] = this.targetSegments;
        data["searchValue"] = this.searchValue;
        data["replaceValue"] = this.replaceValue;
        data["fieldName"] = this.fieldName;
        data["compareFieldName"] = this.compareFieldName;
        data["includeExclude"] = this.includeExclude;
        data["option"] = this.option;
        data["filterText"] = this.filterText;
        data["fieldId"] = this.fieldId;
        data["fieldDescription"] = this.fieldDescription;
        data["campaignStatus"] = this.campaignStatus;
        return data; 
    }
}

export interface ISaveGlobalChangesInputDto {
    campaignId: number | undefined;
    databaseId: number | undefined;
    divisionId: number | undefined;
    userID: string | undefined;
    sourceSegment: number | undefined;
    action: string | undefined;
    targetSegments: string | undefined;
    searchValue: string | undefined;
    replaceValue: string | undefined;
    fieldName: string | undefined;
    compareFieldName: string | undefined;
    includeExclude: string | undefined;
    option: number | undefined;
    filterText: string | undefined;
    fieldId: number | undefined;
    fieldDescription: string | undefined;
    campaignStatus: CampaignStatus | undefined;
}

export enum CampaignStatus {
    OrderCreated = 10,
    OrderSubmitted = 20,
    OrderRunning = 30,
    OrderCompleted = 40,
    OrderFailed = 50,
    ReadytoOutput = 60,
    OutputSubmitted = 70,
    OutputRunning = 80,
    OutputCompleted = 90,
    OutputFailed = 100,
    ApprovedforShipping = 110,
    WaitingtoShip = 120,
    Shipped = 130,
    ShippingFailed = 140,
    Cancelled = 150,
}

export class AdvanceSelectionsInputDto implements IAdvanceSelectionsInputDto {
    segmentID!: number | undefined;
    sicFields!: SegmentSelectionDto[] | undefined;
    primarySICField!: SegmentSelectionDto | undefined;

    constructor(data?: IAdvanceSelectionsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.segmentID = data["segmentID"];
            if (Array.isArray(data["sicFields"])) {
                this.sicFields = [] as any;
                for (let item of data["sicFields"])
                    this.sicFields!.push(SegmentSelectionDto.fromJS(item));
            }
            this.primarySICField = data["primarySICField"] ? SegmentSelectionDto.fromJS(data["primarySICField"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdvanceSelectionsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvanceSelectionsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["segmentID"] = this.segmentID;
        if (Array.isArray(this.sicFields)) {
            data["sicFields"] = [];
            for (let item of this.sicFields)
                data["sicFields"].push(item.toJSON());
        }
        data["primarySICField"] = this.primarySICField ? this.primarySICField.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAdvanceSelectionsInputDto {
    segmentID: number | undefined;
    sicFields: SegmentSelectionDto[] | undefined;
    primarySICField: SegmentSelectionDto | undefined;
}

export class SegmentSelectionDto implements ISegmentSelectionDto {
    segmentId!: number | undefined;
    cQuestionFieldName!: string | undefined;
    cQuestionDescription!: string | undefined;
    cJoinOperator!: string | undefined;
    iGroupNumber!: number | undefined;
    iGroupOrder!: number | undefined;
    cGrouping!: string | undefined;
    cValues!: string | undefined;
    cValueMode!: string | undefined;
    cDescriptions!: string | undefined;
    cValueOperator!: string | undefined;
    cFileName!: string | undefined;
    cSystemFileName!: string | undefined;
    cCreatedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cTableName!: string | undefined;
    orderID!: number | undefined;
    isRuleUpdated!: number | undefined;
    isDirectFileUpload!: number | undefined;
    cFieldDescription!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISegmentSelectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.segmentId = data["segmentId"];
            this.cQuestionFieldName = data["cQuestionFieldName"];
            this.cQuestionDescription = data["cQuestionDescription"];
            this.cJoinOperator = data["cJoinOperator"];
            this.iGroupNumber = data["iGroupNumber"];
            this.iGroupOrder = data["iGroupOrder"];
            this.cGrouping = data["cGrouping"];
            this.cValues = data["cValues"];
            this.cValueMode = data["cValueMode"];
            this.cDescriptions = data["cDescriptions"];
            this.cValueOperator = data["cValueOperator"];
            this.cFileName = data["cFileName"];
            this.cSystemFileName = data["cSystemFileName"];
            this.cCreatedBy = data["cCreatedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cTableName = data["cTableName"];
            this.orderID = data["orderID"];
            this.isRuleUpdated = data["isRuleUpdated"];
            this.isDirectFileUpload = data["isDirectFileUpload"];
            this.cFieldDescription = data["cFieldDescription"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SegmentSelectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SegmentSelectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["segmentId"] = this.segmentId;
        data["cQuestionFieldName"] = this.cQuestionFieldName;
        data["cQuestionDescription"] = this.cQuestionDescription;
        data["cJoinOperator"] = this.cJoinOperator;
        data["iGroupNumber"] = this.iGroupNumber;
        data["iGroupOrder"] = this.iGroupOrder;
        data["cGrouping"] = this.cGrouping;
        data["cValues"] = this.cValues;
        data["cValueMode"] = this.cValueMode;
        data["cDescriptions"] = this.cDescriptions;
        data["cValueOperator"] = this.cValueOperator;
        data["cFileName"] = this.cFileName;
        data["cSystemFileName"] = this.cSystemFileName;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cTableName"] = this.cTableName;
        data["orderID"] = this.orderID;
        data["isRuleUpdated"] = this.isRuleUpdated;
        data["isDirectFileUpload"] = this.isDirectFileUpload;
        data["cFieldDescription"] = this.cFieldDescription;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISegmentSelectionDto {
    segmentId: number | undefined;
    cQuestionFieldName: string | undefined;
    cQuestionDescription: string | undefined;
    cJoinOperator: string | undefined;
    iGroupNumber: number | undefined;
    iGroupOrder: number | undefined;
    cGrouping: string | undefined;
    cValues: string | undefined;
    cValueMode: string | undefined;
    cDescriptions: string | undefined;
    cValueOperator: string | undefined;
    cFileName: string | undefined;
    cSystemFileName: string | undefined;
    cCreatedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cTableName: string | undefined;
    orderID: number | undefined;
    isRuleUpdated: number | undefined;
    isDirectFileUpload: number | undefined;
    cFieldDescription: string | undefined;
    id: number | undefined;
}

export class AddressDetailDto implements IAddressDetailDto {
    matchLevel!: number | undefined;
    description!: string | undefined;
    zipCode!: string | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;

    constructor(data?: IAddressDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchLevel = data["matchLevel"];
            this.description = data["description"];
            this.zipCode = data["zipCode"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
        }
    }

    static fromJS(data: any): AddressDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchLevel"] = this.matchLevel;
        data["description"] = this.description;
        data["zipCode"] = this.zipCode;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data; 
    }
}

export interface IAddressDetailDto {
    matchLevel: number | undefined;
    description: string | undefined;
    zipCode: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
}

export class SaveGeoRadiusDto implements ISaveGeoRadiusDto {
    matchLevel!: number | undefined;
    campaignId!: number | undefined;
    databaseId!: number | undefined;
    selection!: SegmentSelectionDto | undefined;

    constructor(data?: ISaveGeoRadiusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchLevel = data["matchLevel"];
            this.campaignId = data["campaignId"];
            this.databaseId = data["databaseId"];
            this.selection = data["selection"] ? SegmentSelectionDto.fromJS(data["selection"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SaveGeoRadiusDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaveGeoRadiusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchLevel"] = this.matchLevel;
        data["campaignId"] = this.campaignId;
        data["databaseId"] = this.databaseId;
        data["selection"] = this.selection ? this.selection.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISaveGeoRadiusDto {
    matchLevel: number | undefined;
    campaignId: number | undefined;
    databaseId: number | undefined;
    selection: SegmentSelectionDto | undefined;
}

export class SegmentSelectionSaveDto implements ISegmentSelectionSaveDto {
    selections!: SegmentSelectionDto[] | undefined;
    campaignId!: number | undefined;
    deletedSelections!: number[] | undefined;
    databaseId!: number | undefined;

    constructor(data?: ISegmentSelectionSaveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["selections"])) {
                this.selections = [] as any;
                for (let item of data["selections"])
                    this.selections!.push(SegmentSelectionDto.fromJS(item));
            }
            this.campaignId = data["campaignId"];
            if (Array.isArray(data["deletedSelections"])) {
                this.deletedSelections = [] as any;
                for (let item of data["deletedSelections"])
                    this.deletedSelections!.push(item);
            }
            this.databaseId = data["databaseId"];
        }
    }

    static fromJS(data: any): SegmentSelectionSaveDto {
        data = typeof data === 'object' ? data : {};
        let result = new SegmentSelectionSaveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.selections)) {
            data["selections"] = [];
            for (let item of this.selections)
                data["selections"].push(item.toJSON());
        }
        data["campaignId"] = this.campaignId;
        if (Array.isArray(this.deletedSelections)) {
            data["deletedSelections"] = [];
            for (let item of this.deletedSelections)
                data["deletedSelections"].push(item);
        }
        data["databaseId"] = this.databaseId;
        return data; 
    }
}

export interface ISegmentSelectionSaveDto {
    selections: SegmentSelectionDto[] | undefined;
    campaignId: number | undefined;
    deletedSelections: number[] | undefined;
    databaseId: number | undefined;
}

export class GetQueryBuilderDetails implements IGetQueryBuilderDetails {
    filterDetails!: string | undefined;
    filterQuery!: string | undefined;
    unMappedFilters!: string | undefined;
    buildLolId!: number | undefined;

    constructor(data?: IGetQueryBuilderDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filterDetails = data["filterDetails"];
            this.filterQuery = data["filterQuery"];
            this.unMappedFilters = data["unMappedFilters"];
            this.buildLolId = data["buildLolId"];
        }
    }

    static fromJS(data: any): GetQueryBuilderDetails {
        data = typeof data === 'object' ? data : {};
        let result = new GetQueryBuilderDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterDetails"] = this.filterDetails;
        data["filterQuery"] = this.filterQuery;
        data["unMappedFilters"] = this.unMappedFilters;
        data["buildLolId"] = this.buildLolId;
        return data; 
    }
}

export interface IGetQueryBuilderDetails {
    filterDetails: string | undefined;
    filterQuery: string | undefined;
    unMappedFilters: string | undefined;
    buildLolId: number | undefined;
}

export class ColumnDefinition implements IColumnDefinition {
    label!: string | undefined;
    field!: string | undefined;
    type!: string | undefined;
    input!: string | undefined;
    multiple!: boolean | undefined;
    values!: string | undefined;
    operators!: string[] | undefined;
    template!: string | undefined;
    itemBankNotFilterable!: boolean | undefined;
    itemBankNotColumn!: boolean | undefined;
    id!: string | undefined;
    optgroup!: string | undefined;
    value!: string | undefined;
    data!: BuildTableLayoutDetails | undefined;

    constructor(data?: IColumnDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.field = data["field"];
            this.type = data["type"];
            this.input = data["input"];
            this.multiple = data["multiple"];
            this.values = data["values"];
            if (Array.isArray(data["operators"])) {
                this.operators = [] as any;
                for (let item of data["operators"])
                    this.operators!.push(item);
            }
            this.template = data["template"];
            this.itemBankNotFilterable = data["itemBankNotFilterable"];
            this.itemBankNotColumn = data["itemBankNotColumn"];
            this.id = data["id"];
            this.optgroup = data["optgroup"];
            this.value = data["value"];
            this.data = data["data"] ? BuildTableLayoutDetails.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ColumnDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["field"] = this.field;
        data["type"] = this.type;
        data["input"] = this.input;
        data["multiple"] = this.multiple;
        data["values"] = this.values;
        if (Array.isArray(this.operators)) {
            data["operators"] = [];
            for (let item of this.operators)
                data["operators"].push(item);
        }
        data["template"] = this.template;
        data["itemBankNotFilterable"] = this.itemBankNotFilterable;
        data["itemBankNotColumn"] = this.itemBankNotColumn;
        data["id"] = this.id;
        data["optgroup"] = this.optgroup;
        data["value"] = this.value;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IColumnDefinition {
    label: string | undefined;
    field: string | undefined;
    type: string | undefined;
    input: string | undefined;
    multiple: boolean | undefined;
    values: string | undefined;
    operators: string[] | undefined;
    template: string | undefined;
    itemBankNotFilterable: boolean | undefined;
    itemBankNotColumn: boolean | undefined;
    id: string | undefined;
    optgroup: string | undefined;
    value: string | undefined;
    data: BuildTableLayoutDetails | undefined;
}

export class BuildTableLayoutDetails implements IBuildTableLayoutDetails {
    id!: number | undefined;
    iDataLength!: number | undefined;
    cFieldName!: string | undefined;
    cTableName!: string | undefined;
    iShowTextBox!: boolean | undefined;
    iShowListBox!: boolean | undefined;
    iFileOperations!: boolean | undefined;
    iShowDefault!: number | undefined;
    cFieldType!: string | undefined;
    iDisplayOrder!: number | undefined;
    iIsListSpecific!: boolean | undefined;
    cFieldDescription!: string | undefined;
    iBTID!: number | undefined;
    isFavourite!: boolean | undefined;
    cDataType!: string | undefined;
    iDBID!: number | undefined;

    constructor(data?: IBuildTableLayoutDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.iDataLength = data["iDataLength"];
            this.cFieldName = data["cFieldName"];
            this.cTableName = data["cTableName"];
            this.iShowTextBox = data["iShowTextBox"];
            this.iShowListBox = data["iShowListBox"];
            this.iFileOperations = data["iFileOperations"];
            this.iShowDefault = data["iShowDefault"];
            this.cFieldType = data["cFieldType"];
            this.iDisplayOrder = data["iDisplayOrder"];
            this.iIsListSpecific = data["iIsListSpecific"];
            this.cFieldDescription = data["cFieldDescription"];
            this.iBTID = data["iBTID"];
            this.isFavourite = data["isFavourite"];
            this.cDataType = data["cDataType"];
            this.iDBID = data["iDBID"];
        }
    }

    static fromJS(data: any): BuildTableLayoutDetails {
        data = typeof data === 'object' ? data : {};
        let result = new BuildTableLayoutDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["iDataLength"] = this.iDataLength;
        data["cFieldName"] = this.cFieldName;
        data["cTableName"] = this.cTableName;
        data["iShowTextBox"] = this.iShowTextBox;
        data["iShowListBox"] = this.iShowListBox;
        data["iFileOperations"] = this.iFileOperations;
        data["iShowDefault"] = this.iShowDefault;
        data["cFieldType"] = this.cFieldType;
        data["iDisplayOrder"] = this.iDisplayOrder;
        data["iIsListSpecific"] = this.iIsListSpecific;
        data["cFieldDescription"] = this.cFieldDescription;
        data["iBTID"] = this.iBTID;
        data["isFavourite"] = this.isFavourite;
        data["cDataType"] = this.cDataType;
        data["iDBID"] = this.iDBID;
        return data; 
    }
}

export interface IBuildTableLayoutDetails {
    id: number | undefined;
    iDataLength: number | undefined;
    cFieldName: string | undefined;
    cTableName: string | undefined;
    iShowTextBox: boolean | undefined;
    iShowListBox: boolean | undefined;
    iFileOperations: boolean | undefined;
    iShowDefault: number | undefined;
    cFieldType: string | undefined;
    iDisplayOrder: number | undefined;
    iIsListSpecific: boolean | undefined;
    cFieldDescription: string | undefined;
    iBTID: number | undefined;
    isFavourite: boolean | undefined;
    cDataType: string | undefined;
    iDBID: number | undefined;
}

export class ValueList implements IValueList {
    id!: number | undefined;
    cValue!: string | undefined;
    cDescription!: string | undefined;

    constructor(data?: IValueList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cValue = data["cValue"];
            this.cDescription = data["cDescription"];
        }
    }

    static fromJS(data: any): ValueList {
        data = typeof data === 'object' ? data : {};
        let result = new ValueList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cValue"] = this.cValue;
        data["cDescription"] = this.cDescription;
        return data; 
    }
}

export interface IValueList {
    id: number | undefined;
    cValue: string | undefined;
    cDescription: string | undefined;
}

export class PagedResultDtoOfGetSelectionFieldCountReportView implements IPagedResultDtoOfGetSelectionFieldCountReportView {
    totalCount!: number | undefined;
    items!: GetSelectionFieldCountReportView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSelectionFieldCountReportView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSelectionFieldCountReportView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSelectionFieldCountReportView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSelectionFieldCountReportView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetSelectionFieldCountReportView {
    totalCount: number | undefined;
    items: GetSelectionFieldCountReportView[] | undefined;
}

export class GetSelectionFieldCountReportView implements IGetSelectionFieldCountReportView {
    cQuestionFieldName!: string | undefined;
    cDescription!: string | undefined;
    count!: number | undefined;
    iStatus!: number | undefined;
    orderDetailsList!: GetOrderDetailsView[] | undefined;

    constructor(data?: IGetSelectionFieldCountReportView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cQuestionFieldName = data["cQuestionFieldName"];
            this.cDescription = data["cDescription"];
            this.count = data["count"];
            this.iStatus = data["iStatus"];
            if (Array.isArray(data["orderDetailsList"])) {
                this.orderDetailsList = [] as any;
                for (let item of data["orderDetailsList"])
                    this.orderDetailsList!.push(GetOrderDetailsView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSelectionFieldCountReportView {
        data = typeof data === 'object' ? data : {};
        let result = new GetSelectionFieldCountReportView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cQuestionFieldName"] = this.cQuestionFieldName;
        data["cDescription"] = this.cDescription;
        data["count"] = this.count;
        data["iStatus"] = this.iStatus;
        if (Array.isArray(this.orderDetailsList)) {
            data["orderDetailsList"] = [];
            for (let item of this.orderDetailsList)
                data["orderDetailsList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetSelectionFieldCountReportView {
    cQuestionFieldName: string | undefined;
    cDescription: string | undefined;
    count: number | undefined;
    iStatus: number | undefined;
    orderDetailsList: GetOrderDetailsView[] | undefined;
}

export class GetOrderDetailsView implements IGetOrderDetailsView {
    orderId!: number | undefined;
    cDescription!: string | undefined;
    iProvidedCount!: number | undefined;
    dCreatedDate!: string | undefined;
    createdBy!: string | undefined;

    constructor(data?: IGetOrderDetailsView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.cDescription = data["cDescription"];
            this.iProvidedCount = data["iProvidedCount"];
            this.dCreatedDate = data["dCreatedDate"];
            this.createdBy = data["createdBy"];
        }
    }

    static fromJS(data: any): GetOrderDetailsView {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrderDetailsView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["cDescription"] = this.cDescription;
        data["iProvidedCount"] = this.iProvidedCount;
        data["dCreatedDate"] = this.dCreatedDate;
        data["createdBy"] = this.createdBy;
        return data; 
    }
}

export interface IGetOrderDetailsView {
    orderId: number | undefined;
    cDescription: string | undefined;
    iProvidedCount: number | undefined;
    dCreatedDate: string | undefined;
    createdBy: string | undefined;
}

export class PagedResultDtoOfGetOrderDetailsView implements IPagedResultDtoOfGetOrderDetailsView {
    totalCount!: number | undefined;
    items!: GetOrderDetailsView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetOrderDetailsView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetOrderDetailsView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetOrderDetailsView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetOrderDetailsView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetOrderDetailsView {
    totalCount: number | undefined;
    items: GetOrderDetailsView[] | undefined;
}

export class GetSelectionFieldCountReportInput implements IGetSelectionFieldCountReportInput {
    downloadFlag!: boolean | undefined;
    filter!: string | undefined;
    selectedDatabase!: number | undefined;
    selectedcQuestionFieldName!: string | undefined;
    selectediStatus!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IGetSelectionFieldCountReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.downloadFlag = data["downloadFlag"];
            this.filter = data["filter"];
            this.selectedDatabase = data["selectedDatabase"];
            this.selectedcQuestionFieldName = data["selectedcQuestionFieldName"];
            this.selectediStatus = data["selectediStatus"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetSelectionFieldCountReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSelectionFieldCountReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadFlag"] = this.downloadFlag;
        data["filter"] = this.filter;
        data["selectedDatabase"] = this.selectedDatabase;
        data["selectedcQuestionFieldName"] = this.selectedcQuestionFieldName;
        data["selectediStatus"] = this.selectediStatus;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IGetSelectionFieldCountReportInput {
    downloadFlag: boolean | undefined;
    filter: string | undefined;
    selectedDatabase: number | undefined;
    selectedcQuestionFieldName: string | undefined;
    selectediStatus: string | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto | undefined;
    tenant!: TenantLoginInfoDto | undefined;
    application!: ApplicationInfoDto | undefined;
    theme!: UiCustomizationSettingsDto | undefined;
    idmsUser!: IdmsUserLoginInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.theme = data["theme"] ? UiCustomizationSettingsDto.fromJS(data["theme"]) : <any>undefined;
            this.idmsUser = data["idmsUser"] ? IdmsUserLoginInfoDto.fromJS(data["idmsUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        data["idmsUser"] = this.idmsUser ? this.idmsUser.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
    theme: UiCustomizationSettingsDto | undefined;
    idmsUser: IdmsUserLoginInfoDto | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;
    subscriptionPaymentType!: SubscriptionPaymentType | undefined;
    edition!: EditionInfoDto | undefined;
    creationTime!: moment.Moment | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    subscriptionDateString!: string | undefined;
    creationTimeString!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.subscriptionPaymentType = data["subscriptionPaymentType"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionDateString = data["subscriptionDateString"];
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    subscriptionPaymentType: SubscriptionPaymentType | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: moment.Moment | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: moment.Moment | undefined;
    currency!: string | undefined;
    currencySign!: string | undefined;
    allowTenantsToChangeEmailSettings!: boolean | undefined;
    features!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            this.currency = data["currency"];
            this.currencySign = data["currencySign"];
            this.allowTenantsToChangeEmailSettings = data["allowTenantsToChangeEmailSettings"];
            if (data["features"]) {
                this.features = {} as any;
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features![key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean | undefined;
    features: { [key: string]: boolean; } | undefined;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings!: ThemeSettingsDto | undefined;
    isLeftMenuUsed!: boolean | undefined;
    isTopMenuUsed!: boolean | undefined;
    isTabMenuUsed!: boolean | undefined;
    allowMenuScroll!: boolean | undefined;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.baseSettings = data["baseSettings"] ? ThemeSettingsDto.fromJS(data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = data["isLeftMenuUsed"];
            this.isTopMenuUsed = data["isTopMenuUsed"];
            this.isTabMenuUsed = data["isTabMenuUsed"];
            this.allowMenuScroll = data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data; 
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto | undefined;
    isLeftMenuUsed: boolean | undefined;
    isTopMenuUsed: boolean | undefined;
    isTabMenuUsed: boolean | undefined;
    allowMenuScroll: boolean | undefined;
}

export class IdmsUserLoginInfoDto implements IIdmsUserLoginInfoDto {
    idmsUserID!: number | undefined;
    idmsUserName!: string | undefined;
    userMailerID!: number | undefined;
    currentCampaignDatabaseId!: number | undefined;

    constructor(data?: IIdmsUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.idmsUserID = data["idmsUserID"];
            this.idmsUserName = data["idmsUserName"];
            this.userMailerID = data["userMailerID"];
            this.currentCampaignDatabaseId = data["currentCampaignDatabaseId"];
        }
    }

    static fromJS(data: any): IdmsUserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdmsUserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idmsUserID"] = this.idmsUserID;
        data["idmsUserName"] = this.idmsUserName;
        data["userMailerID"] = this.userMailerID;
        data["currentCampaignDatabaseId"] = this.currentCampaignDatabaseId;
        return data; 
    }
}

export interface IIdmsUserLoginInfoDto {
    idmsUserID: number | undefined;
    idmsUserName: string | undefined;
    userMailerID: number | undefined;
    currentCampaignDatabaseId: number | undefined;
}

export enum SubscriptionPaymentType {
    Manual = 0,
    RecurringAutomatic = 1,
    RecurringManual = 2,
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName!: string | undefined;
    trialDayCount!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    isHighestEdition!: boolean | undefined;
    isFree!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme!: string | undefined;
    layout!: ThemeLayoutSettingsDto | undefined;
    header!: ThemeHeaderSettingsDto | undefined;
    subHeader!: ThemeSubHeaderSettingsDto | undefined;
    menu!: ThemeMenuSettingsDto | undefined;
    footer!: ThemeFooterSettingsDto | undefined;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
            this.layout = data["layout"] ? ThemeLayoutSettingsDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? ThemeHeaderSettingsDto.fromJS(data["header"]) : <any>undefined;
            this.subHeader = data["subHeader"] ? ThemeSubHeaderSettingsDto.fromJS(data["subHeader"]) : <any>undefined;
            this.menu = data["menu"] ? ThemeMenuSettingsDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? ThemeFooterSettingsDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["subHeader"] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto | undefined;
    header: ThemeHeaderSettingsDto | undefined;
    subHeader: ThemeSubHeaderSettingsDto | undefined;
    menu: ThemeMenuSettingsDto | undefined;
    footer: ThemeFooterSettingsDto | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType!: string | undefined;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        return data; 
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    desktopFixedHeader!: boolean | undefined;
    mobileFixedHeader!: boolean | undefined;
    headerSkin!: string | undefined;
    minimizeDesktopHeaderType!: string | undefined;
    headerMenuArrows!: boolean | undefined;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.headerSkin = data["headerSkin"];
            this.minimizeDesktopHeaderType = data["minimizeDesktopHeaderType"];
            this.headerMenuArrows = data["headerMenuArrows"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        data["minimizeDesktopHeaderType"] = this.minimizeDesktopHeaderType;
        data["headerMenuArrows"] = this.headerMenuArrows;
        return data; 
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean | undefined;
    mobileFixedHeader: boolean | undefined;
    headerSkin: string | undefined;
    minimizeDesktopHeaderType: string | undefined;
    headerMenuArrows: boolean | undefined;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
    fixedSubHeader!: boolean | undefined;
    subheaderStyle!: string | undefined;

    constructor(data?: IThemeSubHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedSubHeader = data["fixedSubHeader"];
            this.subheaderStyle = data["subheaderStyle"];
        }
    }

    static fromJS(data: any): ThemeSubHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSubHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedSubHeader"] = this.fixedSubHeader;
        data["subheaderStyle"] = this.subheaderStyle;
        return data; 
    }
}

export interface IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean | undefined;
    subheaderStyle: string | undefined;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean | undefined;
    allowAsideMinimizing!: boolean | undefined;
    defaultMinimizedAside!: boolean | undefined;
    submenuToggle!: string | undefined;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.submenuToggle = data["submenuToggle"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["submenuToggle"] = this.submenuToggle;
        return data; 
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    submenuToggle: string | undefined;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter!: boolean | undefined;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class PagedResultDtoOfGetShippedReportView implements IPagedResultDtoOfGetShippedReportView {
    totalCount!: number | undefined;
    items!: GetShippedReportView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetShippedReportView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetShippedReportView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetShippedReportView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetShippedReportView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetShippedReportView {
    totalCount: number | undefined;
    items: GetShippedReportView[] | undefined;
}

export class GetShippedReportView implements IGetShippedReportView {
    orderID!: number | undefined;
    orderDescription!: string | undefined;
    databaseName!: string | undefined;
    mailer!: string | undefined;
    broker!: string | undefined;
    brokerPONumber!: string | undefined;
    poNumber!: string | undefined;
    shippedDate!: string | undefined;
    providedQuantity!: number | undefined;
    type!: string | undefined;
    netOrder!: string | undefined;
    netUsage!: string | undefined;
    decoyKey!: string | undefined;
    createdBy!: string | undefined;
    shippedBy!: string | undefined;
    exportLayoutName!: string | undefined;
    oessInvoiceTotal!: string | undefined;
    oessInvoiceNumber!: string | undefined;

    constructor(data?: IGetShippedReportView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderID = data["orderID"];
            this.orderDescription = data["orderDescription"];
            this.databaseName = data["databaseName"];
            this.mailer = data["mailer"];
            this.broker = data["broker"];
            this.brokerPONumber = data["brokerPONumber"];
            this.poNumber = data["poNumber"];
            this.shippedDate = data["shippedDate"];
            this.providedQuantity = data["providedQuantity"];
            this.type = data["type"];
            this.netOrder = data["netOrder"];
            this.netUsage = data["netUsage"];
            this.decoyKey = data["decoyKey"];
            this.createdBy = data["createdBy"];
            this.shippedBy = data["shippedBy"];
            this.exportLayoutName = data["exportLayoutName"];
            this.oessInvoiceTotal = data["oessInvoiceTotal"];
            this.oessInvoiceNumber = data["oessInvoiceNumber"];
        }
    }

    static fromJS(data: any): GetShippedReportView {
        data = typeof data === 'object' ? data : {};
        let result = new GetShippedReportView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderID"] = this.orderID;
        data["orderDescription"] = this.orderDescription;
        data["databaseName"] = this.databaseName;
        data["mailer"] = this.mailer;
        data["broker"] = this.broker;
        data["brokerPONumber"] = this.brokerPONumber;
        data["poNumber"] = this.poNumber;
        data["shippedDate"] = this.shippedDate;
        data["providedQuantity"] = this.providedQuantity;
        data["type"] = this.type;
        data["netOrder"] = this.netOrder;
        data["netUsage"] = this.netUsage;
        data["decoyKey"] = this.decoyKey;
        data["createdBy"] = this.createdBy;
        data["shippedBy"] = this.shippedBy;
        data["exportLayoutName"] = this.exportLayoutName;
        data["oessInvoiceTotal"] = this.oessInvoiceTotal;
        data["oessInvoiceNumber"] = this.oessInvoiceNumber;
        return data; 
    }
}

export interface IGetShippedReportView {
    orderID: number | undefined;
    orderDescription: string | undefined;
    databaseName: string | undefined;
    mailer: string | undefined;
    broker: string | undefined;
    brokerPONumber: string | undefined;
    poNumber: string | undefined;
    shippedDate: string | undefined;
    providedQuantity: number | undefined;
    type: string | undefined;
    netOrder: string | undefined;
    netUsage: string | undefined;
    decoyKey: string | undefined;
    createdBy: string | undefined;
    shippedBy: string | undefined;
    exportLayoutName: string | undefined;
    oessInvoiceTotal: string | undefined;
    oessInvoiceNumber: string | undefined;
}

export class GetShippedReportInput implements IGetShippedReportInput {
    filter!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number | undefined;
    maxResultCount!: number | undefined;

    constructor(data?: IGetShippedReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetShippedReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetShippedReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }
}

export interface IGetShippedReportInput {
    filter: string | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export enum PageID {
    AddFavorites = 0,
    Campaigns = 1,
    Models = 2,
    MatchAppend = 3,
    ShippedReports = 4,
    CampaignHistory = 5,
    Decoys = 6,
    Lookups = 7,
    SelectionFieldCountReports = 8,
    BatchProcessQueue = 9,
    ListOfList = 10,
    IDMSConfiguration = 11,
    ExternalDatabaseLinks = 12,
    ProcessQueues = 13,
}

export class HelpText implements IHelpText {
    header!: string | undefined;
    examples!: string[] | undefined;

    constructor(data?: IHelpText) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.header = data["header"];
            if (Array.isArray(data["examples"])) {
                this.examples = [] as any;
                for (let item of data["examples"])
                    this.examples!.push(item);
            }
        }
    }

    static fromJS(data: any): HelpText {
        data = typeof data === 'object' ? data : {};
        let result = new HelpText();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header;
        if (Array.isArray(this.examples)) {
            data["examples"] = [];
            for (let item of this.examples)
                data["examples"].push(item);
        }
        return data; 
    }
}

export interface IHelpText {
    header: string | undefined;
    examples: string[] | undefined;
}

export class PagedResultDtoOfGetSICCodeRelatedForViewDto implements IPagedResultDtoOfGetSICCodeRelatedForViewDto {
    totalCount!: number | undefined;
    items!: GetSICCodeRelatedForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSICCodeRelatedForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSICCodeRelatedForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSICCodeRelatedForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSICCodeRelatedForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetSICCodeRelatedForViewDto {
    totalCount: number | undefined;
    items: GetSICCodeRelatedForViewDto[] | undefined;
}

export class GetSICCodeRelatedForViewDto implements IGetSICCodeRelatedForViewDto {
    sicCodeRelated!: SICCodeRelatedDto | undefined;

    constructor(data?: IGetSICCodeRelatedForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sicCodeRelated = data["sicCodeRelated"] ? SICCodeRelatedDto.fromJS(data["sicCodeRelated"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSICCodeRelatedForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSICCodeRelatedForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sicCodeRelated"] = this.sicCodeRelated ? this.sicCodeRelated.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetSICCodeRelatedForViewDto {
    sicCodeRelated: SICCodeRelatedDto | undefined;
}

export class SICCodeRelatedDto implements ISICCodeRelatedDto {
    id!: number | undefined;

    constructor(data?: ISICCodeRelatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SICCodeRelatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new SICCodeRelatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ISICCodeRelatedDto {
    id: number | undefined;
}

export class GetSICCodeRelatedForEditOutput implements IGetSICCodeRelatedForEditOutput {
    sicCodeRelated!: CreateOrEditSICCodeRelatedDto | undefined;

    constructor(data?: IGetSICCodeRelatedForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sicCodeRelated = data["sicCodeRelated"] ? CreateOrEditSICCodeRelatedDto.fromJS(data["sicCodeRelated"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSICCodeRelatedForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSICCodeRelatedForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sicCodeRelated"] = this.sicCodeRelated ? this.sicCodeRelated.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetSICCodeRelatedForEditOutput {
    sicCodeRelated: CreateOrEditSICCodeRelatedDto | undefined;
}

export class CreateOrEditSICCodeRelatedDto implements ICreateOrEditSICCodeRelatedDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditSICCodeRelatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSICCodeRelatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSICCodeRelatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditSICCodeRelatedDto {
    id: number | undefined;
}

export class TreeNode implements ITreeNode {
    label!: string | undefined;
    data!: NodeData | undefined;
    icon!: string | undefined;
    expandedIcon!: string | undefined;
    collapsedIcon!: string | undefined;
    leaf!: boolean | undefined;
    expanded!: boolean | undefined;
    styleClass!: string | undefined;
    key!: string | undefined;
    children!: TreeNode[] | undefined;

    constructor(data?: ITreeNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.data = data["data"] ? NodeData.fromJS(data["data"]) : <any>undefined;
            this.icon = data["icon"];
            this.expandedIcon = data["expandedIcon"];
            this.collapsedIcon = data["collapsedIcon"];
            this.leaf = data["leaf"];
            this.expanded = data["expanded"];
            this.styleClass = data["styleClass"];
            this.key = data["key"];
            if (Array.isArray(data["children"])) {
                this.children = [] as any;
                for (let item of data["children"])
                    this.children!.push(TreeNode.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TreeNode {
        data = typeof data === 'object' ? data : {};
        let result = new TreeNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["icon"] = this.icon;
        data["expandedIcon"] = this.expandedIcon;
        data["collapsedIcon"] = this.collapsedIcon;
        data["leaf"] = this.leaf;
        data["expanded"] = this.expanded;
        data["styleClass"] = this.styleClass;
        data["key"] = this.key;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITreeNode {
    label: string | undefined;
    data: NodeData | undefined;
    icon: string | undefined;
    expandedIcon: string | undefined;
    collapsedIcon: string | undefined;
    leaf: boolean | undefined;
    expanded: boolean | undefined;
    styleClass: string | undefined;
    key: string | undefined;
    children: TreeNode[] | undefined;
}

export class NodeData implements INodeData {
    cDescription!: string | undefined;
    cSICCode!: string | undefined;
    cIndicator!: string | undefined;
    level!: number | undefined;
    sicLength!: number | undefined;

    constructor(data?: INodeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cDescription = data["cDescription"];
            this.cSICCode = data["cSICCode"];
            this.cIndicator = data["cIndicator"];
            this.level = data["level"];
            this.sicLength = data["sicLength"];
        }
    }

    static fromJS(data: any): NodeData {
        data = typeof data === 'object' ? data : {};
        let result = new NodeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cDescription"] = this.cDescription;
        data["cSICCode"] = this.cSICCode;
        data["cIndicator"] = this.cIndicator;
        data["level"] = this.level;
        data["sicLength"] = this.sicLength;
        return data; 
    }
}

export interface INodeData {
    cDescription: string | undefined;
    cSICCode: string | undefined;
    cIndicator: string | undefined;
    level: number | undefined;
    sicLength: number | undefined;
}

export class FranchiseNIndusdustry implements IFranchiseNIndusdustry {
    franchises!: DropdownOutputDto[] | undefined;
    industries!: DropdownOutputDto[] | undefined;

    constructor(data?: IFranchiseNIndusdustry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["franchises"])) {
                this.franchises = [] as any;
                for (let item of data["franchises"])
                    this.franchises!.push(DropdownOutputDto.fromJS(item));
            }
            if (Array.isArray(data["industries"])) {
                this.industries = [] as any;
                for (let item of data["industries"])
                    this.industries!.push(DropdownOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FranchiseNIndusdustry {
        data = typeof data === 'object' ? data : {};
        let result = new FranchiseNIndusdustry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.franchises)) {
            data["franchises"] = [];
            for (let item of this.franchises)
                data["franchises"].push(item.toJSON());
        }
        if (Array.isArray(this.industries)) {
            data["industries"] = [];
            for (let item of this.industries)
                data["industries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFranchiseNIndusdustry {
    franchises: DropdownOutputDto[] | undefined;
    industries: DropdownOutputDto[] | undefined;
}

export class ValidateSICCodesInputDto implements IValidateSICCodesInputDto {
    searchText!: string | undefined;

    constructor(data?: IValidateSICCodesInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchText = data["searchText"];
        }
    }

    static fromJS(data: any): ValidateSICCodesInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateSICCodesInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchText"] = this.searchText;
        return data; 
    }
}

export interface IValidateSICCodesInputDto {
    searchText: string | undefined;
}

export class SmartAddOutputDto implements ISmartAddOutputDto {
    warningMessage!: string | undefined;
    sicSelections!: DropdownOutputDto[][] | undefined;

    constructor(data?: ISmartAddOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.warningMessage = data["warningMessage"];
            if (Array.isArray(data["sicSelections"])) {
                this.sicSelections = [] as any;
                for (let item of data["sicSelections"])
                    this.sicSelections!.push(item);
            }
        }
    }

    static fromJS(data: any): SmartAddOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SmartAddOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warningMessage"] = this.warningMessage;
        if (Array.isArray(this.sicSelections)) {
            data["sicSelections"] = [];
            for (let item of this.sicSelections)
                data["sicSelections"].push(item);
        }
        return data; 
    }
}

export interface ISmartAddOutputDto {
    warningMessage: string | undefined;
    sicSelections: DropdownOutputDto[][] | undefined;
}

export class PagedResultDtoOfGetSICFranchiseCodeForViewDto implements IPagedResultDtoOfGetSICFranchiseCodeForViewDto {
    totalCount!: number | undefined;
    items!: GetSICFranchiseCodeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSICFranchiseCodeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSICFranchiseCodeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSICFranchiseCodeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSICFranchiseCodeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetSICFranchiseCodeForViewDto {
    totalCount: number | undefined;
    items: GetSICFranchiseCodeForViewDto[] | undefined;
}

export class GetSICFranchiseCodeForViewDto implements IGetSICFranchiseCodeForViewDto {
    sicFranchiseCode!: SICFranchiseCodeDto | undefined;

    constructor(data?: IGetSICFranchiseCodeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sicFranchiseCode = data["sicFranchiseCode"] ? SICFranchiseCodeDto.fromJS(data["sicFranchiseCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSICFranchiseCodeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSICFranchiseCodeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sicFranchiseCode"] = this.sicFranchiseCode ? this.sicFranchiseCode.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetSICFranchiseCodeForViewDto {
    sicFranchiseCode: SICFranchiseCodeDto | undefined;
}

export class SICFranchiseCodeDto implements ISICFranchiseCodeDto {
    id!: number | undefined;

    constructor(data?: ISICFranchiseCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SICFranchiseCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SICFranchiseCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ISICFranchiseCodeDto {
    id: number | undefined;
}

export class GetSICFranchiseCodeForEditOutput implements IGetSICFranchiseCodeForEditOutput {
    sicFranchiseCode!: CreateOrEditSICFranchiseCodeDto | undefined;

    constructor(data?: IGetSICFranchiseCodeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sicFranchiseCode = data["sicFranchiseCode"] ? CreateOrEditSICFranchiseCodeDto.fromJS(data["sicFranchiseCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSICFranchiseCodeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSICFranchiseCodeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sicFranchiseCode"] = this.sicFranchiseCode ? this.sicFranchiseCode.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetSICFranchiseCodeForEditOutput {
    sicFranchiseCode: CreateOrEditSICFranchiseCodeDto | undefined;
}

export class CreateOrEditSICFranchiseCodeDto implements ICreateOrEditSICFranchiseCodeDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditSICFranchiseCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSICFranchiseCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSICFranchiseCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditSICFranchiseCodeDto {
    id: number | undefined;
}

export class GetStateForViewDto implements IGetStateForViewDto {
    configuredFields!: AdvanceSelectionFields | undefined;
    targetDatabaseId!: number | undefined;
    states!: DropdownOutputDto[] | undefined;

    constructor(data?: IGetStateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.configuredFields = data["configuredFields"] ? AdvanceSelectionFields.fromJS(data["configuredFields"]) : <any>undefined;
            this.targetDatabaseId = data["targetDatabaseId"];
            if (Array.isArray(data["states"])) {
                this.states = [] as any;
                for (let item of data["states"])
                    this.states!.push(DropdownOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetStateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configuredFields"] = this.configuredFields ? this.configuredFields.toJSON() : <any>undefined;
        data["targetDatabaseId"] = this.targetDatabaseId;
        if (Array.isArray(this.states)) {
            data["states"] = [];
            for (let item of this.states)
                data["states"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetStateForViewDto {
    configuredFields: AdvanceSelectionFields | undefined;
    targetDatabaseId: number | undefined;
    states: DropdownOutputDto[] | undefined;
}

export class StripeConfirmPaymentInput implements IStripeConfirmPaymentInput {
    paymentId!: number | undefined;
    stripeToken!: string | undefined;

    constructor(data?: IStripeConfirmPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeConfirmPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfirmPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }
}

export interface IStripeConfirmPaymentInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;
}

export class StripeCreateSubscriptionInput implements IStripeCreateSubscriptionInput {
    paymentId!: number | undefined;
    stripeToken!: string | undefined;

    constructor(data?: IStripeCreateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeCreateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }
}

export interface IStripeCreateSubscriptionInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;
}

export class StripeUpdateSubscriptionInput implements IStripeUpdateSubscriptionInput {
    paymentId!: number | undefined;

    constructor(data?: IStripeUpdateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
        }
    }

    static fromJS(data: any): StripeUpdateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeUpdateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        return data; 
    }
}

export interface IStripeUpdateSubscriptionInput {
    paymentId: number | undefined;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey!: string | undefined;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.publishableKey = data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        return data; 
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;
}

export class GetSubSelectSourcesForView implements IGetSubSelectSourcesForView {
    masterLOLID!: number | undefined;
    id!: number | undefined;

    constructor(data?: IGetSubSelectSourcesForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.masterLOLID = data["masterLOLID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetSubSelectSourcesForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetSubSelectSourcesForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["masterLOLID"] = this.masterLOLID;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetSubSelectSourcesForView {
    masterLOLID: number | undefined;
    id: number | undefined;
}

export class SubSelectForViewDto implements ISubSelectForViewDto {
    cIncludeExclude!: string | undefined;
    cCompanyIndividual!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISubSelectForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cIncludeExclude = data["cIncludeExclude"];
            this.cCompanyIndividual = data["cCompanyIndividual"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubSelectForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubSelectForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cIncludeExclude"] = this.cIncludeExclude;
        data["cCompanyIndividual"] = this.cCompanyIndividual;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubSelectForViewDto {
    cIncludeExclude: string | undefined;
    cCompanyIndividual: string | undefined;
    id: number | undefined;
}

export class CreateOrEditSubSelectDto implements ICreateOrEditSubSelectDto {
    cIncludeExclude!: string | undefined;
    cCompanyIndividual!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    segmentId!: number | undefined;
    campaignId!: number | undefined;
    sourceIds!: number[] | undefined;
    deletedSourceIds!: number[] | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditSubSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cIncludeExclude = data["cIncludeExclude"];
            this.cCompanyIndividual = data["cCompanyIndividual"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.segmentId = data["segmentId"];
            this.campaignId = data["campaignId"];
            if (Array.isArray(data["sourceIds"])) {
                this.sourceIds = [] as any;
                for (let item of data["sourceIds"])
                    this.sourceIds!.push(item);
            }
            if (Array.isArray(data["deletedSourceIds"])) {
                this.deletedSourceIds = [] as any;
                for (let item of data["deletedSourceIds"])
                    this.deletedSourceIds!.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSubSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSubSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cIncludeExclude"] = this.cIncludeExclude;
        data["cCompanyIndividual"] = this.cCompanyIndividual;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["segmentId"] = this.segmentId;
        data["campaignId"] = this.campaignId;
        if (Array.isArray(this.sourceIds)) {
            data["sourceIds"] = [];
            for (let item of this.sourceIds)
                data["sourceIds"].push(item);
        }
        if (Array.isArray(this.deletedSourceIds)) {
            data["deletedSourceIds"] = [];
            for (let item of this.deletedSourceIds)
                data["deletedSourceIds"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditSubSelectDto {
    cIncludeExclude: string | undefined;
    cCompanyIndividual: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    segmentId: number | undefined;
    campaignId: number | undefined;
    sourceIds: number[] | undefined;
    deletedSourceIds: number[] | undefined;
    id: number | undefined;
}

export class SubSelectSelectionsDetailsDto implements ISubSelectSelectionsDetailsDto {
    fields!: SubSelectSelectionsDTO[] | undefined;
    buildLolId!: number | undefined;

    constructor(data?: ISubSelectSelectionsDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["fields"])) {
                this.fields = [] as any;
                for (let item of data["fields"])
                    this.fields!.push(SubSelectSelectionsDTO.fromJS(item));
            }
            this.buildLolId = data["buildLolId"];
        }
    }

    static fromJS(data: any): SubSelectSelectionsDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubSelectSelectionsDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["buildLolId"] = this.buildLolId;
        return data; 
    }
}

export interface ISubSelectSelectionsDetailsDto {
    fields: SubSelectSelectionsDTO[] | undefined;
    buildLolId: number | undefined;
}

export class SubSelectSelectionsDTO implements ISubSelectSelectionsDTO {
    cTableName!: string | undefined;
    subSelectId!: number | undefined;
    cJoinOperator!: string | undefined;
    cQuestionFieldName!: string | undefined;
    cQuestionDescription!: string | undefined;
    iGroupNumber!: number | undefined;
    iGroupOrder!: number | undefined;
    cGrouping!: string | undefined;
    cValues!: string | undefined;
    cDescriptions!: string | undefined;
    cValueMode!: string | undefined;
    cValueOperator!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cCreatedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    iIsListSpecific!: boolean | undefined;
    iIsRAWNotMapped!: boolean | undefined;
    addedFilterId!: number | undefined;
    campaignId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISubSelectSelectionsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cTableName = data["cTableName"];
            this.subSelectId = data["subSelectId"];
            this.cJoinOperator = data["cJoinOperator"];
            this.cQuestionFieldName = data["cQuestionFieldName"];
            this.cQuestionDescription = data["cQuestionDescription"];
            this.iGroupNumber = data["iGroupNumber"];
            this.iGroupOrder = data["iGroupOrder"];
            this.cGrouping = data["cGrouping"];
            this.cValues = data["cValues"];
            this.cDescriptions = data["cDescriptions"];
            this.cValueMode = data["cValueMode"];
            this.cValueOperator = data["cValueOperator"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cCreatedBy = data["cCreatedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.iIsListSpecific = data["iIsListSpecific"];
            this.iIsRAWNotMapped = data["iIsRAWNotMapped"];
            this.addedFilterId = data["addedFilterId"];
            this.campaignId = data["campaignId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubSelectSelectionsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SubSelectSelectionsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cTableName"] = this.cTableName;
        data["subSelectId"] = this.subSelectId;
        data["cJoinOperator"] = this.cJoinOperator;
        data["cQuestionFieldName"] = this.cQuestionFieldName;
        data["cQuestionDescription"] = this.cQuestionDescription;
        data["iGroupNumber"] = this.iGroupNumber;
        data["iGroupOrder"] = this.iGroupOrder;
        data["cGrouping"] = this.cGrouping;
        data["cValues"] = this.cValues;
        data["cDescriptions"] = this.cDescriptions;
        data["cValueMode"] = this.cValueMode;
        data["cValueOperator"] = this.cValueOperator;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["iIsListSpecific"] = this.iIsListSpecific;
        data["iIsRAWNotMapped"] = this.iIsRAWNotMapped;
        data["addedFilterId"] = this.addedFilterId;
        data["campaignId"] = this.campaignId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubSelectSelectionsDTO {
    cTableName: string | undefined;
    subSelectId: number | undefined;
    cJoinOperator: string | undefined;
    cQuestionFieldName: string | undefined;
    cQuestionDescription: string | undefined;
    iGroupNumber: number | undefined;
    iGroupOrder: number | undefined;
    cGrouping: string | undefined;
    cValues: string | undefined;
    cDescriptions: string | undefined;
    cValueMode: string | undefined;
    cValueOperator: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cCreatedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    iIsListSpecific: boolean | undefined;
    iIsRAWNotMapped: boolean | undefined;
    addedFilterId: number | undefined;
    campaignId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetSysSendMailForViewDto implements IPagedResultDtoOfGetSysSendMailForViewDto {
    totalCount!: number | undefined;
    items!: GetSysSendMailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSysSendMailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSysSendMailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSysSendMailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSysSendMailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetSysSendMailForViewDto {
    totalCount: number | undefined;
    items: GetSysSendMailForViewDto[] | undefined;
}

export class GetSysSendMailForViewDto implements IGetSysSendMailForViewDto {
    sysSendMail!: SysSendMailDto | undefined;

    constructor(data?: IGetSysSendMailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sysSendMail = data["sysSendMail"] ? SysSendMailDto.fromJS(data["sysSendMail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSysSendMailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSysSendMailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sysSendMail"] = this.sysSendMail ? this.sysSendMail.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetSysSendMailForViewDto {
    sysSendMail: SysSendMailDto | undefined;
}

export class SysSendMailDto implements ISysSendMailDto {
    id!: number | undefined;

    constructor(data?: ISysSendMailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SysSendMailDto {
        data = typeof data === 'object' ? data : {};
        let result = new SysSendMailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ISysSendMailDto {
    id: number | undefined;
}

export class GetSysSendMailForEditOutput implements IGetSysSendMailForEditOutput {
    sysSendMail!: CreateOrEditSysSendMailDto | undefined;

    constructor(data?: IGetSysSendMailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sysSendMail = data["sysSendMail"] ? CreateOrEditSysSendMailDto.fromJS(data["sysSendMail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSysSendMailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSysSendMailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sysSendMail"] = this.sysSendMail ? this.sysSendMail.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetSysSendMailForEditOutput {
    sysSendMail: CreateOrEditSysSendMailDto | undefined;
}

export class CreateOrEditSysSendMailDto implements ICreateOrEditSysSendMailDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditSysSendMailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSysSendMailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSysSendMailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditSysSendMailDto {
    id: number | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number | undefined;
    items!: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    editionDisplayName!: string | undefined;
    connectionString!: string | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    editionId!: number | undefined;
    isInTrialPeriod!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    sendActivationEmail!: boolean | undefined;
    editionId!: number | undefined;
    isActive!: boolean | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    editionId!: number | undefined;
    isActive!: boolean | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(data["features"])) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number | undefined;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (Array.isArray(data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id!: number | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDto {
    id: number | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["memberActivities"])) {
                this.memberActivities = [] as any;
                for (let item of data["memberActivities"])
                    this.memberActivities!.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.memberActivities)) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number | undefined;
    closed!: number | undefined;
    rate!: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.earnings = data["earnings"];
            this.cases = data["cases"];
            this.closed = data["closed"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number | undefined;
    closed: number | undefined;
    rate: string | undefined;
}

export enum SalesSummaryDatePeriod {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit!: number | undefined;
    newFeedbacks!: number | undefined;
    newOrders!: number | undefined;
    newUsers!: number | undefined;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number | undefined;
    revenue!: number | undefined;
    expenses!: number | undefined;
    growth!: number | undefined;
    transactionPercent!: number | undefined;
    newVisitPercent!: number | undefined;
    bouncePercent!: number | undefined;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
            if (Array.isArray(data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
            if (Array.isArray(data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of data["dailySales"])
                    this.dailySales!.push(item);
            }
            if (Array.isArray(data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number | undefined;
    profit!: number | undefined;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.sales = data["sales"];
            this.profit = data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number | undefined;
    profit: number | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    salesSummary!: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetSalesSummaryOutput {
    salesSummary: SalesSummaryData[] | undefined;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["stats"])) {
                this.stats = [] as any;
                for (let item of data["stats"])
                    this.stats!.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stats)) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number | undefined;
    change!: number[] | undefined;
    averagePrice!: number | undefined;
    totalPrice!: number | undefined;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryName = data["countryName"];
            this.sales = data["sales"];
            if (Array.isArray(data["change"])) {
                this.change = [] as any;
                for (let item of data["change"])
                    this.change!.push(item);
            }
            this.averagePrice = data["averagePrice"];
            this.totalPrice = data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (Array.isArray(this.change)) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data; 
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number | undefined;
    change: number[] | undefined;
    averagePrice: number | undefined;
    totalPrice: number | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number | undefined;
    newVisitPercent!: number | undefined;
    bouncePercent!: number | undefined;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    captchaResponse!: string | undefined;
    subscriptionStartType!: SubscriptionStartType | undefined;
    editionId!: number | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.captchaResponse = data["captchaResponse"];
            this.subscriptionStartType = data["subscriptionStartType"];
            this.editionId = data["editionId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        return data; 
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType | undefined;
    editionId: number | undefined;
}

export enum SubscriptionStartType {
    Free = 1,
    Trial = 2,
    Paid = 3,
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isTenantActive!: boolean | undefined;
    isActive!: boolean | undefined;
    isEmailConfirmationRequired!: boolean | undefined;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isTenantActive = data["isTenantActive"];
            this.isActive = data["isActive"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }
}

export interface IRegisterTenantOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean | undefined;
    isActive: boolean | undefined;
    isEmailConfirmationRequired: boolean | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures!: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["allFeatures"])) {
                this.allFeatures = [] as any;
                for (let item of data["allFeatures"])
                    this.allFeatures!.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (Array.isArray(data["editionsWithFeatures"])) {
                this.editionsWithFeatures = [] as any;
                for (let item of data["editionsWithFeatures"])
                    this.editionsWithFeatures!.push(EditionWithFeaturesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allFeatures)) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (Array.isArray(this.editionsWithFeatures)) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: IInputType | undefined;
    textHtmlColor!: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? IInputType.fromJS(data["inputType"]) : <any>undefined;
            this.textHtmlColor = data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType | undefined;
    textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition!: EditionSelectDto | undefined;
    featureValues!: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            if (Array.isArray(data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto | undefined;
    featureValues: NameValueDto[] | undefined;
}

export class IInputType implements IIInputType {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator | undefined;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            if (data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto | undefined;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: TenantEmailSettingsEditDto | undefined;
    ldap!: LdapSettingsEditDto | undefined;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto | undefined;
    otherSettings!: TenantOtherSettingsEditDto | undefined;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? TenantEmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;
    otherSettings: TenantOtherSettingsEditDto | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredUserActiveByDefault!: boolean | undefined;
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    useCaptchaOnLogin!: boolean | undefined;
    isCookieConsentEnabled!: boolean | undefined;
    isQuickThemeSelectEnabled!: boolean | undefined;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto | undefined;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.useCaptchaOnLogin = data["useCaptchaOnLogin"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
            this.sessionTimeOutSettings = data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    useCaptchaOnLogin: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto | undefined;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings!: boolean | undefined;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean | undefined;
    smtpUseDefaultCredentials!: boolean | undefined;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useHostDefaultEmailSettings = data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean | undefined;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean | undefined;
    isEnabled!: boolean | undefined;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;
}

export enum SettingScopes {
    Application = 1,
    Tenant = 2,
    User = 4,
    All = 7,
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean | undefined;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;
    captchaResponse!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean | undefined;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    captchaResponse: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    shouldResetPassword!: boolean | undefined;
    passwordResetCode!: string | undefined;
    userId!: number | undefined;
    requiresTwoFactorVerification!: boolean | undefined;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    lockWarning!: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (Array.isArray(data["twoFactorAuthProviders"])) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            this.refreshToken = data["refreshToken"];
            this.lockWarning = data["lockWarning"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (Array.isArray(this.twoFactorAuthProviders)) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["lockWarning"] = this.lockWarning;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    lockWarning: string | undefined;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        return data; 
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number | undefined;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number | undefined;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string]: string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
            if (data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in data["additionalParams"]) {
                    if (data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams![key] = data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string]: string; } | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    waitingForActivation!: boolean | undefined;
    returnUrl!: string | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
    returnUrl: string | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number | undefined;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean | undefined;
    roles!: UserListRoleDto[] | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    grantedPermissions!: string | undefined;
    divisionCode!: string | undefined;
    id!: number | undefined;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (Array.isArray(data["roles"])) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.grantedPermissions = data["grantedPermissions"];
            this.divisionCode = data["divisionCode"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["grantedPermissions"] = this.grantedPermissions;
        data["divisionCode"] = this.divisionCode;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    grantedPermissions: string | undefined;
    divisionCode: string | undefined;
    id: number | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto | undefined;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (Array.isArray(data["roles"])) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(data["allOrganizationUnits"])) {
                this.allOrganizationUnits = [] as any;
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
            }
            if (Array.isArray(data["memberedOrganizationUnits"])) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.allOrganizationUnits)) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.memberedOrganizationUnits)) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    isTwoFactorEnabled!: boolean | undefined;
    isLockoutEnabled!: boolean | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data; 
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean | undefined;
    inheritedFromOrganizationUnit!: boolean | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
            this.inheritedFromOrganizationUnit = data["inheritedFromOrganizationUnit"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        data["inheritedFromOrganizationUnit"] = this.inheritedFromOrganizationUnit;
        return data; 
    }
}

export interface IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;
    inheritedFromOrganizationUnit: boolean | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["permissions"])) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number | undefined;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfInt64 {
    id: number | undefined;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number | undefined;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (Array.isArray(data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    sendActivationEmail!: boolean | undefined;
    setRandomPassword!: boolean | undefined;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (Array.isArray(data["assignedRoleNames"])) {
                this.assignedRoleNames = [] as any;
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            if (Array.isArray(data["organizationUnits"])) {
                this.organizationUnits = [] as any;
                for (let item of data["organizationUnits"])
                    this.organizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.assignedRoleNames)) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (Array.isArray(this.organizationUnits)) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    organizationUnits: number[] | undefined;
}

export class UserLoginAttempt implements IUserLoginAttempt {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    userId!: number | undefined;
    userNameOrEmailAddress!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: AbpLoginResultType | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUserLoginAttempt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.userId = data["userId"];
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttempt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["userId"] = this.userId;
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginAttempt {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    userId: number | undefined;
    userNameOrEmailAddress: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: AbpLoginResultType | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export enum AbpLoginResultType {
    Success = 1,
    InvalidUserNameOrEmailAddress = 2,
    InvalidPassword = 3,
    UserIsNotActive = 4,
    InvalidTenancyName = 5,
    TenantIsNotActive = 6,
    UserEmailIsNotConfirmed = 7,
    UnknownExternalLogin = 8,
    LockedOut = 9,
    UserPhoneNumberIsNotConfirmed = 10,
}

export class PagedResultDtoOfGetUserAccessObjectForViewDto implements IPagedResultDtoOfGetUserAccessObjectForViewDto {
    totalCount!: number | undefined;
    items!: GetUserAccessObjectForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUserAccessObjectForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetUserAccessObjectForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUserAccessObjectForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUserAccessObjectForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetUserAccessObjectForViewDto {
    totalCount: number | undefined;
    items: GetUserAccessObjectForViewDto[] | undefined;
}

export class GetUserAccessObjectForViewDto implements IGetUserAccessObjectForViewDto {
    userAccessObject!: UserAccessObjectDto | undefined;
    idmsUsercUserID!: string | undefined;
    accessObjectcCode!: string | undefined;

    constructor(data?: IGetUserAccessObjectForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userAccessObject = data["userAccessObject"] ? UserAccessObjectDto.fromJS(data["userAccessObject"]) : <any>undefined;
            this.idmsUsercUserID = data["idmsUsercUserID"];
            this.accessObjectcCode = data["accessObjectcCode"];
        }
    }

    static fromJS(data: any): GetUserAccessObjectForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserAccessObjectForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userAccessObject"] = this.userAccessObject ? this.userAccessObject.toJSON() : <any>undefined;
        data["idmsUsercUserID"] = this.idmsUsercUserID;
        data["accessObjectcCode"] = this.accessObjectcCode;
        return data; 
    }
}

export interface IGetUserAccessObjectForViewDto {
    userAccessObject: UserAccessObjectDto | undefined;
    idmsUsercUserID: string | undefined;
    accessObjectcCode: string | undefined;
}

export class UserAccessObjectDto implements IUserAccessObjectDto {
    idmsUserId!: number | undefined;
    accessObjectId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUserAccessObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.idmsUserId = data["idmsUserId"];
            this.accessObjectId = data["accessObjectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserAccessObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAccessObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idmsUserId"] = this.idmsUserId;
        data["accessObjectId"] = this.accessObjectId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserAccessObjectDto {
    idmsUserId: number | undefined;
    accessObjectId: number | undefined;
    id: number | undefined;
}

export class GetUserAccessObjectForEditOutput implements IGetUserAccessObjectForEditOutput {
    userAccessObject!: CreateOrEditUserAccessObjectDto | undefined;
    idmsUsercUserID!: string | undefined;
    accessObjectcCode!: string | undefined;

    constructor(data?: IGetUserAccessObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userAccessObject = data["userAccessObject"] ? CreateOrEditUserAccessObjectDto.fromJS(data["userAccessObject"]) : <any>undefined;
            this.idmsUsercUserID = data["idmsUsercUserID"];
            this.accessObjectcCode = data["accessObjectcCode"];
        }
    }

    static fromJS(data: any): GetUserAccessObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserAccessObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userAccessObject"] = this.userAccessObject ? this.userAccessObject.toJSON() : <any>undefined;
        data["idmsUsercUserID"] = this.idmsUsercUserID;
        data["accessObjectcCode"] = this.accessObjectcCode;
        return data; 
    }
}

export interface IGetUserAccessObjectForEditOutput {
    userAccessObject: CreateOrEditUserAccessObjectDto | undefined;
    idmsUsercUserID: string | undefined;
    accessObjectcCode: string | undefined;
}

export class CreateOrEditUserAccessObjectDto implements ICreateOrEditUserAccessObjectDto {
    idmsUserId!: number | undefined;
    accessObjectId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditUserAccessObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.idmsUserId = data["idmsUserId"];
            this.accessObjectId = data["accessObjectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUserAccessObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserAccessObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idmsUserId"] = this.idmsUserId;
        data["accessObjectId"] = this.accessObjectId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditUserAccessObjectDto {
    idmsUserId: number | undefined;
    accessObjectId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfUserAccessObjectIDMSUserLookupTableDto implements IPagedResultDtoOfUserAccessObjectIDMSUserLookupTableDto {
    totalCount!: number | undefined;
    items!: UserAccessObjectIDMSUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserAccessObjectIDMSUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserAccessObjectIDMSUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserAccessObjectIDMSUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserAccessObjectIDMSUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserAccessObjectIDMSUserLookupTableDto {
    totalCount: number | undefined;
    items: UserAccessObjectIDMSUserLookupTableDto[] | undefined;
}

export class UserAccessObjectIDMSUserLookupTableDto implements IUserAccessObjectIDMSUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUserAccessObjectIDMSUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UserAccessObjectIDMSUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAccessObjectIDMSUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUserAccessObjectIDMSUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfUserAccessObjectAccessObjectLookupTableDto implements IPagedResultDtoOfUserAccessObjectAccessObjectLookupTableDto {
    totalCount!: number | undefined;
    items!: UserAccessObjectAccessObjectLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserAccessObjectAccessObjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserAccessObjectAccessObjectLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserAccessObjectAccessObjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserAccessObjectAccessObjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserAccessObjectAccessObjectLookupTableDto {
    totalCount: number | undefined;
    items: UserAccessObjectAccessObjectLookupTableDto[] | undefined;
}

export class UserAccessObjectAccessObjectLookupTableDto implements IUserAccessObjectAccessObjectLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUserAccessObjectAccessObjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UserAccessObjectAccessObjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAccessObjectAccessObjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUserAccessObjectAccessObjectLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetUserDatabaseAccessObjectForViewDto implements IPagedResultDtoOfGetUserDatabaseAccessObjectForViewDto {
    totalCount!: number | undefined;
    items!: GetUserDatabaseAccessObjectForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUserDatabaseAccessObjectForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetUserDatabaseAccessObjectForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUserDatabaseAccessObjectForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUserDatabaseAccessObjectForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetUserDatabaseAccessObjectForViewDto {
    totalCount: number | undefined;
    items: GetUserDatabaseAccessObjectForViewDto[] | undefined;
}

export class GetUserDatabaseAccessObjectForViewDto implements IGetUserDatabaseAccessObjectForViewDto {
    userDatabaseAccessObject!: UserDatabaseAccessObjectDto | undefined;
    idmsUsercFirstName!: string | undefined;
    accessObjectcCode!: string | undefined;
    databasecDatabaseName!: string | undefined;

    constructor(data?: IGetUserDatabaseAccessObjectForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userDatabaseAccessObject = data["userDatabaseAccessObject"] ? UserDatabaseAccessObjectDto.fromJS(data["userDatabaseAccessObject"]) : <any>undefined;
            this.idmsUsercFirstName = data["idmsUsercFirstName"];
            this.accessObjectcCode = data["accessObjectcCode"];
            this.databasecDatabaseName = data["databasecDatabaseName"];
        }
    }

    static fromJS(data: any): GetUserDatabaseAccessObjectForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDatabaseAccessObjectForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDatabaseAccessObject"] = this.userDatabaseAccessObject ? this.userDatabaseAccessObject.toJSON() : <any>undefined;
        data["idmsUsercFirstName"] = this.idmsUsercFirstName;
        data["accessObjectcCode"] = this.accessObjectcCode;
        data["databasecDatabaseName"] = this.databasecDatabaseName;
        return data; 
    }
}

export interface IGetUserDatabaseAccessObjectForViewDto {
    userDatabaseAccessObject: UserDatabaseAccessObjectDto | undefined;
    idmsUsercFirstName: string | undefined;
    accessObjectcCode: string | undefined;
    databasecDatabaseName: string | undefined;
}

export class UserDatabaseAccessObjectDto implements IUserDatabaseAccessObjectDto {
    idmsUserId!: number | undefined;
    accessObjectId!: number | undefined;
    databaseId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUserDatabaseAccessObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.idmsUserId = data["idmsUserId"];
            this.accessObjectId = data["accessObjectId"];
            this.databaseId = data["databaseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDatabaseAccessObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDatabaseAccessObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idmsUserId"] = this.idmsUserId;
        data["accessObjectId"] = this.accessObjectId;
        data["databaseId"] = this.databaseId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserDatabaseAccessObjectDto {
    idmsUserId: number | undefined;
    accessObjectId: number | undefined;
    databaseId: number | undefined;
    id: number | undefined;
}

export class GetUserDatabaseAccessObjectForEditOutput implements IGetUserDatabaseAccessObjectForEditOutput {
    userDatabaseAccessObject!: CreateOrEditUserDatabaseAccessObjectDto | undefined;
    idmsUsercFirstName!: string | undefined;
    accessObjectcCode!: string | undefined;
    databasecDatabaseName!: string | undefined;

    constructor(data?: IGetUserDatabaseAccessObjectForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userDatabaseAccessObject = data["userDatabaseAccessObject"] ? CreateOrEditUserDatabaseAccessObjectDto.fromJS(data["userDatabaseAccessObject"]) : <any>undefined;
            this.idmsUsercFirstName = data["idmsUsercFirstName"];
            this.accessObjectcCode = data["accessObjectcCode"];
            this.databasecDatabaseName = data["databasecDatabaseName"];
        }
    }

    static fromJS(data: any): GetUserDatabaseAccessObjectForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDatabaseAccessObjectForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDatabaseAccessObject"] = this.userDatabaseAccessObject ? this.userDatabaseAccessObject.toJSON() : <any>undefined;
        data["idmsUsercFirstName"] = this.idmsUsercFirstName;
        data["accessObjectcCode"] = this.accessObjectcCode;
        data["databasecDatabaseName"] = this.databasecDatabaseName;
        return data; 
    }
}

export interface IGetUserDatabaseAccessObjectForEditOutput {
    userDatabaseAccessObject: CreateOrEditUserDatabaseAccessObjectDto | undefined;
    idmsUsercFirstName: string | undefined;
    accessObjectcCode: string | undefined;
    databasecDatabaseName: string | undefined;
}

export class CreateOrEditUserDatabaseAccessObjectDto implements ICreateOrEditUserDatabaseAccessObjectDto {
    idmsUserId!: number | undefined;
    accessObjectId!: number | undefined;
    databaseId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditUserDatabaseAccessObjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.idmsUserId = data["idmsUserId"];
            this.accessObjectId = data["accessObjectId"];
            this.databaseId = data["databaseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUserDatabaseAccessObjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserDatabaseAccessObjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idmsUserId"] = this.idmsUserId;
        data["accessObjectId"] = this.accessObjectId;
        data["databaseId"] = this.databaseId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditUserDatabaseAccessObjectDto {
    idmsUserId: number | undefined;
    accessObjectId: number | undefined;
    databaseId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfUserDatabaseAccessObjectIDMSUserLookupTableDto implements IPagedResultDtoOfUserDatabaseAccessObjectIDMSUserLookupTableDto {
    totalCount!: number | undefined;
    items!: UserDatabaseAccessObjectIDMSUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDatabaseAccessObjectIDMSUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserDatabaseAccessObjectIDMSUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDatabaseAccessObjectIDMSUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDatabaseAccessObjectIDMSUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserDatabaseAccessObjectIDMSUserLookupTableDto {
    totalCount: number | undefined;
    items: UserDatabaseAccessObjectIDMSUserLookupTableDto[] | undefined;
}

export class UserDatabaseAccessObjectIDMSUserLookupTableDto implements IUserDatabaseAccessObjectIDMSUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUserDatabaseAccessObjectIDMSUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UserDatabaseAccessObjectIDMSUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDatabaseAccessObjectIDMSUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUserDatabaseAccessObjectIDMSUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfUserDatabaseAccessObjectAccessObjectLookupTableDto implements IPagedResultDtoOfUserDatabaseAccessObjectAccessObjectLookupTableDto {
    totalCount!: number | undefined;
    items!: UserDatabaseAccessObjectAccessObjectLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDatabaseAccessObjectAccessObjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserDatabaseAccessObjectAccessObjectLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDatabaseAccessObjectAccessObjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDatabaseAccessObjectAccessObjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserDatabaseAccessObjectAccessObjectLookupTableDto {
    totalCount: number | undefined;
    items: UserDatabaseAccessObjectAccessObjectLookupTableDto[] | undefined;
}

export class UserDatabaseAccessObjectAccessObjectLookupTableDto implements IUserDatabaseAccessObjectAccessObjectLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUserDatabaseAccessObjectAccessObjectLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UserDatabaseAccessObjectAccessObjectLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDatabaseAccessObjectAccessObjectLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUserDatabaseAccessObjectAccessObjectLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfUserDatabaseAccessObjectDatabaseLookupTableDto implements IPagedResultDtoOfUserDatabaseAccessObjectDatabaseLookupTableDto {
    totalCount!: number | undefined;
    items!: UserDatabaseAccessObjectDatabaseLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDatabaseAccessObjectDatabaseLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserDatabaseAccessObjectDatabaseLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDatabaseAccessObjectDatabaseLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDatabaseAccessObjectDatabaseLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserDatabaseAccessObjectDatabaseLookupTableDto {
    totalCount: number | undefined;
    items: UserDatabaseAccessObjectDatabaseLookupTableDto[] | undefined;
}

export class UserDatabaseAccessObjectDatabaseLookupTableDto implements IUserDatabaseAccessObjectDatabaseLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUserDatabaseAccessObjectDatabaseLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UserDatabaseAccessObjectDatabaseLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDatabaseAccessObjectDatabaseLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUserDatabaseAccessObjectDatabaseLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetUserDatabaseForViewDto implements IPagedResultDtoOfGetUserDatabaseForViewDto {
    totalCount!: number | undefined;
    items!: GetUserDatabaseForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUserDatabaseForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetUserDatabaseForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUserDatabaseForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUserDatabaseForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetUserDatabaseForViewDto {
    totalCount: number | undefined;
    items: GetUserDatabaseForViewDto[] | undefined;
}

export class GetUserDatabaseForViewDto implements IGetUserDatabaseForViewDto {
    userDatabase!: UserDatabaseDto | undefined;
    userName!: string | undefined;
    databasecDatabaseName!: string | undefined;

    constructor(data?: IGetUserDatabaseForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userDatabase = data["userDatabase"] ? UserDatabaseDto.fromJS(data["userDatabase"]) : <any>undefined;
            this.userName = data["userName"];
            this.databasecDatabaseName = data["databasecDatabaseName"];
        }
    }

    static fromJS(data: any): GetUserDatabaseForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDatabaseForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDatabase"] = this.userDatabase ? this.userDatabase.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["databasecDatabaseName"] = this.databasecDatabaseName;
        return data; 
    }
}

export interface IGetUserDatabaseForViewDto {
    userDatabase: UserDatabaseDto | undefined;
    userName: string | undefined;
    databasecDatabaseName: string | undefined;
}

export class UserDatabaseDto implements IUserDatabaseDto {
    userId!: number | undefined;
    databaseId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUserDatabaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.databaseId = data["databaseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDatabaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDatabaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["databaseId"] = this.databaseId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserDatabaseDto {
    userId: number | undefined;
    databaseId: number | undefined;
    id: number | undefined;
}

export class GetUserDatabaseForEditOutput implements IGetUserDatabaseForEditOutput {
    userDatabase!: CreateOrEditUserDatabaseDto | undefined;
    userName!: string | undefined;
    databasecDatabaseName!: string | undefined;

    constructor(data?: IGetUserDatabaseForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userDatabase = data["userDatabase"] ? CreateOrEditUserDatabaseDto.fromJS(data["userDatabase"]) : <any>undefined;
            this.userName = data["userName"];
            this.databasecDatabaseName = data["databasecDatabaseName"];
        }
    }

    static fromJS(data: any): GetUserDatabaseForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDatabaseForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDatabase"] = this.userDatabase ? this.userDatabase.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["databasecDatabaseName"] = this.databasecDatabaseName;
        return data; 
    }
}

export interface IGetUserDatabaseForEditOutput {
    userDatabase: CreateOrEditUserDatabaseDto | undefined;
    userName: string | undefined;
    databasecDatabaseName: string | undefined;
}

export class CreateOrEditUserDatabaseDto implements ICreateOrEditUserDatabaseDto {
    userId!: number | undefined;
    databaseId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditUserDatabaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.databaseId = data["databaseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUserDatabaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserDatabaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["databaseId"] = this.databaseId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditUserDatabaseDto {
    userId: number | undefined;
    databaseId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfUserDatabaseUserLookupTableDto implements IPagedResultDtoOfUserDatabaseUserLookupTableDto {
    totalCount!: number | undefined;
    items!: UserDatabaseUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDatabaseUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserDatabaseUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDatabaseUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDatabaseUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserDatabaseUserLookupTableDto {
    totalCount: number | undefined;
    items: UserDatabaseUserLookupTableDto[] | undefined;
}

export class UserDatabaseUserLookupTableDto implements IUserDatabaseUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUserDatabaseUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UserDatabaseUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDatabaseUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUserDatabaseUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfUserDatabaseDatabaseLookupTableDto implements IPagedResultDtoOfUserDatabaseDatabaseLookupTableDto {
    totalCount!: number | undefined;
    items!: UserDatabaseDatabaseLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDatabaseDatabaseLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserDatabaseDatabaseLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDatabaseDatabaseLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDatabaseDatabaseLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserDatabaseDatabaseLookupTableDto {
    totalCount: number | undefined;
    items: UserDatabaseDatabaseLookupTableDto[] | undefined;
}

export class UserDatabaseDatabaseLookupTableDto implements IUserDatabaseDatabaseLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUserDatabaseDatabaseLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UserDatabaseDatabaseLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDatabaseDatabaseLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUserDatabaseDatabaseLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetUserDivisionForViewDto implements IPagedResultDtoOfGetUserDivisionForViewDto {
    totalCount!: number | undefined;
    items!: GetUserDivisionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUserDivisionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetUserDivisionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUserDivisionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUserDivisionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetUserDivisionForViewDto {
    totalCount: number | undefined;
    items: GetUserDivisionForViewDto[] | undefined;
}

export class GetUserDivisionForViewDto implements IGetUserDivisionForViewDto {
    userDivision!: UserDivisionDto | undefined;
    tblUsercFirstName!: string | undefined;
    divisioncDivisionName!: string | undefined;

    constructor(data?: IGetUserDivisionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userDivision = data["userDivision"] ? UserDivisionDto.fromJS(data["userDivision"]) : <any>undefined;
            this.tblUsercFirstName = data["tblUsercFirstName"];
            this.divisioncDivisionName = data["divisioncDivisionName"];
        }
    }

    static fromJS(data: any): GetUserDivisionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDivisionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDivision"] = this.userDivision ? this.userDivision.toJSON() : <any>undefined;
        data["tblUsercFirstName"] = this.tblUsercFirstName;
        data["divisioncDivisionName"] = this.divisioncDivisionName;
        return data; 
    }
}

export interface IGetUserDivisionForViewDto {
    userDivision: UserDivisionDto | undefined;
    tblUsercFirstName: string | undefined;
    divisioncDivisionName: string | undefined;
}

export class UserDivisionDto implements IUserDivisionDto {
    userID!: number | undefined;
    divisionID!: number | undefined;
    iSelectedBuildID!: number | undefined;
    iSelectedDatabaseID!: number | undefined;
    cCreatedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUserDivisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userID = data["userID"];
            this.divisionID = data["divisionID"];
            this.iSelectedBuildID = data["iSelectedBuildID"];
            this.iSelectedDatabaseID = data["iSelectedDatabaseID"];
            this.cCreatedBy = data["cCreatedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDivisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDivisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userID"] = this.userID;
        data["divisionID"] = this.divisionID;
        data["iSelectedBuildID"] = this.iSelectedBuildID;
        data["iSelectedDatabaseID"] = this.iSelectedDatabaseID;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserDivisionDto {
    userID: number | undefined;
    divisionID: number | undefined;
    iSelectedBuildID: number | undefined;
    iSelectedDatabaseID: number | undefined;
    cCreatedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    id: number | undefined;
}

export class GetUserDivisionForEditOutput implements IGetUserDivisionForEditOutput {
    userDivision!: CreateOrEditUserDivisionDto | undefined;
    tblUsercFirstName!: string | undefined;
    divisioncDivisionName!: string | undefined;

    constructor(data?: IGetUserDivisionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userDivision = data["userDivision"] ? CreateOrEditUserDivisionDto.fromJS(data["userDivision"]) : <any>undefined;
            this.tblUsercFirstName = data["tblUsercFirstName"];
            this.divisioncDivisionName = data["divisioncDivisionName"];
        }
    }

    static fromJS(data: any): GetUserDivisionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDivisionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDivision"] = this.userDivision ? this.userDivision.toJSON() : <any>undefined;
        data["tblUsercFirstName"] = this.tblUsercFirstName;
        data["divisioncDivisionName"] = this.divisioncDivisionName;
        return data; 
    }
}

export interface IGetUserDivisionForEditOutput {
    userDivision: CreateOrEditUserDivisionDto | undefined;
    tblUsercFirstName: string | undefined;
    divisioncDivisionName: string | undefined;
}

export class CreateOrEditUserDivisionDto implements ICreateOrEditUserDivisionDto {
    userID!: number | undefined;
    divisionID!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditUserDivisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userID = data["userID"];
            this.divisionID = data["divisionID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUserDivisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserDivisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userID"] = this.userID;
        data["divisionID"] = this.divisionID;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditUserDivisionDto {
    userID: number | undefined;
    divisionID: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfUserDivisiontblUserLookupTableDto implements IPagedResultDtoOfUserDivisiontblUserLookupTableDto {
    totalCount!: number | undefined;
    items!: UserDivisiontblUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDivisiontblUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserDivisiontblUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDivisiontblUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDivisiontblUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserDivisiontblUserLookupTableDto {
    totalCount: number | undefined;
    items: UserDivisiontblUserLookupTableDto[] | undefined;
}

export class UserDivisiontblUserLookupTableDto implements IUserDivisiontblUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUserDivisiontblUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UserDivisiontblUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDivisiontblUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUserDivisiontblUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfUserDivisionDivisionLookupTableDto implements IPagedResultDtoOfUserDivisionDivisionLookupTableDto {
    totalCount!: number | undefined;
    items!: UserDivisionDivisionLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDivisionDivisionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserDivisionDivisionLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDivisionDivisionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDivisionDivisionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserDivisionDivisionLookupTableDto {
    totalCount: number | undefined;
    items: UserDivisionDivisionLookupTableDto[] | undefined;
}

export class UserDivisionDivisionLookupTableDto implements IUserDivisionDivisionLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUserDivisionDivisionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UserDivisionDivisionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDivisionDivisionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUserDivisionDivisionLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetUserGroupForViewDto implements IPagedResultDtoOfGetUserGroupForViewDto {
    totalCount!: number | undefined;
    items!: GetUserGroupForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUserGroupForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetUserGroupForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUserGroupForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUserGroupForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetUserGroupForViewDto {
    totalCount: number | undefined;
    items: GetUserGroupForViewDto[] | undefined;
}

export class GetUserGroupForViewDto implements IGetUserGroupForViewDto {
    userGroup!: UserGroupDto | undefined;
    tblUsercFirstName!: string | undefined;

    constructor(data?: IGetUserGroupForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userGroup = data["userGroup"] ? UserGroupDto.fromJS(data["userGroup"]) : <any>undefined;
            this.tblUsercFirstName = data["tblUsercFirstName"];
        }
    }

    static fromJS(data: any): GetUserGroupForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserGroupForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userGroup"] = this.userGroup ? this.userGroup.toJSON() : <any>undefined;
        data["tblUsercFirstName"] = this.tblUsercFirstName;
        return data; 
    }
}

export interface IGetUserGroupForViewDto {
    userGroup: UserGroupDto | undefined;
    tblUsercFirstName: string | undefined;
}

export class UserGroupDto implements IUserGroupDto {
    userId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUserGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserGroupDto {
    userId: number | undefined;
    id: number | undefined;
}

export class GetUserGroupForEditOutput implements IGetUserGroupForEditOutput {
    userGroup!: CreateOrEditUserGroupDto | undefined;
    tblUsercFirstName!: string | undefined;

    constructor(data?: IGetUserGroupForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userGroup = data["userGroup"] ? CreateOrEditUserGroupDto.fromJS(data["userGroup"]) : <any>undefined;
            this.tblUsercFirstName = data["tblUsercFirstName"];
        }
    }

    static fromJS(data: any): GetUserGroupForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserGroupForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userGroup"] = this.userGroup ? this.userGroup.toJSON() : <any>undefined;
        data["tblUsercFirstName"] = this.tblUsercFirstName;
        return data; 
    }
}

export interface IGetUserGroupForEditOutput {
    userGroup: CreateOrEditUserGroupDto | undefined;
    tblUsercFirstName: string | undefined;
}

export class CreateOrEditUserGroupDto implements ICreateOrEditUserGroupDto {
    userId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditUserGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUserGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditUserGroupDto {
    userId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfUserGroupTblUserLookupTableDto implements IPagedResultDtoOfUserGroupTblUserLookupTableDto {
    totalCount!: number | undefined;
    items!: UserGroupTblUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserGroupTblUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserGroupTblUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserGroupTblUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserGroupTblUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserGroupTblUserLookupTableDto {
    totalCount: number | undefined;
    items: UserGroupTblUserLookupTableDto[] | undefined;
}

export class UserGroupTblUserLookupTableDto implements IUserGroupTblUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUserGroupTblUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UserGroupTblUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserGroupTblUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUserGroupTblUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number | undefined;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    id!: number | undefined;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class PagedResultDtoOfGetUserReportForViewDto implements IPagedResultDtoOfGetUserReportForViewDto {
    totalCount!: number | undefined;
    items!: GetUserReportForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUserReportForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetUserReportForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUserReportForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUserReportForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetUserReportForViewDto {
    totalCount: number | undefined;
    items: GetUserReportForViewDto[] | undefined;
}

export class GetUserReportForViewDto implements IGetUserReportForViewDto {
    userReport!: UserReportDto | undefined;
    tblUsercFirstName!: string | undefined;
    reportcReportName!: string | undefined;

    constructor(data?: IGetUserReportForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userReport = data["userReport"] ? UserReportDto.fromJS(data["userReport"]) : <any>undefined;
            this.tblUsercFirstName = data["tblUsercFirstName"];
            this.reportcReportName = data["reportcReportName"];
        }
    }

    static fromJS(data: any): GetUserReportForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserReportForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userReport"] = this.userReport ? this.userReport.toJSON() : <any>undefined;
        data["tblUsercFirstName"] = this.tblUsercFirstName;
        data["reportcReportName"] = this.reportcReportName;
        return data; 
    }
}

export interface IGetUserReportForViewDto {
    userReport: UserReportDto | undefined;
    tblUsercFirstName: string | undefined;
    reportcReportName: string | undefined;
}

export class UserReportDto implements IUserReportDto {
    reportID!: number | undefined;
    tblUserId!: number | undefined;
    reportId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUserReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportID = data["reportID"];
            this.tblUserId = data["tblUserId"];
            this.reportId = data["reportId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportID"] = this.reportID;
        data["tblUserId"] = this.tblUserId;
        data["reportId"] = this.reportId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserReportDto {
    reportID: number | undefined;
    tblUserId: number | undefined;
    reportId: number | undefined;
    id: number | undefined;
}

export class GetUserReportForEditOutput implements IGetUserReportForEditOutput {
    userReport!: CreateOrEditUserReportDto | undefined;
    tblUsercFirstName!: string | undefined;
    reportcReportName!: string | undefined;

    constructor(data?: IGetUserReportForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userReport = data["userReport"] ? CreateOrEditUserReportDto.fromJS(data["userReport"]) : <any>undefined;
            this.tblUsercFirstName = data["tblUsercFirstName"];
            this.reportcReportName = data["reportcReportName"];
        }
    }

    static fromJS(data: any): GetUserReportForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserReportForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userReport"] = this.userReport ? this.userReport.toJSON() : <any>undefined;
        data["tblUsercFirstName"] = this.tblUsercFirstName;
        data["reportcReportName"] = this.reportcReportName;
        return data; 
    }
}

export interface IGetUserReportForEditOutput {
    userReport: CreateOrEditUserReportDto | undefined;
    tblUsercFirstName: string | undefined;
    reportcReportName: string | undefined;
}

export class CreateOrEditUserReportDto implements ICreateOrEditUserReportDto {
    userID!: number | undefined;
    reportID!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditUserReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userID = data["userID"];
            this.reportID = data["reportID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUserReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userID"] = this.userID;
        data["reportID"] = this.reportID;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditUserReportDto {
    userID: number | undefined;
    reportID: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfUserReportTblUserLookupTableDto implements IPagedResultDtoOfUserReportTblUserLookupTableDto {
    totalCount!: number | undefined;
    items!: UserReportTblUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserReportTblUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserReportTblUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserReportTblUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserReportTblUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserReportTblUserLookupTableDto {
    totalCount: number | undefined;
    items: UserReportTblUserLookupTableDto[] | undefined;
}

export class UserReportTblUserLookupTableDto implements IUserReportTblUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUserReportTblUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UserReportTblUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserReportTblUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUserReportTblUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfUserReportReportLookupTableDto implements IPagedResultDtoOfUserReportReportLookupTableDto {
    totalCount!: number | undefined;
    items!: UserReportReportLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserReportReportLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserReportReportLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserReportReportLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserReportReportLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserReportReportLookupTableDto {
    totalCount: number | undefined;
    items: UserReportReportLookupTableDto[] | undefined;
}

export class UserReportReportLookupTableDto implements IUserReportReportLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUserReportReportLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UserReportReportLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserReportReportLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUserReportReportLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetUserSavedSelectionDetailForViewDto implements IPagedResultDtoOfGetUserSavedSelectionDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetUserSavedSelectionDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUserSavedSelectionDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetUserSavedSelectionDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUserSavedSelectionDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUserSavedSelectionDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetUserSavedSelectionDetailForViewDto {
    totalCount: number | undefined;
    items: GetUserSavedSelectionDetailForViewDto[] | undefined;
}

export class GetUserSavedSelectionDetailForViewDto implements IGetUserSavedSelectionDetailForViewDto {
    userSavedSelectionDetail!: UserSavedSelectionDetailDto | undefined;
    userSavedSelectioncDescription!: string | undefined;

    constructor(data?: IGetUserSavedSelectionDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userSavedSelectionDetail = data["userSavedSelectionDetail"] ? UserSavedSelectionDetailDto.fromJS(data["userSavedSelectionDetail"]) : <any>undefined;
            this.userSavedSelectioncDescription = data["userSavedSelectioncDescription"];
        }
    }

    static fromJS(data: any): GetUserSavedSelectionDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserSavedSelectionDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userSavedSelectionDetail"] = this.userSavedSelectionDetail ? this.userSavedSelectionDetail.toJSON() : <any>undefined;
        data["userSavedSelectioncDescription"] = this.userSavedSelectioncDescription;
        return data; 
    }
}

export interface IGetUserSavedSelectionDetailForViewDto {
    userSavedSelectionDetail: UserSavedSelectionDetailDto | undefined;
    userSavedSelectioncDescription: string | undefined;
}

export class UserSavedSelectionDetailDto implements IUserSavedSelectionDetailDto {
    userSavedSelectionId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUserSavedSelectionDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userSavedSelectionId = data["userSavedSelectionId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserSavedSelectionDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSavedSelectionDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userSavedSelectionId"] = this.userSavedSelectionId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserSavedSelectionDetailDto {
    userSavedSelectionId: number | undefined;
    id: number | undefined;
}

export class GetUserSavedSelectionDetailForEditOutput implements IGetUserSavedSelectionDetailForEditOutput {
    userSavedSelectionDetail!: CreateOrEditUserSavedSelectionDetailDto | undefined;
    userSavedSelectioncDescription!: string | undefined;

    constructor(data?: IGetUserSavedSelectionDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userSavedSelectionDetail = data["userSavedSelectionDetail"] ? CreateOrEditUserSavedSelectionDetailDto.fromJS(data["userSavedSelectionDetail"]) : <any>undefined;
            this.userSavedSelectioncDescription = data["userSavedSelectioncDescription"];
        }
    }

    static fromJS(data: any): GetUserSavedSelectionDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserSavedSelectionDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userSavedSelectionDetail"] = this.userSavedSelectionDetail ? this.userSavedSelectionDetail.toJSON() : <any>undefined;
        data["userSavedSelectioncDescription"] = this.userSavedSelectioncDescription;
        return data; 
    }
}

export interface IGetUserSavedSelectionDetailForEditOutput {
    userSavedSelectionDetail: CreateOrEditUserSavedSelectionDetailDto | undefined;
    userSavedSelectioncDescription: string | undefined;
}

export class CreateOrEditUserSavedSelectionDetailDto implements ICreateOrEditUserSavedSelectionDetailDto {
    userSavedSelectionId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditUserSavedSelectionDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userSavedSelectionId = data["userSavedSelectionId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUserSavedSelectionDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserSavedSelectionDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userSavedSelectionId"] = this.userSavedSelectionId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditUserSavedSelectionDetailDto {
    userSavedSelectionId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfUserSavedSelectionDetailUserSavedSelectionLookupTableDto implements IPagedResultDtoOfUserSavedSelectionDetailUserSavedSelectionLookupTableDto {
    totalCount!: number | undefined;
    items!: UserSavedSelectionDetailUserSavedSelectionLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserSavedSelectionDetailUserSavedSelectionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserSavedSelectionDetailUserSavedSelectionLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserSavedSelectionDetailUserSavedSelectionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserSavedSelectionDetailUserSavedSelectionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserSavedSelectionDetailUserSavedSelectionLookupTableDto {
    totalCount: number | undefined;
    items: UserSavedSelectionDetailUserSavedSelectionLookupTableDto[] | undefined;
}

export class UserSavedSelectionDetailUserSavedSelectionLookupTableDto implements IUserSavedSelectionDetailUserSavedSelectionLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUserSavedSelectionDetailUserSavedSelectionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UserSavedSelectionDetailUserSavedSelectionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSavedSelectionDetailUserSavedSelectionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUserSavedSelectionDetailUserSavedSelectionLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class CreateOrEditUserSavedSelectionDto implements ICreateOrEditUserSavedSelectionDto {
    cDescription!: string | undefined;
    iIsActive!: boolean | undefined;
    cChannelType!: string | undefined;
    iIsDefault!: boolean | undefined;
    userID!: number | undefined;
    databaseId!: number | undefined;
    cCreatedBy!: string | undefined;
    dCreatedDate!: moment.Moment | undefined;
    cModifiedBy!: string | undefined;
    dModifiedDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditUserSavedSelectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cDescription = data["cDescription"];
            this.iIsActive = data["iIsActive"];
            this.cChannelType = data["cChannelType"];
            this.iIsDefault = data["iIsDefault"];
            this.userID = data["userID"];
            this.databaseId = data["databaseId"];
            this.cCreatedBy = data["cCreatedBy"];
            this.dCreatedDate = data["dCreatedDate"] ? moment(data["dCreatedDate"].toString()) : <any>undefined;
            this.cModifiedBy = data["cModifiedBy"];
            this.dModifiedDate = data["dModifiedDate"] ? moment(data["dModifiedDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUserSavedSelectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserSavedSelectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cDescription"] = this.cDescription;
        data["iIsActive"] = this.iIsActive;
        data["cChannelType"] = this.cChannelType;
        data["iIsDefault"] = this.iIsDefault;
        data["userID"] = this.userID;
        data["databaseId"] = this.databaseId;
        data["cCreatedBy"] = this.cCreatedBy;
        data["dCreatedDate"] = this.dCreatedDate ? this.dCreatedDate.toISOString() : <any>undefined;
        data["cModifiedBy"] = this.cModifiedBy;
        data["dModifiedDate"] = this.dModifiedDate ? this.dModifiedDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditUserSavedSelectionDto {
    cDescription: string | undefined;
    iIsActive: boolean | undefined;
    cChannelType: string | undefined;
    iIsDefault: boolean | undefined;
    userID: number | undefined;
    databaseId: number | undefined;
    cCreatedBy: string | undefined;
    dCreatedDate: moment.Moment | undefined;
    cModifiedBy: string | undefined;
    dModifiedDate: moment.Moment | undefined;
    id: number | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["latestWebLogLines"])) {
                this.latestWebLogLines = [] as any;
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.latestWebLogLines)) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class AdditionalData implements IAdditionalData {
    paypal!: { [key: string]: string; } | undefined;
    stripe!: { [key: string]: string; } | undefined;

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {} as any;
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal![key] = data["Paypal"][key];
                }
            }
            if (data["Stripe"]) {
                this.stripe = {} as any;
                for (let key in data["Stripe"]) {
                    if (data["Stripe"].hasOwnProperty(key))
                        this.stripe![key] = data["Stripe"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        if (this.stripe) {
            data["Stripe"] = {};
            for (let key in this.stripe) {
                if (this.stripe.hasOwnProperty(key))
                    data["Stripe"][key] = this.stripe[key];
            }
        }
        return data; 
    }
}

export interface IAdditionalData {
    paypal: { [key: string]: string; } | undefined;
    stripe: { [key: string]: string; } | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}